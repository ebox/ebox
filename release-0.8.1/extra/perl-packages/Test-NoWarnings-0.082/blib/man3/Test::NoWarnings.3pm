.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.14
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Test::NoWarnings 3pm"
.TH Test::NoWarnings 3pm "2005-10-08" "perl v5.8.4" "User Contributed Perl Documentation"
.SH "NAME"
Test::NoWarnings \- Make sure you didn't emit any warnings while testing
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
For scripts that have no plan
.PP
.Vb 1
\&  use Test::NoWarnings;
.Ve
.PP
that's it, you don't need to do anything else
.PP
For scripts that look like
.PP
.Vb 1
\&  use Test::More tests => x;
.Ve
.PP
change to  
.PP
.Vb 2
\&  use Test::More tests => x + 1;
\&  use Test::NoWarnings;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
In general, your tests shouldn't produce warnings. This modules causes any
warnings to be captured and stored. It automatically adds an extra test that
will run when your script ends to check that there were no warnings. If
there were any warings, the test will give a \*(L"not ok\*(R" and diagnostics of
where, when and what the warning was, including a stack trace of what was
going on when the it occurred.
.PP
If some of your tests \fBare supposed to\fR produce warnings then you should be
capturing and checking them with Test::Warn, that way Test::NoWarnings
will not see them and so not complain.
.PP
The test is run by an \s-1END\s0 block in Test::NoWarnings. It will not be run when
any forked children exit.
.SH "USAGE"
.IX Header "USAGE"
Simply by using the module, you automatically get an extra test at the end
of your script that checks that no warnings were emitted. So just stick
.PP
.Vb 1
\&  use Test::NoWarnings
.Ve
.PP
at the top of your script and continue as normal.
.PP
If you want more control you can invoke the test manually at any time with
\&\f(CW\*(C`had_no_warnings()\*(C'\fR.
.PP
The warnings your test has generated so far are stored in an array. You can
look inside and clear this whenever you want with \f(CW\*(C`warnings()\*(C'\fR and
\&\f(CW\*(C`clear_warnings()\*(C'\fR, however, if you are doing this sort of thing then you
probably want to use Test::Warn in combination with Test::NoWarnings.
.SH "USE vs REQUIRE"
.IX Header "USE vs REQUIRE"
You will almost always want to do
.PP
.Vb 1
\&  use Test::NoWarnings
.Ve
.PP
If you do a \f(CW\*(C`require\*(C'\fR rather than a \f(CW\*(C`use\*(C'\fR, then there will be no automatic
test at the end of your script.
.SH "OUTPUT"
.IX Header "OUTPUT"
If warning is captured during your test then the details will output as part
of the diagnostics. You will get:
.IP "o" 2
the number and name of the test that was executed just before the warning
(if no test had been executed these will be 0 and '')
.IP "o" 2
the message passed to \f(CW\*(C`warn\*(C'\fR,
.IP "o" 2
a full dump of the stack when warn was called, courtesy of the \f(CW\*(C`Carp\*(C'\fR
module
.SH "EXPORTABLE FUNCTIONS"
.IX Header "EXPORTABLE FUNCTIONS"
.Sh "\fIhad_no_warnings()\fP"
.IX Subsection "had_no_warnings()"
This checks that there have been warnings emitted by your test scripts.
Usually you will not call this explicitly as it is called automatically when
your script finishes.
.Sh "\fIclear_warnings()\fP"
.IX Subsection "clear_warnings()"
This will clear the array of warnings that have been captured. If the array
is empty then a call to \f(CW\*(C`had_no_warnings()\*(C'\fR will produce a pass result.
.Sh "\fIwarnings()\fP"
.IX Subsection "warnings()"
This will return the array of warnings captured so far. Each element of this
array is an object containing information about the warning. The following
methods are available on these object.
.IP "\(bu" 2
$warn\->getMessage
.Sp
Get the message that would been printed by the warning.
.IP "\(bu" 2
$warn\->getCarp
.Sp
Get a stack trace of what was going on when the warning happened, this stack
trace is just a string generated by the Carp module.
.IP "\(bu" 2
$warn\->getTrace
.Sp
Get a stack trace object generated by the Devel::StackTrace module. This
will return undef if Devel::StackTrace is not installed.
.IP "\(bu" 2
$warn\->getTest
.Sp
Get the number of the test that executed before the warning was emitted.
.IP "\(bu" 2
$warn\->getTestName
.Sp
Get the name of the test that executed before the warning was emitted.
.SH "PITFALLS"
.IX Header "PITFALLS"
When counting your tests for the plan, don't forget to include the test that
runs automatically when your script ends.
.SH "BUGS"
.IX Header "BUGS"
None that I know of.
.SH "HISTORY"
.IX Header "HISTORY"
This was previously known as Test::Warn::None
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Test::Builder, Test::Warn
.SH "AUTHOR"
.IX Header "AUTHOR"
Written by Fergal Daly <fergal@esatclear.ie>.
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 2003 by Fergal Daly <fergal@esatclear.ie>.
.PP
This program is free software and comes with no warranty. It is distributed
under the \s-1LGPL\s0 license
.PP
See the file \fI\s-1LGPL\s0\fR included in this distribution or
\&\fIhttp://www.fsf.org/licenses/licenses.html\fR.
