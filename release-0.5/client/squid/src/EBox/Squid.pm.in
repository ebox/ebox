# Copyright (C) 2004  Warp Netwoks S.L.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License, version 2, as
# published by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

package EBox::Squid;
use strict;
use warnings;

use base 'EBox::GConfModule';

use EBox::Objects;
use EBox::Global;
use EBox::Config;
use EBox::Firewall;
use EBox::Validate qw( :all );
use EBox::Exceptions::InvalidData;
use EBox::Exceptions::Internal;
use EBox::Exceptions::DataNotFound;
use EBox::SquidFirewall;
use EBox::SquidOnlyFirewall;
use EBox::Summary::Module;
use EBox::Summary::Value;
use EBox::Summary::Status;
use EBox::Summary::Section;
use EBox::Sudo qw( :all );
use EBox::Gettext;
use Error qw(:try);
use HTML::Mason;


#Module local conf stuff
use constant SQUIDCONFFILE => "@SQUIDCONF@";
use constant SQUIDINIT     => "/etc/init.d/squid";
use constant DGINIT     => "/etc/init.d/dansguardian";
use constant PIDFILE       => "/var/run/squid.pid";
use constant DGPIDFILE	=> "/var/run/dansguardian.pid";
use constant MAXDOMAINSIZ 		=> 255; 
use constant SQUIDPORT => '3128';
use constant DGPORT => '3129';
use constant DGDIR => '/etc/dansguardian';


sub _create 
{
	my $class = shift;
	my $self  = $class->SUPER::_create(name => 'squid', 
					   domain => 'ebox-squid',
					   @_);
	$self->{logger} = EBox::Global->logger();
	bless ($self, $class);
	return $self;
}

sub isRunning
{
	my $self = shift;
	return $self->pidFileRunning(PIDFILE);
}

sub DGIsRunning
{
	my $self = shift;
	return $self->pidFileRunning(DGPIDFILE);
}

sub _doDaemon
{
	my $self = shift;
	my $action = undef;

	if ($self->service and $self->isRunning) {
		$action = 'reload';
	} elsif ($self->service) {
		$action = 'start';
	} elsif ($self->isRunning) {
		$action = 'stop';
	} else {
		return;
	}

	my $command =  SQUIDINIT . " " . $action . " 2>&1";
	root($command);
}

sub _doDGDaemon
{
	my $self = shift;
	my $action = undef;

	if ($self->_dgNeeded and $self->DGIsRunning) {
		$action = 'restart';
	} elsif ($self->_dgNeeded) {
		$action = 'start';
	} elsif ($self->DGIsRunning) {
		$action = 'stop';
	} else {
		return;
	}

	my $dgcommand =  DGINIT . " " . $action . " 2>&1";
	root($dgcommand);
}
sub _stopService 
{
	my $self = shift;
	if ($self->isRunning) {
		root(SQUIDINIT . " stop 2>&1");
	}
	if ($self->DGIsRunning) {
		root(DGINIT . " stop 2>&1");
	}
	
}
#Override virtual method in base class
#This method should be called anytime  object's conf changes
#Restart service if module active
sub _regenConfig 
{
	my $self = shift;
	$self->_setSquidConf;
	$self->_doDaemon();
	$self->_doDGDaemon();
}

#Override virtual method in base class
#Arguments:
#	- Object name
#Returns:
#	- True if  used by this module
#	- False if not used by this module
sub usesObject # (object)
{
	my ($self, $object) = @_;
	if ($self->isUnfiltered($object) or $self->isBan($object)) {
		return 1;
	}
	return undef;
}

#Override virtual method in base class
#Arguments:
#	- Object name
sub freeObject # (object) 
{
	my ($self, $object) = @_;
	(defined($object) && $object ne "") or return;

	my @unfiltered = @{$self->unfiltered};
	my @bans = @{$self->bans};

	if (grep(/^$object$/, @unfiltered)) {
		my @array = ();
		foreach (@unfiltered) {
			($_ ne $object) or next;
			push(@array, $_)
		}
		$self->setUnfiltered(\@array);
	}

	if (grep(/^$object$/, @bans)) {
		my @array = ();
		foreach (@bans) {
			($_ ne $object) or next;
			push(@array, $_)
		}
		$self->setBans(\@array);
	}
}

#
#Par: 0- Array with object names
sub setUnfiltered # (\@objects)
{
	my ($self, $args) = @_;
	my $objects = EBox::Global->modInstance('objects');
	$self->unset("unfiltered");
	($args) or return;
	my @bans = @{$self->bans};
	my $bansflag = undef;
	foreach my $obj (@{$args}) {	
		$objects->objectExists($obj) or
			throw EBox::Exceptions::DataNotFound(
				'data' => __("object"), 'value' => $obj);
		if (grep(/^$obj$/, @bans)) {
			@bans = grep(!/^$obj$/, @bans);
			$bansflag = 1;
		}
        }
	$self->set_list("unfiltered", "string", $args);
	$bansflag and $self->setBans(\@bans);
}

#returns:
#	- array reference 
sub filtered
{
	my $self = shift;
	my $objects = EBox::Global->modInstance('objects');
	my @no = @{$self->unfiltered};
	push(@no, @{$self->bans});
	my @names = @{$objects->ObjectNames};
	my @filtered = ();
	foreach my $n (@names) {
		unless (grep(/^$n$/, @no)) {
			push(@filtered, $n);
		}
	}
	return \@filtered;
}

#returns:
#	- array reference 
sub unfiltered
{
	my $self = shift;
	return $self->get_list("unfiltered");
}

#
sub isUnfiltered # ($object)
{
	my ($self, $object) = @_;
	my $unfiltered = $self->unfiltered();
	foreach (@{$unfiltered}) {
		return 1 if ($_ eq $object);
	}
	return undef;
}

#creates bans
#Par: 0- Array with object names
sub setBans # (\@objects)
{
	my ($self, $args) = @_;
	my $objects = EBox::Global->modInstance('objects');
	$self->unset("bans");
	($args) or return;
	my @unfiltered = @{$self->unfiltered};
	my $unfilteredflag = undef;
	foreach my $obj (@{$args}) {	
		$objects->objectExists($obj) or
			throw EBox::Exceptions::DataNotFound(
				'data' => __("object"), 'value' => $obj);
		if (grep(/^$obj$/, @unfiltered)) {
			@unfiltered = grep(!/^$obj$/, @unfiltered);
			$unfilteredflag = 1;
		}
        }
	$self->set_list("bans", "string", $args);
	$unfilteredflag and $self->setUnfiltered(\@unfiltered);
}

#returns:
#	- array reference 
sub bans
{
	my $self = shift;
	return $self->get_list("bans");
}

#returns true if an Object is banned
sub isBan # ($object)
{
	my ($self, $object) = @_;
	my $bans = $self->bans();
	foreach (@{$bans}) {
		return 1 if ($_ eq $object);
	}
	return undef;
}

#sets authentication 
#Par: 0 -> boolean
sub setAuth # (auth)
{
	my ($self, $auth) = @_;
	($auth and $self->auth) and return;
	(!$auth and !$self->auth) and return;
	$self->set_bool('auth', $auth);
}

#returns authentication 
#ret: boolean
sub auth
{
	my $self = shift;
	return $self->get_bool('auth');
}

#sets activation service --- servicio de activacion????
#Par: 0-> boolean
sub setService # (enabled) 
{
	my ($self, $active) = @_;
	($active and $self->service) and return;
	(!$active and !$self->service) and return;
	$self->set_bool('active', $active);
}

#returns if service is active or not
#ret: bool
sub service
{
	my $self = shift;    	
	return $self->get_bool('active');
}

#sets transparent proxy service
#Par: 0-> 'yes'|'no
sub setTransproxy # (enabled)
{
	my ($self, $trans) = @_;
	($trans and $self->transproxy) and return undef;
	(!$trans and !$self->transproxy) and return undef;
	$self->set_bool('transproxy', $trans);
	return 1;
}

#returns if service is active or not
#ret:
sub transproxy
{
	my $self = shift;    	
	return $self->get_bool('transproxy');
}

#sets port service
#Par: 0-> port_number
sub setPort # (port)
{
	my ($self, $port) = @_;
	my $fw = EBox::Global->modInstance('firewall');
	checkPort($port, "listening port");
	my $currentport = $self->port();	
	if ($currentport == $port) {
		return;
	}
	unless ($fw->availablePort($port)) {
		throw EBox::Exceptions::DataExists(
					'data'  => __('listening port'),
					'value' => $port);
	}					
	if ($port eq $self->port) {
		return undef;
	}
	$self->set_int("port", $port);
	return 1;
}

#returns port_number
#ret: port_number
sub port
{
	my $self = shift;    	
	return $self->get_int("port");
}

#returns
# 	- Array with banned domains
sub bannedDomains
{
	my $self = shift;
	return $self->get_list("banned_sites");
}

#arguments
#	- string: forbidden domain
#returns
#	- true if exists
#	- false if not
sub bannedDomainExists # (domain)
{
	my $self = shift;
	my $domain = shift;

	foreach (@{$self->bannedDomains()}) {
		return 1 if ($_ eq $domain);
	}
	return undef;
}

sub _checkDomainName # (domain)
{
	my $self = shift;
	my $domain = shift;
	
	unless (length($domain) < MAXDOMAINSIZ) {
		return undef;
	}
	unless ($domain =~ /^[^\.\-][\w\.\-]+[^\-]$/) {
		return undef;
	}
	return 1;
}

sub ipBlocked #
{
	my $self = shift;
	return $self->get_bool("block_ip");
}

sub setIpBlocked #
{
	my ($self, $block) = @_;
	if ($block && $self->ipBlocked) {
		return;
	} elsif (!$block && !$self->ipBlocked){
		return;
	}
	$self->set_bool("block_ip", $block);
}

# allow | deny | filter
sub globalPolicy #
{
	my $self = shift;
	return $self->get_string("policy");
}

sub setGlobalPolicy #
{
	my ($self, $policy) = @_;
	if ($policy ne 'allow' && $policy ne 'deny' && $policy ne 'filter') {
		throw EBox::Exceptions::Internal(
                        __x("Policy '{policy}' is invalid", policy => $policy));
	}
	if ($policy eq $self->globalPolicy) {
		return undef;
	}
	$self->set_string("policy", $policy);
	return 1;
}

#arguments
#	- string: forbidden domain
#returns
#	- true if everything goes ok
#throws 
#	- DataExists
#		- If domain already exists
sub addBannedDomain # (domain)
{
	my $self = shift;
	my $domain = shift;

	unless ($self->_checkDomainName($domain)) {
  		throw EBox::Exceptions::InvalidData(
				'data' => __('domain name'),
	  			'value' => $domain); 
	}
	if ($self->bannedDomainExists($domain)) {
                 throw EBox::Exceptions::DataExists(
		 		'data' => __('domain name'),
                                'value' => "$domain");
	}
	my @list = @{$self->bannedDomains()};
	push @list, $domain;
	$self->set_list("banned_sites", "string", \@list);	
	return 1;
}

#arguments
#	- string: forbidden domain
#returns
#	- true if everything goes ok
#	- false if not
sub removeBannedDomain # (domain)
{
	my ($self, $domain) = @_;

	unless ($self->bannedDomainExists($domain)) {
		 throw EBox::Exceptions::DataNotFound(
		 		'data' => __("domain"), 
				'value' => $domain); 
	}
	
	my @list = @{$self->bannedDomains()};
	@list = grep (!/^$domain$/, @list);
	$self->set_list("banned_sites", "string", \@list);	
	return 1;
}

# Method: setBanThreshold
# Sets the weighted phrase value that will cause a page to be banned by the
# content-based filter.
#
# Parameters:
# 	threshold - A positive integer with the desired threshold. A value of 0
# 		    will disable the content filter. Acording to dansguardian
# 		    documentation, recommended values are:
#	 		* 50 for young children
#	 		* 100 for old children
#	 		* 160 for young adults
sub setBanThreshold # (threshold)
{
	my ($self, $thres) = @_;
	unless ($thres =~ /^\d+$/) {
		throw EBox::Exceptions::InvalidData(data=>__('Threshold'),
						value=>$thres);
	}
	my $old_thres = $self->banThreshold;
	($thres ne $old_thres) or return;
	$self->set_int('threshold', $thres);
}

# Method: banThreshold
# Gets the weighted phrase value that will cause a page to be banned.
#
# Returns:
# A positive integer with the current ban threshold.
sub banThreshold
{
	my $self = shift;
	return $self->get_int('threshold');
}

sub _dgNeeded
{
	my $self = shift;
	$self->service or return undef;
	$self->ipBlocked and return 1;
	($self->banThreshold > 0) and return 1;
	(scalar(@{$self->bannedDomains}) > 0) and return 1;
	return undef;
}

sub usesPort # (protocol, port, iface)
{
	my ($self, $protocol, $port, $iface) = @_;
	($protocol eq 'tcp') or return undef;
	# SQUIDPORT and DGPORT are hard-coded, they are reported as used even if
	# the service is disabled.
	($port eq SQUIDPORT) and return 1;
	($port eq DGPORT) and return 1;
	# the port selected by the user is only reported if the service is not
	# enabled
	($self->service) or return undef;
	($port eq $self->port) and return 1;
	return undef;
}

sub _setSquidConf
{
	my $self = shift;
	if ($self->_dgNeeded) {
		$self->_squidAndDG;
	} else {
		$self->_squidOnly;
	}
}

sub _squidOnly
{
	my $self = shift;
	my $ob = EBox::Global->modInstance('objects');
	my $objects;
	my $policy = $self->globalPolicy;
	my $squidpolicy = $policy;
	my $trans = 'no';
	my @exceptions = ();
	($self->transproxy) and $trans = 'yes';

	if ($policy eq 'deny') {
		push(@exceptions, @{$self->filtered});
		push(@exceptions, @{$self->unfiltered});
	} else {
		$squidpolicy = "allow";
		push(@exceptions, @{$self->bans});
	}
	
	foreach my $aux (@exceptions) {
		foreach my $addr (@{$ob->ObjectAddresses($aux)}) {
			$objects .= "acl objects src  $addr\n";
		}
	}

	my @array = ();
	push(@array, 'port'  => $self->port);
	push(@array, 'transparent'  => $trans);
	push(@array, 'policy'  => $squidpolicy);
	push(@array, 'objects' => $objects);

	$self->writeConfFile(SQUIDCONFFILE, "squid/squid.conf.mas", \@array);
}

sub dansguardianPort
{
	return DGPORT;
}

sub _squidAndDG
{
	my $self = shift;
	my $ob = EBox::Global->modInstance('objects');
	my $objects;
	my $banned = $self->bannedDomains;
	my $policy = $self->globalPolicy;
	my $squidpolicy = $policy;
	my $trans = 'no';
	my $block_ip = 'no';
	my @exceptions = ();
	my $threshold = $self->banThreshold;
	($self->transproxy) and $trans = 'yes';
	($self->ipBlocked) and $block_ip = 'yes';

	if ($policy eq 'allow') {
		push(@exceptions, @{$self->bans});
		push(@exceptions, @{$self->filtered});
	} else {
		$squidpolicy = "deny";
		push(@exceptions, @{$self->unfiltered});
	}
	
	foreach my $aux (@exceptions) {
		foreach my $addr (@{$ob->ObjectAddresses($aux)}) {
			$objects .= "acl objects src  $addr\n";
		}
	}

	my @array = ();
	push(@array, 'port'  => $self->port);
	push(@array, 'transparent'  => $trans);
	push(@array, 'policy'  => $squidpolicy);
	push(@array, 'objects' => $objects);

	$self->writeConfFile(SQUIDCONFFILE, "squid/squid.conf.mas", \@array);

	my $locale = EBox::Global::locale();
	my $lang = 'ukenglish';
	if ($locale =~ /^es_/) {
		$lang = 'arspanish';
	} elsif ($locale =~ /^fr_/) {
		$lang = 'french';
	}

	@array = ();
	# FIXME - get a proper lang name for the current locale
	push(@array, 'port'  => DGPORT);
	push(@array, 'lang'  => $lang);
	push(@array, 'squidport'  => SQUIDPORT);
	$self->writeConfFile(DGDIR . "/dansguardian.conf", 
				"squid/dansguardian.conf.mas", \@array);

	@array = ();
	push(@array, 'threshold'  => $threshold);
	$self->writeConfFile(DGDIR . "/dansguardianf1.conf", 
				"squid/dansguardianf1.conf.mas", \@array);

	@array = ();
	push(@array, 'block_ip'  => $block_ip);
	push(@array, 'domains'  => $banned);
	$self->writeConfFile(DGDIR . "/bannedsitelist", 
				"squid/bannedsitelist.mas", \@array);
}

sub firewallHelper 
{
	my $self = shift;
	if ($self->service) {
		if ($self->_dgNeeded()) {
			return new EBox::SquidFirewall();
		} else  {
			return new EBox::SquidOnlyFirewall();
		}
	}
	return undef;
}

#manage squid via init.d/squid script
#Pars 0: start|stop|restart
sub _daemon # (action)
{
	my ($self, $action) = @_;
	my $command =  SQUIDINIT . " " . $action . " 2>&1";

	if ( $action eq 'start') {
		root($command);
	} elsif ( $action eq 'stop') {
		root($command);
	} elsif ( $action eq 'reload') {
		root($command);
	} else {
		throw EBox::Exceptions::Internal("Bad argument: $action");
	}
	
}

sub statusSummary
{
	my $self = shift;
	return new EBox::Summary::Status('squid', __('HTTP Proxy'),
					$self->isRunning, $self->service);
}

sub summary
{
	my $self = shift;
	$self->isRunning() or return undef;

	my $item = new EBox::Summary::Module(__("Proxy"));
	my $section = new EBox::Summary::Section();
	my $status;
	$item->add($section);
	
	if ($self->transproxy) {
		$status = __("Enabled");
	} else {
		$status = __("Disabled");
	}
	$section->add(new EBox::Summary::Value(__("Transparent proxy"),$status));
	
	if ($self->globalPolicy eq "allow") {
		$status = __("Allow");
	} else {
		$status = __("Deny");
	}
	$section->add(new EBox::Summary::Value(__("Global policy"), $status));
	
	$section->add(new EBox::Summary::Value(__("Listening port"), 
					       $self->port));
	return $item;
}

sub rootCommands 
{
	my $self = shift;
	my @array = ();
	push(@array, SQUIDINIT);
	push(@array, DGINIT);
	push(@array,"/bin/mv ".EBox::Config::tmp ."* ".SQUIDCONFFILE);
	push(@array,"/bin/chmod * " . SQUIDCONFFILE);
	push(@array,"/bin/chown * " . SQUIDCONFFILE);
	push(@array,"/bin/mv ".EBox::Config::tmp ."* ". DGDIR . 
		"/dansguardian.conf");
	push(@array,"/bin/chmod * " . DGDIR . "/dansguardian.conf");
	push(@array,"/bin/chown * " . DGDIR . "/dansguardian.conf");
	push(@array,"/bin/mv ".EBox::Config::tmp ."* ". DGDIR . 
		"/dansguardianf1.conf");
	push(@array,"/bin/chmod * " . DGDIR . "/dansguardianf1.conf");
	push(@array,"/bin/chown * " . DGDIR . "/dansguardianf1.conf");
	push(@array,"/bin/mv ".EBox::Config::tmp ."* ". DGDIR . 
		"/bannedsitelist");
	push(@array,"/bin/chmod * " . DGDIR . "/bannedsitelist");
	push(@array,"/bin/chown * " . DGDIR . "/bannedsitelist");
	return @array;
}

1;
