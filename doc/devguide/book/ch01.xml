<chapter id="ch-intro">

	<title>Introduction</title>

	<section id='sect-audience'>
		<title>Intended audience</title>

		<para>This guide is written for developers interested in writing new
		modules with new features for <application>eBox</application>,
		and for those who need to change or extend the base eBox
		framework.</para>

		<para><application>eBox</application> is written in perl and is mostly
		object-oriented. It is assumed that readers know how to write object
		oriented programs in perl. Some features of the language or the
		libraries used in eBox may be discussed, but no attempt has been made
		to document those aspects throughly.</para>

		<para>Some experience writing object oriented applications and
		using design patterns in any language should be useful, but you
		should be fine just with the basic concepts of object oriented
		programming.</para>

		<para>An effort has been made to provide examples for all aspects of
		eBox development explained in this guide. Most of them come straight
		from existing and working modules. Furthermore, a complete module is
		developed step by step in <xref linkend='ch-examplemod'/>. It's a real
		module so that chapter should cover all the parts of a complete and
		working module.</para>
	</section>

	<section id="sect-whatis">

		<title>What is eBox?</title>

		<para>eBox is a platform for the development and deployment of security
		and work-group related services on a local network. It is configured
		through a web interface that integrates all services in a consistent
		and easy to use way. Its goal is to be usable by non-experts.</para>

		<para>eBox is meant to be installed on a dedicated machine, all
		configuration tasks are performed through the eBox web interface. This
		means that the configuration of the underlying services is one-way:
		eBox modules generate configuration files, overwriting system files in
		some cases (although that tends to be avoided if possible) and manual
		changes to those files are not detected by eBox. This simplifies the
		implementation and usage of the package but has the disadvantage that
		developers need to be careful if they use their own system for testing
		purposes.</para>

		<para>eBox design is modular, new modules providing new services and
		features can be developed independently from its core package. eBox
		simplifies the deployment of new modules and the updates of existing
		ones with a software management module, which is also independent from
		the eBox base package.</para>

		<para>The system is based on Linux and has been developed on top of
		Debian, no support is provided for other Linux distributions as there
		are some "debianisms" in some of the modules. Porting to other Linux
		distributions should be quite easy, and porting to other Unix like
		operating systems such as OpenBSD would take a little more work but it
		should still be doable, and worth it.</para>

		<para>eBox is based on a few software packages, which are used for
		several purposes:</para>

		<variablelist>

			<varlistentry>
				<term>Linux 2.6</term>
				<listitem>

					<para>eBox relies on some features provided by the kernel, some
					are available only on the 2.6 series. Among these features
					are netfilter (for the firewall), 802.1q (for VLANs) and
					ipsec.</para>

				</listitem>
			</varlistentry>

			<varlistentry>
				<term>perl and mod_perl</term>
				<listitem>

					<para>All eBox modules are implemented in perl, the web interface
					runs under mod_perl for performance reasons.</para>

				</listitem>
			</varlistentry>

			<varlistentry>
				<term>mason</term>
				<listitem>

					<para>mason is a templating system for perl, it is used to
					generate HTML for the web based user interface and to generate
					configuration files.</para>

				</listitem>
			</varlistentry>

			<varlistentry>
				<term>apache</term>
				<listitem>

					<para>The web interface is served by apache, we usually use the
					apache-perl Debian package.</para>

				</listitem>
			</varlistentry>

			<varlistentry>
				<term>gconf</term>
				<listitem>

					<para>eBox stores its configuration using gconf2 and its perl
					library bindings.</para>

				</listitem>
			</varlistentry>

			<varlistentry>
				<term>sudo</term>
				<listitem>

					<para>Apache runs as an unprivileged user, all eBox modules use
					sudo to execute commands that need to be run as root.</para>

				</listitem>
			</varlistentry>

		</variablelist>

		<para>The base eBox package provides a development framework for
		new modules. By using this framework modules automatically get
		features like configuration backups and reversion of changes in the
		configuration before they are saved. The features available to module
		developers will be explained in detail in later chapters.</para>

		<!-- FIXME - screenshots -->

  </section>

	<section>
		<title>Terminology</title>

		<para>A few conventions are used throughout this guide regarding
		several concepts:</para>

		<formalpara>
			<title>Booleans</title>
			<para>Whenever we need to talk about a boolean value passed
			to a method or returned by it, we will refer to a true
			value as <literal>true</literal> and to a false value as
			<literal>undef</literal> or <literal>false</literal>.</para>
		</formalpara>

		<formalpara>
			<title>Perl modules and eBox modules</title>
			<para>There may be some confusion in some parts of the guide about
			the term <emphasis>module</emphasis> as the term may refer to an
			<emphasis>eBox</emphasis> module or a <emphasis>perl</emphasis>
			module. An eBox module is the complete set of classes (and perl
			modules) and other files that provide a self-contained functionality
			for eBox and that may be installed or uninstalled independently from
			the rest of eBox. A perl module is basically a perl source file.</para>
		</formalpara>

		<para>Whenever there is no possibility of confusion, we'll just
		write <emphasis>module</emphasis>, otherwise we'll write explicitly
		<emphasis>perl module</emphasis> since this meaning will be the one
		used less frequently.</para>
	</section>

	<section id="sect-amodule">
		<title>How a module works</title>

		<para>The typical eBox module handles the configuration of a daemon,
		possibly integrated with other eBox modules. The developer decides
		in what ways should the user be able to configure the daemon, this
		ways do not necessarily map directly to the daemon configuration options on a
		one-to-one relationship. The developer may pick a sane default value
		for most of the options and hide them from the user, showing him just
		the ones that he feels are important. Even further, an option changed
		by the user through the web interface may cause configuration changes
		in several real configuration options or even on several eBox modules. The
		main goal is to have an user interface as simple, easy to use, and
		integrated as possible, while providing the user with a rich set of
		features.</para>

		<para>However, there may be modules that do not handle the
		configuration of a network service. An example is the 'sysinfo' module
		in the base system, it just gathers system information to be shown in
		the Summary page and provides a few menu entries for features that
		do not belong to any module in particular. The module parent class
		defines several abstract methods that real modules are free to leave
		unimplemented. Thus, a module may just provide info in the Summary, add
		new menu items, handle a network service or all of the above.</para>

		<para>The normal, and most interesting, case is the module described
		in the first paragraph. Such a module has three parts.</para>

		<itemizedlist>
			<listitem>
				<para>It defines and implements an API that will let the GUI,
				other modules or plain perl scripts configure the daemon it is
				going to handle. </para>
			</listitem>

			<listitem>
				<para> The second is the GUI, which is a set of CGIs that show the
				current configuration to the user and let him change it, these
				CGIs use the API defined earlier to fetch the configuration info and make
				changes to it. </para>
			</listitem>

			<listitem>
				<para>The third part of the module is usually quite small, it
				translates all the configuration information stored in GConf into
				firewall rules, configuration files and commands that make the network
				service behave as the user expects. It also takes care of starting,
				stopping and restarting the service when needed.</para>
			</listitem>
		</itemizedlist>

		<para> This separation between the GUI and the backend opens the
		possibility for other means of changing the configuration. One such means
		is through perl scripts, these is useful when making packages for a
		distribution, the package maintainer can write a simple script to import the
		current system configuration into eBox, or set up some default values. Another
		use of the API is for other modules, the firewall module is the most
		used case, almost all modules need tell the firewall to open some port
		for them. In the future a wrapper may be written around these APIs to
		publish them through web-services, this would make eBox configurable
		programmatically over the network.</para>

		<para>Besides these three parts, the module has some other minor
		parts, like its piece of the summary page in the web
		interface, menu entries, dependency declarations, backups of
		configuration pieces not stored in GConf, etc.</para>

		<para>That's all there is to it, creating a module is as simple as
		following these steps:</para>

		<itemizedlist>
			<listitem>
				<para>Decide what daemon your module is going to handle and learn
				how it works and how to set it up.</para>
			</listitem>

			<listitem>
				<para>Plan what options you are going to expose to the user through
				the web interface, and how they may interact with other eBox
				modules</para>
			</listitem>

			<listitem>
				<para>Define and implement the API that will let the GUI manipulate
				the necessary configuration options. The main class in your module
				should inherit from <classname>EBox::GConfModule</classname>, this
				class wraps the GConf API and transparently implements some useful
				features that all eBox modules need to have.</para>
			</listitem>

			<listitem>
				<para>Create the CGIs and HTML templates that will let the
				user interact with the module. CGIs should inherit from the
				<classname>EBox::CGI::Base</classname> class which, again, provides
				some features transparently to all its children.</para>
			</listitem>

			<listitem>
				<para>Write the code needed to make the daemon work, possibly
				generating a configuration file and setting up a firewall rule using the
				<classname>EBox::Firewall</classname> class. Configuration files are
				generated almost trivially with mason, which is the template system
				also used to generate the HTML pages for the GUI.</para>
			</listitem>

		</itemizedlist>

		<para>The size and complexity of a module depends directly on the
		complexity of the service involved and the amount of configuration
		items exposed to the user. The necessary work to make a small eBox
		module is minimal, take the DNSCache module as an example, its CGIs add
		up to 49 lines of code and the module itself is 134 lines long.</para>

		<para>The directory structure of an eBox module may look quite complex
		for a newcomer. A usual eBox module directory should look like this:

		<programlisting>
AUTHORS     configure.ac  INSTALL     Makefile.am  README   stubs/
autogen.sh  COPYING       NEWS        schemas/     tools/   ChangeLog
debian/     m4/           po/         src/         www/
		</programlisting>
		</para>

		<para>The more important directories are <filename>src/</filename>,
		<filename>schemas/</filename>, <filename>www/</filename> and
		<filename>stubs/</filename>.</para>

		<para>The <filename>src/</filename> directory contains the source
		code for the module. Inside this directory two directories can be
		found: <filename>EBox</filename> and <filename>templates</filename>.
		The <filename>EBox</filename> directory contains the Perl source code
		files, including a <filename>CGI</filename> subdirectory with the web
		frontend for the module. The <filename>templates</filename> directory
		is used to store the Mason templates, which will be used to generate
		the HTML output.</para>

		<para>The <filename>schemas/</filename> directory contains gconf
		schemas, used to define the configuration schemas for modules, and
		optionally provide default values for some options.</para>

		<para>The <filename>www/</filename> directory contains images and
		stylesheets that will be used in the web frontend.</para>

		<para>The <filename>stubs/</filename> is used to store Mason templates
		to generate configuration files for the module services.</para>

  </section>

  <section id="sect-a-mvc-module">
    <title>A Model-View-Controller module</title>

    <para>
      Bear <link linkend="sect-amodule">above section</link> in mind, a new way to develop
      eBox modules have been developed. It relies on 
      <ulink url="http://en.wikipedia.org/wiki/Model-view-controller">Model-View-Controller</ulink>
      design pattern, which an architectural pattern used in large software projects to
      decouple highly data (<emphasis>model</emphasis>) and user interface
      (<emphasis>view</emphasis>) so that developer can change the data architecture
      without changing the user interface and vice versa. A new component is added,
      the <emphasis>controller</emphasis>, which manages data access and business 
      logic acting as an intermediate between them.
    </para>

    <para>
      Thus with our new architecture the eBox MVC conception will be the following:
    </para>

    <variablelist>
      <varlistentry>
        <term>Model</term>
        <listitem>
          <para>
            Our model is defined as a perl module which is a subclass of 
            <classname>EBox::Model::DataTable</classname> or one of the subclasses.
          </para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>View</term>
        <listitem>
          <para>
            The already defined Mason templates are used to show the information to 
            the user.
          </para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>Controller</term>
        <listitem>
          <para>
            The CGIs which are mapped from the Mason templates to do actions. There
            are some default actions already implemented.
          </para>
        </listitem>
      </varlistentry>
    </variablelist>

    <para>
      At section <link linkend="ch-mvc-internals">behind the scenes</link>, there is a large
      explanation about how it works internally. Below we are only going to introduce the main
      components which an eBox developer requires to know to build up an eBox MVC's module.
    </para>
    
    <para>
      A basic MVC based module should have, at least, these three main parts:
    </para>
    
    <itemizedlist>
      <listitem>
        <para>
          A series of data models which represent the information you want to store to configure
          your desired service.
        </para>
      </listitem>
      <listitem>
        <para>
          Manage your service daemon (if any) accessing to the data model, add menu entry,
          summary and make the data contained in the model(s) available to the eBox system.
        </para>
      </listitem>
      <listitem>
        <para>
          Expose the desired API to other eBox modules, perl scripts and SOAP interface.
        </para>
      </listitem>
    </itemizedlist>

    <section>
      <title>Model creation</title>

      <para>
        A model is just a table concept, that is, an array of rows which have a defined fixed
        definition, the table description. This table description contains a series of <classname>
        EBox::Types</classname> which are instances of <classname>EBox::Types::Abstract</classname>,
        these eBox types try to include the required representation for eBox configuration parameters,
        a brief list could be:
      </para>

      <variablelist>
        <varlistentry>
          <term>Basic types</term>
          <listitem>
            <para>
              Basic types include are: <classname>Boolean</classname>, <classname>Int</classname>,
              <classname>Text</classname>, <classname>Password</classname>,
              <classname>Select</classname> (an enumeration) or <classname>Link</classname>, which
              describe a type that stores a simple link reference.
            </para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>Network related types</term>
          <listitem>
            <para>
              These comprise <classname>IPAddr</classname> which represents an IP address,
               <classname>MACAddr</classname> which is a Ethernet address, <classname>Service</classname>
              which matches with port and protocol such as <filename>/etc/services</filename> does
              and <classname>PortRange</classname> which describes a single port number,
              a port range or any port.
            </para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>Composite types</term>
          <listitem>
            <para>
              Currently, just a <classname>Union</classname> type has been developed which
              represents a type is used from a defined list of options. If none of options are suitable,
              a <classname>Union::Text</classname> may be used with this purpose.
            </para>
          </listitem>
        </varlistentry>
      </variablelist>

      <para>
        The data storage is managed automatically by the model itself. A model stores its information 
        under a GConf directory which must set explicitly at the model creation. However, you can set
        dynamically which becomes the model instance in a submodel. The submodels are model instances
        whose GConf directory is set dynamically, not only at the runtime. Its usage is intimately with
        <classname>EBox::Types::HasMany</classname>, which describes a relationship between a field from
        a model with another model indicating that field contains the whole data from another model.
      </para>

      <para>
        Apart from the table description, it is required to set several attributes such as the name,
        the printable name, if it is ordered, etc... Some model definition examples may help to understand
        the subject:
      </para>

      <example id="object-model-definition">
        <title><classname>Object</classname> model definition</title>
        <programlisting><![CDATA[
sub _table
{
    my @tableHead = 
        ( 

            new EBox::Types::Text
                            (
                                'fieldName' => 'name',
                                'printableName' => __('Name'),
                                'size' => '12',
                                'unique' => 1,
                                'editable' => 1
                             ),
            new EBox::Types::HasMany
                            (
                                'fieldName' => 'members',
                                'printableName' => __('Members'),
                                'foreignModel' => 'MemberTable',
                                'view' => '/ebox/Object/View/MemberTable',
                                'backView' => '/ebox/Object/View/MemberTable',
                                'size' => '1',
                             )

          );

    my $dataTable = 
        { 
            'tableName' => 'ObjectTable',
            'printableTableName' => __('Objects'),
            'automaticRemove' => 1,
            'modelDomain' => 'Objects',
            'defaultActions' => ['add', 'del', 'editField' ],
            'tableDescription' => \@tableHead,
            'class' => 'dataTable',
            'help' => __('Objects'),
            'printableRowName' => __('object'),
        };

    return $dataTable;
}]]>
        </programlisting>

      </example>

      <para>
        As it is shown, a model is used to describe an eBox object, which has a name
        and a group of members which are described below:
      </para>

      <example id="member-model-definition">
        <title><classname>Object member</classname> model definition</title>
        <programlisting><![CDATA[
sub _table
{
    my @tableHead = 
        ( 

            new EBox::Types::Text
                            (
                                'fieldName' => 'name',
                                'printableName' => __('Name'),
                                'size' => '12',
                                'unique' => 1,
                                'editable' => 1
                             ),
            new EBox::Types::IPAddr
                            (
                                'fieldName' => 'ipaddr',
                                'printableName' => __('IP Address'),
                                'editable'      => 1,
                            ),
            new EBox::Types::MACAddr
                            (
                                'fieldName' => 'macaddr',
                                'printableName' => __('MAC Address'),
                                'editable'      => 1,
                                'optional' => 1
                            ),


          );

    my $dataTable = 
        { 
            'tableName' => 'MemberTable',
            'printableTableName' => __('Members'),
            'automaticRemove' => 1,
            'defaultActions' => ['add', 'del', 'editField' ],
            'modelDomain'    => 'Objects',
            'tableDescription' => \@tableHead,
            'class' => 'dataTable',
            'help' => __('Objects'),
            'printableRowName' => __('member'),
        };

    return $dataTable;
}]]>
        </programlisting>
        
      </example>

      <para>
        As you may see, every field has some attributes as well as the model itself. Just
        note the actions are the allowed actions to apply to that model. For instance, you
        can add, delete rows, edit fields... Several attributes are allowed for every type
        and model, if they are not explicitly set at the model definition, they are treated
        as false value if it is a boolean type or empty string if the type is an string.
      </para>

        <para>
          The best part of it comes with forms. Typical eBox scenarios contain a set of
          tables and forms. So the information that a form may show can be stored in a
          data model as described above. However, it has some significant differences.
          A form data model looks like a table data model with just one row which is
          always shown to be edited. A form model definition is similar to a table data
          model one:
        </para>

        <example id="jabber-model-definition">
          <title><classname>Jabber dispatcher</classname>configuration form data model
          definition</title>

          <programlisting><![CDATA[
sub _table
  {

      my @tableDesc =
        (
         new EBox::Types::Text(
                               fieldName     => 'server',
                               printableName => __('Jabber server name'),
                               size          => 12,
                               editable      => 1,
                              ),
         new EBox::Types::Int(
                              fieldName     => 'port',
                              printableName => __('Port'),
                              size          => 6,
                              editable      => 1,
                              defaultValue  => 5222,
                             ),
         new EBox::Types::Text(
                               fieldName     => 'user',
                               printableName => __('Jabber user name'),
                               size          => 12,
                               editable      => 1,
                              ),
         new EBox::Types::Password(
                                   fieldName     => 'password',
                                   printableName => __('User password'),
                                   size          => 12,
                                   editable      => 1,
                                   minLength     => 4,
                                   maxLength     => 25,
                                  ),
         new EBox::Types::Boolean(
                                  fieldName      => 'subscribe',
                                  printableName  => __('Subscribe'),
                                  editable       => 1,
                                 ),
         new EBox::Types::Text(
                               fieldName     => 'adminJID',
                               printableName => __('Administrator Jabber Identifier'),
                               size          => 12,
                               editable      => 1,
                              ),
        );

      my $dataForm = {
                      tableName          => 'JabberDispatcherForm',
                      printableTableName => __('Configure Jabber dispatcher'),
                      modelDomain        => 'Events',
                      tableDescription   => \@tableDesc,
                      class              => 'dataForm',
                      help               => __('In order to configure the Jabber event dispatcher ' .
                                               'is required to be registered at the chosen Jabber ' .
                                               'server or check subscribe to do register. The administrator ' .
                                               'identifier should follow the pattern: user@domain[/resource]'),
                     };

      return $dataForm;

  }]]>
          </programlisting>
          
        </example>
       
        <para>
          As you may notice, fields at a form can contain default values. This is done due to 
          have default eBox configuration working. For example, you may want to enable a service
          to a specific port whose value does not modify the service if the default value is
          set.
        </para>

        <section id="model-data-management-sect">
          <title>User input management</title>

          <para>
            Once the definition is set you may want to validate the user input. Types do some
            validation, for instance, <classname>IPAddr</classname> checks if the parameters
            contain a valid IP. However, there are cases where the developer requires to do
            extra validation. To achieve so, there are two methods to override <methodname>
            validateRow</methodname> and <methodname>validateTypedRow</methodname>.
          </para>

          <para>
            Furthermore, actions have callbacks to called after an action have been finished.
            Therefore <emphasis>add</emphasis> action has <methodname>addedRowNotify</methodname>,
            <emphasis>edit</emphasis> <methodname>updatedRowNotify</methodname> and so on. This
            allows you to manage the updated information to do something different from just
            storing updating information at GConf database.
          </para>

        </section>

    </section>

    <section id="model-view-sect">

      <title>Model view</title>

      <para>
        This section explains how the data model is shown at eBox user interface. If you just
        want to show a data model in eBox, a new menu entry is required. Its URL must have
        this pattern: <emphasis>${modelDomain}/View/${tableName}</emphasis>. The 
        <property>modelDomain</property> and <property>tableName</property> are attributes
        which have been already set at the data model definition. A table model will show up
        an empty table and a HTML form will appear if a form model is defined, they are named
        as their <emphasis>viewers</emphasis>.
      </para>

      <para>
        You may wish to combine the several models in the same page. Here where the model
        composites play its role. The model composites are containers which stores two
        kinds of components: models and composites, thus you can create complex composites
        to find the more usable and adapted user interface for your needs. The current
        available layouts are:
      </para>
      
      <variablelist>
        <varlistentry>
          <term>top-bottom</term>
          <listitem>
            <para>The components are shown in order from top to the bottom.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>tabbed</term>
          <listitem>
            <para>The component viewers are displayed in a tabbed way. That is,
            each component is shown when the tab name is clicked</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <para>
        Define a model composite is even simpler than a model one as it depicts in 
        this example:
      </para>

      <example id="composite-def-example">
        <title>A sample model composite definition</title>

        <programlisting><![CDATA[
sub _description
  {

      my $description =
        {
         components      => [
                             'EnableForm',
                             'ConfigurationComposite',
                            ],
         layout          => 'top-bottom',
         name            => 'GeneralComposite',
         printableName   => __('Events'),
         compositeDomain => 'Events',
         help            => __('Events module may help you to make eBox ' .
                               'inform you about events that happen at eBox ' .
                               'in some different ways'),
        };

      return $description;

  }]]>
        </programlisting>

      </example>
   
      <para>
        The components are referenced using its name, <property>tableName</property> at
        models and <property>name</property> at composites. In order to display a
        composite based page, it is required to change the menu entry. In this case, 
        the URL to call must follow this pattern
        <emphasis>${compositeDomain}/Composite/${name}</emphasis>. That's all you need
        to display your models together in a single page.
      </para>

    </section>

    <section id="model-access-sect">

      <title>Data model publishing and access</title>

      <para>
        Just get the magic done, it is required to publish the models and the composites.
        To achieve so, the eBox modules, which are subclasses of
        <classname>EBox::GConfModule</classname>, must inherit 
        <classname>EBox::Model::ModelProvider</classname> and 
        <classname>EBox::Model::CompositeProvider</classname> interfaces and implementing
        its respectively methods <methodname>models</methodname> and
        <methodname>composites</methodname>, which returns an array reference of model and
        composite instances that lives within this eBox module realm. An example could be
        the next one:
      </para>

      <para>
      </para>

    </section>

  </section>

</chapter>
