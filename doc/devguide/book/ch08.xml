<chapter id="ch-examplemod">

  <title>How to create a module</title>

  <section id="long-way-sect">

    <title>Long way to create a small module</title>

    <simplesect id="long-create-model-introduction">

      <para>Once you've seen the eBox internals, we are going to apply all
      the knowledge explained in the previous chapters creating a module
      from scratch. The first thing to do is choose a network service that
      you want to integrate into eBox. In our case we've chosen the Network
      Time Protocol server because it is one of the most simple service that exist in
      eBox. Our module will provide eBox these features:</para>

      <itemizedlist>
        <listitem>
          <para>Date and time synchronisation with an external server.</para>
        </listitem>

        <listitem>
          <para>Let clients synchronise their time and date with
          eBox.</para>
        </listitem>
      </itemizedlist>

      <para>And these are the steps we are going to follow in the development for
      the module:</para>

      <itemizedlist id="long-steps-creating-module-list">
        <listitem>
          <para>Study the NTP server and its features.</para>
        </listitem>

        <listitem>
          <para>Create a new module from the module template.</para>
        </listitem>

        <listitem>
          <para>Define and implement an API to manage its configuration.</para>
        </listitem>

        <listitem>
          <para>Develop CGIs and mason templates.</para>
        </listitem>

        <listitem>
          <para>Make our module show up in the eBox menu and in the summary
          page.</para>
        </listitem>

        <listitem>
          <para>Generate the configuration files and control the daemon
          execution.</para>
        </listitem>

        <listitem>
          <para>Establish custom rules in the firewall that let our module
          work.</para>
        </listitem>
      </itemizedlist>

    </simplesect>
    
    <section id='sect-example-define'>
      <title>Studying the NTP service and its features</title>

      <para>We've decided to develop this module using the ntp server from <ulink
      url='http://www.ntp.org'>www.ntp.org</ulink>. Debian includes packages for
      the server so we are going to use two of them:
      <emphasis>ntp-server</emphasis> to provide the time synchronisation service
      to clients and <emphasis>ntpdate</emphasis> to make synchronisation queries
      to external servers.</para>

      <para>After choosing the software we have to study how it works, its
      configuration files and the configurable parameters within them. With all
      this information we will be able to choose what degree of control the user
      of our module will have. We'll try to strike a balance between flexibility
      in the configuration and ease of use.</para>

      <para>For the module we are developing we only need to tune some of the
      parameters contained in the <filename>/etc/ntp.conf</filename> file,
      which holds the configuration for the ntp daemon. Of all the possible
      configuration options contained in that file, we are only interested in
      two:</para>

      <itemizedlist>
        <listitem>
          <para>The list of ntp servers we are going to use to synchronise our
          date and time. This can be achieved by adding lines like the following
          as many times as necessary to the configuration file:</para>

          <programlisting> <![CDATA[ server ntp_server_ip ]]>
          </programlisting>
        </listitem>

        <listitem>
          <para>The ability to act as an NTP server for clients in our network.
          This is done using the <varname>server</varname> attribute, as seen
          above, with an special SIP address:</para>

          <programlisting> <![CDATA[ server 127.127.1.0 ]]> </programlisting>
        </listitem>
      </itemizedlist>

      <para>The NTP server has more configuration options, but we have
      decided to leave them with sane default values that are transparent to
      the user. We will concentrate on those features that will be generally
      most interesting to our users.</para>

      <para>We will also add the possibility for the user to manually change
      the system time and date and the time zone, in case there is no
      possibility to synchronise the time with external NTP servers.</para>

      <para>Time and date modification is easily done using the
      <command>/bin/date</command> command.</para>

      <para>Time zone configuration is easy too.
      <filename>/etc/localtime</filename> is a symbolic link that points
      to a file named after the location we are in. All possible timezones
      are stored under the <filename>/usr/share/zoneinfo/</filename>
      directory. Each location is stored inside its continent,
      so if our time zone is <emphasis>Madrid/Europe</emphasis>,
      then <filename>/etc/localtime</filename>must point to
      <filename>/usr/share/zoneinfo/Europe/Madrid</filename>. The
      operation of modifying the time zone is as simple as changing the
      <filename>/etc/localtime</filename> symbolic link.</para>

    </section>

    <section id='sect-example-module-bootstrap'>
      <title>Create a new module from the module template.</title>

      <para>As we have seen above, eBox modules have a complex directory
      structure that can be tedious to set up. Because of that, a module
      template is provided inside the tools directory in the base ebox
      module. This template provides a basic skeleton for an eBox module and
      can be cloned to create a new one. Note that you should replace the
      string <parameter>modulename</parameter> with your module name. </para>

      <para>eBox uses <command>autoconf</command> and
      <command>automake</command> for module configuration and
      installation. The files <filename>autogen.sh</filename>,
      <filename>configure.ac</filename> and <filename>Makefile.am</filename>
      contain the basic autotools configuration for a standard module and are
      also included in the template. The template also provides a
      <filename>m4/ebox.m4</filename> file, used by modules to detect the
      current eBox installation paths. </para>

      <para>The <ulink
      url="http://www.gnu.org/software/autoconf/manual/">Autoconf</ulink>
      and <ulink
      url="http://www.gnu.org/software/automake/manual/">Automake</ulink>
      manuals are the best autotools reference.</para>

    </section>

    <section id='sect-example-api'>
      <title>Defining and implementing the API</title>

      <para>At this point we should have gained a good degree of familiarity
      with the network service we are going to work with. We should also
      know what features will be exposed to our future users. In addition
      we have a template to use as a base for our module. The next step
      is to define the API for our module's backend. We must define which
      methods will be needed to let the rest of the modules read and write
      all the configuration options and to manage the daemon: start, stop,
      etc...</para>

      <para>The backend of our module is going to be in the
      <classname>EBox::NTP</classname> class. It will inherit from
      <classname>EBox::GConfModule</classname> and it will contain all the
      methods that conform the NTP API. This is its constructor:</para>

      <example id="constructor-example">
        <title><classname>EBox::NTP</classname> constructor</title>
        <programlisting><![CDATA[sub _create 
{
    my $class = shift;
    my $self = $class->SUPER::_create(name => 'ntp', 
                                      domain => 'ebox-ntp',
                                      @_);
    bless($self, $class);
    return $self;
}]]>
        </programlisting>
      </example>

      <para>After the analysis performed in the previous
      section we can define the following methods in
      <classname>EBox::NTP</classname>(remember that we use a leading
      underscore for private method names):</para>

      <itemizedlist>
        <listitem>
          <para>setService</para>
        </listitem>
        <listitem>
          <para>service</para>
        </listitem>
        <listitem>
          <para>setSynchronized</para>
        </listitem>
        <listitem>
          <para>synchronized</para>
        </listitem>
        <listitem>
          <para>setServers</para>
        </listitem>
        <listitem>
          <para>servers</para>
        </listitem>
        <listitem>
          <para>setNewData</para>
        </listitem>
        <listitem>
          <para>setNewTimeZone</para>
        </listitem>
        <listitem>
          <para>_restartAllServices</para>
        </listitem>
      </itemizedlist>

      <variablelist>
        
        <varlistentry>
          <term><methodname>setService</methodname></term>
          <listitem>

            <para>This method gets a boolean argument that enables or disables the
            NTP service, which will allows clients in the local network
            synchronise their time and date with eBox.</para>

            <para>Here is its implementation:</para>
            
            <example id="enable-NTP-example">
              <title>Enabling the NTP server</title>
              <programlisting><![CDATA[sub setService 
{
    my ($self, $active) = @_;
    if ($active xor $self->service) {
        $self->set_bool('active', $active);
    }
} ]]>
              </programlisting>
            </example>

            <para>First we read the <parameter>active</parameter> argument
            and then we use the <methodname>service</methodname> method
            to find out if the server is currently enabled. Only if the
            new value is different than the old one we go on to set
            the <parameter>active</parameter> gconf key, by calling
            <methodname>set_bool</methodname>.</para>

          </listitem>
        </varlistentry>

        <varlistentry>
          <term><methodname>service</methodname></term>
          <listitem>

            <para>This method returns whether the NTP server is currently
            enabled or not. Its implementation is trivial, all we need is
            to fetch the <parameter>active</parameter> gconf key and return
            it:</para>

            <example id="state-example">
              <title>Reading the state of the NTP server</title>
              <programlisting><![CDATA[sub service 
{
    my $self = shift;
    return $self->get_bool('active');
} ]]> 
              </programlisting>
            </example>

          </listitem>
        </varlistentry>

        <varlistentry>
          <term><methodname>setSynchronized</methodname></term>
          <listitem>

            <para>This method receives a boolean parameter that decides
            whether eBox will synchronise its date and time with external
            NTP servers. As you can see, its implementation is similar
            to <methodname>setService</methodname>, we just use the
            <parameter>synchronized</parameter> gconf key instead:</para>

            <example id="enable-NTP-sync-example">
              <title>Enabling the external NTP synchronisation</title>
              <programlisting><![CDATA[sub setSynchronized # (synchronized)
{
    my ($self, $synchronized) = @_;

    if ($synchronized xor $self->synchronized) {
        $self->set_bool('synchronized', $synchronized);
    }
} ]]> </programlisting>
            </example>

          </listitem>
        </varlistentry>

        <varlistentry>
          <term><methodname>synchronized</methodname></term>
          <listitem>

            <para>This method returns the value of the
            <parameter>synchronized</parameter> gconf key.
            Its implementation is quite simple and similar to
            <methodname>service</methodname>.</para>

            <example id="external-sync-example">
              <title>Fetching the configuration for external
              synchronization</title>

              <programlisting><![CDATA[sub synchronized 
{ 
    my $self = shift;
    return $self->getbool('synchronized');
} ]]>
              </programlisting>
            </example>

          </listitem>
        </varlistentry>

        <varlistentry>
          <term><methodname>setServers</methodname></term>
          <listitem>

            <para>This allows us to store the names of the ntp servers we
            will use to synchronise our time and date in the gconf database.
            Its implementation checks whether an SIP address or a domain name
            were introduced and checks the syntax of the value accordingly.
            If the syntax is correct the servers will be stored in the
            gconf database calling the <methodname>set_string</methodname>
            method. In addition to that, we won't let the user set a
            secondary server if no primary server has been set, and the
            same for the third server. Let's see part <footnote><para>The
            complete implementation can be found in the subversion
            repository</para></footnote>of its implementation:</para>

            <example id="setting-external-NTP-example">
              <title>Setting the external NTP servers</title>
              <programlisting><![CDATA[sub setServers # (server1, server2, server3) 
{
    my ($self, $s1, $s2, $s3) = @_;

    if ($s1 =~ /^(\d{1,3}\.){3}\d{1,3}$/) {
        checkIP($s1, __("primary server IP address"));
        $self->set_string('server1', $s1);
    } else {
        checkDomainName($s1, __("primary server name "));
        $self->set_string('server1', $s1);
    }

    if (defined($s2) and ($s2 ne "")) {
        if ($s2 =~ /^(\d{1,3}\.){3}\d{1,3}$/) {
            checkIP($s2, __("secondary server IP address"));
            $self->set_string('server2', $s2);
        } else {

        ...]]> 
              </programlisting>
            </example>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><methodname>servers</methodname></term>
          <listitem>

            <para>It returns an array that contains the NTP external
            servers stored in gconf:</para>

            <example id="getting-external-NTP-example">
              <title>Getting the list of external NTP servers</title>
              <programlisting><![CDATA[sub servers 
{
    my $self = shift;
    my @servers;
    @servers = ($self->get_string('server1'),
    $self->get_string('server2'),
    $self->get_string('server3'));

    return @servers;
} ]]> 
              </programlisting>
            </example>
          </listitem>
        </varlistentry>
        
        <varlistentry>
          <term><methodname>setNewDate</methodname></term>
          <listitem>

            <para>This method changes the system's date and time. This is its
            implementation:</para>
            
            <example id="setting-time-date-example">
              <title>Setting a new system time and date</title>
              <programlisting><![CDATA[sub setNewDate # (day, month, year, hour, minute, second)
{
    my ($self, $day, $month, $year, $hour, $min, $sec) = @_;

    my $newdate = "$year-$month-$day $hour:$min:$sec";
    my $command = "/bin/date --set \"$newdate\"";
    root($command);

    $self->_restartAllServices;
    
} ]]> 
              </programlisting>
            </example>

            <para>We receive as arguments every piece of data necessary to set the
            time and date in the system: day, month, year, hour, minutes and
            seconds.</para>

            <para>We build the complete command in the
            <varname>command</varname> variable and a call is made to the
            <function>root</function> function that executes it. This
            command must be run as root using <command>sudo</command>, that's
            why we don't run it directly.</para>

            <para>When the system time changes, some system services and eBox
            modules need to be restarted. This is implemented in the
            <methodname>_restartAllServices</methodname> method seen in <xref
            linkend='ex-ntp-restart-all'/>.</para>
          </listitem> 
        </varlistentry>

        <varlistentry>
          <term><methodname>setNewTimeZone</methodname></term>
          <listitem>
            
            <para>Along with the time and date, the time zone may be changed too.
            For this purpose we implemented this method:</para>

            <example id="setting-timezone-example">
              <title>Setting a new time zone</title>
              <programlisting><![CDATA[sub setNewTimeZone # (continent, country)
{
     my ($self, $continent, $country) = @_;

     my $command = "ln -s /usr/share/zoneinfo/$continent/$country" .
                   " /etc/localtime";
     $self->set_string('continent', $continent);
     $self->set_string('country', $country);
     root("rm /etc/localtime");
     root($command);
     $self->_restartAllServices;
} ]]>
              </programlisting>
            </example>

            <para>It gets two arguments: <parameter>continent</parameter>
            and <parameter>country</parameter>. We use them to redo
            the symbolic link in <filename>/etc/localtime</filename>
            so that it points to the new time zone. For example,
            if the two arguments are <literal>Africa</literal> and
            <literal>Africa</literal>, <filename>/etc/localtime</filename>
            will be changed so that it points to
            <filename>/usr/share/zoneinfo/Africa/Dakar</filename>.</para>

            <para>We store both arguments in gconf too, making to calls to
            <methodname>set_string</methodname>. When the time zone has
            been changed some eBox modules and the system log services are
            restarted so that they don't run with the wrong time.</para>

          </listitem>
        </varlistentry>

        <varlistentry>
          <term><methodname>_restartAllServices</methodname></term>
          <listitem>

            <para>Operations that change the system's time and date may leave some
            parts of the system in an inconsistent state. To avoid having eBox
            modules and system log services with a time shift we'll write a
            method that will restart all those services so that they get the new
            time and date. Here it goes:</para>

            <example id='ex-ntp-restart-all'>
              <title>Restarting eBox modules and system services</title>
              <programlisting> <![CDATA[sub _restartAllServices
{
    my $self = shift;
    my $global = EBox::Global->getInstance();
    my @names = grep(!/^network$/, @{$global->modNames});
    @names = grep(!/^firewall$/, @names);
    my $log = $global->logger;
    my $failed = "";
    $log->info("Restarting all modules");
              
    foreach my $name (@names) {
        my $mod = $global->modInstance($name);
        try {
            $mod->restartService();
        } catch EBox::Exceptions::Internal with {
            $failed .= "$name ";
        };
    }
              
    if ($failed ne "") {
        throw EBox::Exceptions::Internal("The following modules ".
                                         "failed while being restarted, their state is ".
                                         "unknown: $failed");
    }

    $log->info("Restarting system logs");
    try {
        root("/etc/init.d/sysklogd restart");
        root("/etc/init.d/klogd restart");
        root("/etc/init.d/cron restart");
    } catch EBox::Exceptions::Internal with {
    };
} ]]>
              </programlisting>
            </example>

            <para>First we get an <classname>EBox::Global</classname>
            instance that will build instances of every eBox module.
            We restart all modules except <emphasis>network</emphasis>
            and <emphasis>firewall</emphasis>, catching any exception
            that may be thrown while restarting them. Then we manually
            restart the system daemons: <emphasis>sysklogd</emphasis>,
            <emphasis>klogd</emphasis> and <emphasis>crond</emphasis>.
            Doing this requires root privileges so we invoke the
            <function>root</function> function.</para>

          </listitem>
        </varlistentry>
      </variablelist>

    </section>

    <section id='sect-example-cgis'>
      <title>Creating CGIs and templates</title>

      <para>After designing and implementing the API, it is time to create
      the layer that will interact with it: CGIs and mason templates. As
      you saw in <xref linkend='sect-example-define'/>, this module is
      going to answer NTP queries for clients in the local network. The
      API that enables and disables this service was implemented in <xref
      linkend='sect-example-api'/>. We will now create two CGIs and a mason
      template that will use these methods to give the user an interface for
      this feature:</para>

      <para>The two CGIs are <classname>EBox::CGI::NTP::Index</classname> and
      <classname>EBox::CGI::NTP::Enable</classname>, the template is called
      <filename>ntp/index.mas</filename>.</para>

      <para>Our first CGI is <classname>EBox::CGI::NTP::Index</classname>.
      It inherits from <classname>EBox::CGI::ClientBase</classname> and
      implements a constructor that sets the title for our page and the name
      of the template associated to this CGI. This is the constructor:</para>

      <example id="cgi-constructor-example"> 
        <title>Constructor for <classname>EBox::CGI::NTP::Index</classname>
        </title>
        <programlisting><![CDATA[package EBox::CGI::NTP::Index;

use strict;
use warnings;

use base 'EBox::CGI::ClientBase';

use EBox::Global;
use EBox::Gettext;

sub new {
    my $class = shift;
    my $self = $class->SUPER::new('title'    => NTP,
                                  'template' => 'ntp/index.mas', @_);
                                  $self->{domain} = "ebox-ntp";
    bless($self, $class);
    return $self;
} ]]>
        </programlisting>
      </example>

      <para>A noteworthy detail is the fact that the title string in this
      CGI is not translatable, and thus we haven't followed the instructions
      in <xref linkend='sect-i18n-developers'/> for i18n. If the title was
      translatable we would have followed those instructions.</para>

      <para>We are now ready to implement the
      <methodname>_process</methodname> method, which reads the current
      configuration for the NTP server and feeds it to the mason
      template.</para>

      <example id="mason-template-example">
        <title>Feeding the configuration of the NTP server to the mason
        template</title>

        <programlisting><![CDATA[sub _process
{
    my $self = shift;
    my $ntp = EBox::Global->modInstance('ntp');

    my @array = ();
    my $active = 'no';

    if ($ntp->service()) {
        $active = 'yes';
    }

    push (@array, 'active'     => $active);
    $self->{params} = \@array;
    }]]>
        </programlisting>
      </example>

      <para>You can see that the first thing we do is create an instance of
      our module (ntp) using <classname>EBox::Global</classname>. We use this
      instance to invoke the <methodname>service</methodname> method, which
      returns the configuration of the server and we pass it to the mason
      template placing it in the <structfield>param</structfield> attribute
      of the CGI. If the mason template needed more arguments we would just add
      them to the <varname>array</varname> variable.</para>

      <para>This CGI we just implemented, along with its mason template,
      shows the current configuration for the NTP server. We will now
      implement the CGI that will receive a new configuration from the user
      and will tell the backend to change it.</para>

      <example id="cgi-enable-ntp-example">
        <title>CGI to enable and disable the NTP server</title>
        <programlisting><![CDATA[package EBox::CGI::NTP::Enable;

use strict;
use warnings;

use base 'EBox::CGI::ClientBase';

use EBox::Global;
use EBox::Gettext;

sub new 
{
    my $class = shift;
    my $self = $class->SUPER::new('title' => 'NTP', @_);
    $self->{redirect} = "NTP/Index";
    $self->{domain} = "ebox-ntp";
    bless($self, $class);

    return $self;
}

sub _process
{
    my $self = shift;
    my $ntp= EBox::Global->modInstance('ntp');

    $self->_requireParam('active', __('module status'));
    $ntp->setService(($self->param('active') eq 'yes'));
}

1; ]]> </programlisting>
      </example>

      <para>Its implementation is quite simple, only a couple of details are
      noteworthy.</para>

      <para>First, the constructor sets the
      <structfield>redirect</structfield> attribute to
      <literal>NTP/Index</literal>. This will make the browser invoke that
      CGI after setting the configuration so that the value shown to the user
      is refreshed.</para>

      <para>Finally, we use the <methodname>setService</methodname> method,
      and we pass it a boolean argument that results from the reading of the
      <parameter>active</parameter> parameter from the HTTP request. HTTP
      parameters are fetched by invoking the <methodname>param</methodname>
      method from the parent class.</para>

      <para>Next we are going to create the mason template that will
      display the configuration and the form to change it. This is an
      special case, since most eBox modules will need to enable/disable
      network services. A common way of doing this is provided by the
      <filename>enable.mas</filename> mason template, which is part of the
      basic framework.</para>

      <para>It is very easy to use it. We create a template that receives an
      argument with the current configuration of the server. As explained
      in <xref linkend='sect-mason'/> we can include an external template
      by writing: 
      <programlisting><![CDATA[<& template.mas, @arguments &>]]></programlisting>.
      We are going to include <filename>enable.mas</filename> and we give it two
      arguments, the title and the current configuration of the NTP server. It
      looks like this:</para>

      <example id="mason-template-NTP-example"> 
        <title>Mason template for enabling the NTP server</title> 
        <programlisting><![CDATA[<%args> $active </%args>
<%init> use EBox::Gettext; </%init>

<div class='ntpnew'>
  <br />
  <& enable.mas, title => __('Enable the local NTP server'),
     active => $active &>
</div>        ]]>
        </programlisting>
      </example>

      <para>Using <filename>enable.mas</filename> requires that
      the CGI that enables or disables the service be called
      <classname>Enable</classname>, since that is hard-coded into
      <filename>enable.mas</filename>. If you take another look at the CGI
      we implemented for this purpose, you'll see that its classname is
      <classname>EBox::CGI::NTP::Enable</classname>, just as required.</para>

      <para>We are now missing the CGIs that change the time zone, the time
      and date, and set the external NTP servers. These CGIs and templates
      are quite simple, it you want to see their source code you can check
      the subversion repository, their code will not be shown here, we'll
      limit ourselves to a quick overview of the files involved and their
      relationships.</para>

      <para>Two CGIs handle the time zone changing feature:</para>

      <itemizedlist>
        <listitem>
          <para><classname>Timezone</classname> uses a mason template
          (<filename>timezone.mas</filename>) to display the current timezone
          configuration.</para>
        </listitem>
        <listitem>

          <para><classname>ChangeTimeZone</classname> receives
          the new timezone from the web browser and invokes the
          <methodname>SetNewTimeZone</methodname>.</para>
        </listitem>
      </itemizedlist>

      <para>There is one more detail about the
      <classname>TimeZone</classname> CGI. It sends the current country and
      continent to the mason template, but it also sends a list with all
      possible continents and a hash that links each continents with the
      list of countries it contains. All this information is read from the
      <filename>/usr/share/zoneinfo/zone.tab</filename> file.</para>

      <para>Finally, our module provides two ways to establish the system's
      time and date: manually and synchronizing with external NTP servers.
      Each of these two methods excludes the other one (the user can only
      use one of the two methods). The <classname>Datetime</classname> CGI
      displays the information about the current time and date and the
      configuration of the external NTP servers stored in gconf. Two CGIs let
      the user change the settings shown in <classname>Datetime</classname>:
      <classname>Synch</classname> enables the synchronization against
      external NTP servers and <classname>ChangeDate</classname> changes the
      time and date manually.</para>

      <para>We just said that only one of the two methods may be used at
      the same time. This is enforced by the mason templates, and we are
      going to see how it's done. The <filename>datetime.mas</filename>
      template gets its arguments from the <classname>Datetime</classname>
      CGI, it includes the template <filename>synch.mas</filename>
      which lets the user choose whether he wants to set the time
      manually or use external NTP servers. Then, depending on the
      current configuration it loads the NTP server selection template
      (<filename>servers.mas</filename>) or the manual time and date
      configuration template (<filename>date.mas</filename>).</para>

      <example id="datetime-tmpl-example">
        <title><filename>datetime.mas</filename> template</title>
        <programlisting><![CDATA[
<& /ntp/synch.mas, title => __('Synchronize with external NTP servers'),
   synchronized => $synchronized &>

% if ($synchronized eq 'yes') {
    <& /ntp/servers.mas, title => __('External NTP servers'), servers => \@servers
    &>
% }

% if ($synchronized eq 'no') {
    <& /ntp/date.mas, title => __('Change Date and Time'), date => \@date &>
% }]]>
        </programlisting>
      </example>

      <para><filename>synch.mas</filename>, <filename>server.mas</filename>
      and <filename>date.mas</filename> just display the information that
      <filename>datetime.mas</filename> sends them as arguments.</para>
    </section>

    <section id='sect-example-menu'>
      <title>Showing the menu and the Summary page</title>

      <para>We are already in the final steps in the development of our
      module. Now we are going to add a new section to the eBox menu that
      will let the user access the user interface of our module and a section
      to the summary page with information about the ntp module.</para>

      <para>Adding a new section to the menu is as simple as
      implementing the <methodname>menu</methodname> method in our
      <classname>EBox::NTP</classname> class. This method gets an instance
      of <classname>EBox::Menu::Root</classname> to which we will add
      a new NTP section with several items: <quote>NTP Server</quote>,
      <quote>Date/Time</quote> and <quote>Time zone</quote>. Here is the
      <methodname>menu</methodname> method:</para>

      <example id="entries-menu-example">
        <title>Adding entries to the eBox menu</title>
        <programlisting><![CDATA[sub menu
{
    my ($self, $root) = @_;
    my $folder = new EBox::Menu::Folder('name' => 'NTP',
                                        'text' => __('NTP'));

    $folder->add(new EBox::Menu::Item('url' => 'NTP/Index',
                                      'text' => __('NTP server')));
    $folder->add(new EBox::Menu::Item('url' => 'NTP/Datetime',
                                      'text' => __('Date/time')));
    $folder->add(new EBox::Menu::Item('url' => 'NTP/Timezone',
                                      'text' => __('Time zone')));
    $root->add($folder);
}]]>
        </programlisting>
      </example>

      <para>As you saw in <xref linkend='sect-menu'/>, a new section is
      created with an instance of <classname>EBox::Menu::Folder</classname>,
      which needs to be given a name.</para>

      <para>The we add to it instances of
      <classname>EBox::Menu::Item</classname> which needs a name and a URL
      (as we explained in <xref linkend='sect-cgi'/>, we only need to specify
      <quote>NTP/Index</quote>, not the whole path).</para>

      <para>The NTP module is not going to have its own section in the
      summary page as there is not much information to display. We'll just
      add an entry in the status table at top of that page. For that we are going
      to implement the <methodname>statusSummary</methodname> method in
      <classname>EBox::NTP</classname>:</para>

      <example id="ntp-summary-example">
        <title><methodname>statusSummary</methodname> in 
        <classname>EBox::NTP</classname></title>

        <programlisting><![CDATA[sub statusSummary
{
    my $self = shift;
    return new EBox::Summary::Status('ntp', __('NTP local server'),
                                     $self->isRunning, $self->service);
}]]>
        </programlisting>
      </example>

    </section>

    <section id='sect-example-daemon'>
      <title>Generating config files and managing the NTP server</title>

      <para>Let's see how you can use mason templates to generate the config
      file for the NTP server. In <xref linkend='sect-example-define'/>
      we saw that the NTP server reads all its configuration from the
      <filename>/etc/ntp.conf</filename> file. We'll use the same system we
      use to generate HTML for this file.</para>

      <para>This part of the module belongs in the backend, so
      all the methods needed to implemented will be placed in
      <classname>EBox::NTP</classname>.</para>

      <para>We have created a private method called
      <methodname>_setNTPConf</methodname> which will be invoked every time
      we need to generate the configuration file. Here it is:</para>

      <example id="generating-NTP-conf-example">
        <title> Generating the <filename>/etc/ntp.conf</filename> configuration
        file</title>

        <programlisting><![CDATA[sub _setNTPConf
{
    my $self = shift;
    my @array = ();
    my @servers = $self->servers;
    my $synch = 'no';
    my $active = 'no';

    ($self->synchronized) and $synch = 'yes';
    ($self->service) and $active = 'yes';

    push(@array, 'active'   => $active);
    push(@array, 'synchronized'  => $synch);
    push(@array, 'servers'  => \@servers);
    
    $self->writeConfFile(NTPCONFFILE, "ntp/ntp.conf.mas", \@array);
}]]>
        </programlisting>
      </example>

      <para>It is very simple, we just add all the arguments for the mason
      template to the <varname>array</varname> variable. Our arguments
      are:</para>

      <variablelist>
        <varlistentry>
          <term><parameter>active</parameter></term>
          <listitem>
            <para>It tells the template whether we are going to offer the NTP
            service for clients in our network or not.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><parameter>synchronized</parameter></term>
          <listitem>
            <para>It tells the template whether we are going to synchronize our
            system's time with external NTP servers.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><parameter>servers</parameter></term>
          <listitem>
            <para>It's an array with the list of external NTP servers.</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <para>After building the array with the arguments we call
      <methodname>writeConfFile</methodname>, which generates the configuration
      file with proper permissions and needs these arguments:</para>
      
      <itemizedlist>
        <listitem>
          <para>The absolute path to the configuration file. In our case it is the
          <constant>NTPCONFFILE</constant> constant, which is defined in the
          beginning of our module: </para>
          <programlisting><![CDATA[use constant NTPCONFFILE => "/etc/ntp.conf";]]></programlisting>
        </listitem>

        <listitem>
          <para>The path to the mason template that generates the file.</para>
        </listitem>

        <listitem>
          <para>An array with the arguments for the template.</para>
        </listitem>
      </itemizedlist>

      <para>And now let's see the template. We decided to leave some of the
      values in the configuration file with fixed values, other values are dynamic and
      are generated based on the arguments received:</para>

      <example id="gen-tmpl-NTP-example">
        <title>Template to generate
        <filename>/etc/ntp.conf</filename></title>
        <programlisting><![CDATA[<%args>
$active
$synchronized
@servers
</%args>
# /etc/ntp.conf, configuration for ntpd
# Generated by EBox

driftfile /var/lib/ntp/ntp.drift
statsdir /var/log/ntpstats/

% if ($synchronized eq 'yes') {
%       if ($servers[0]) {
server <% $servers[0] %>
%       }
%       if ($servers[1]) {
server <% $servers[1] %>
%       }
%       if ($servers[2]) {
server <% $servers[2] %>
%       }
% }
% if ($active eq 'yes') {
server 127.127.1.0
% }
fudge 127.127.1.0 stratum 13

restrict default kod notrap nomodify nopeer noquery

restrict 127.0.0.1 nomodify]]>
        </programlisting>
      </example>

      <para>The only thing left is the code to manage the ntp
      daemon. We have to implement several methods, the first is an
      abstract method defined in <classname>EBox::Module</classname>:
      <methodname>_regenConfig</methodname>. It is invoked when services
      are restarted or when a new configuration for a module is saved.
      It has to generate the configuration file, using the already seen
      <methodname>_setNTPConf</methodname> method. Let's see it:</para>

      <example id="regenConfig-example">
        <title><methodname>_regenConfig</methodname> method</title>
        <programlisting><![CDATA[sub _regenConfig
{
    my $self = shift;

    $self->_setNTPConf;
    $self->_doDaemon();
    }]]>
        </programlisting>
      </example>

      <para>Besides invoking <methodname>_setNTPConf</methodname>,
      it needs to restart the daemon, it does so by calling
      a private method: <methodname>_doDaemon</methodname>.
      Together with methods <methodname>_stopService</methodname>, and
      <methodname>isRunning</methodname>, <methodname>_doDaemon</methodname>
      performs the management of the daemon. Let's see them one by
      one:</para>

      <example id="ntp-daemon-example">
        <title>NTP daemon management method</title>
        <programlisting><![CDATA[sub _doDaemon
        {
           my $self = shift;
           my $logger = EBox::Global->logger;

           if (($self->service or $self->synchronized) and $self->isRunning) {
                 EBox::Service::manage('ntpd','stop');
                 sleep 2;
                 if ($self->synchronized) {
                     my $exserver = $self->get_string('server1');
                     try {
                         root("/usr/sbin/ntpdate $exserver");
                     } catch EBox::Exceptions::Internal with {
                         $logger->info("Error, ntpdate could" .
                                       " not be started.");
                     };
                 }
                 EBox::Service::manage('ntpd','start');
            } elsif ($self->service or $self->synchronized) {
                 if ($self->synchronized) {
                    my $exserver = $self->get_string('server1');
                    try {
                       root("/usr/sbin/ntpdate $exserver");
                    } catch EBox::Exceptions::Internal with {
                       $logger->info("Error ntpdate could" .
                                     " not be started.");
                    };
                 }
                 EBox::Service::manage('ntpd','start');
            } elsif ($self->isRunning) {
                 EBox::Service::manage('ntpd','stop');
                 if ($self->synchronized) { 
                     EBox::Service::manage('ntpd','start');
                 }
           }
        }]]></programlisting>
      </example>

      <para>This method is invoked:</para>
      
      <itemizedlist>
        <listitem>
          <para>To launch the server if it was stopped.</para>
        </listitem>
        <listitem>
          <para>To restart the server when it is running.</para>
        </listitem>
        <listitem>
          <para>To stop the server.</para>
        </listitem>
      </itemizedlist>

      <para>Depending on which case we are in it calls
      <methodname>EBox::Service::manage</methodname> telling it which action we want to
      perform: start or stop. If the system date is to be synchronised
      with external servers we should try to make a manual query with the
      <command>/usr/sbin/ntpdate</command> before starting the daemon. This
      is a recommended practice before launching the ntp daemon.</para>

      <para>Let's see how <methodname>EBox::Service::manage</methodname> works,
      it starts, stops or restarts a service directly depending on its
      argument. It uses <ulink url="http://smarden.org/runit/">
      <application>runit</application></ulink> application to manage automatically
      daemon by its supervision. This allows us to check the daemon status,
      for how long and restart the service every time is goes down.</para>

      <para>
        In order to configure a runit service, it is required to edit a shell script
        with the service name, in our case <parameter>ntpd</parameter>, indicating
        how the service is run in foreground mode. This file must place in
        <filename>tools/runit/</filename> directory.
      </para>

      <example id="ntpd-runit-example">
        <title><filename>tools/runit/ntpd</filename> file</title>
        <programlisting><![CDATA[
#!/bin/sh
exec 2>&1
exec /usr/sbin/ntpd -n -g]]>

        </programlisting>
      </example>

      <para>There only two methods left for you to see.
      <methodname>_stopService</methodname> is defined as an abstract method by
      <classname>EBox::Module</classname>, it just stops the service.
      <methodname>isRunning</methodname> tells us whether the ntp daemon is
      currently running, it does so by checking its process id (PID).</para>

      <example id="stopservice-example">
        <title><methodname>_stopService</methodname> method.</title>
        <programlisting><![CDATA[sub _stopService
{
    my $self = shift;

    if ($self->isRunning) {
        $self->_daemon('stop');
    }
}]]> 
        </programlisting>
      </example>

      <example id="ntp-running-example">
        <title>Telling whether the NTP daemon is running or not.</title>
        <programlisting><![CDATA[sub isRunning
{
   my $self = shift;
   return $self->pidFileRunning(PIDFILE);
}]]> 
        </programlisting>
      </example>
    </section>

    <section id='sect-example-firewall'>
      <title>Setting up proper firewall rules</title>

      <para>The last step in creating this module is to let the firewall know
      about our needs, so that the ntp service works fine. If our date is set
      by querying external servers we will need to make UDP connections on
      port 123 to them. We also need to let clients connect to our 123 UDP
      port if we are going to be an NTP server. We created a private method
      called <methodname>_configureFirewall</methodname> that takes care of
      all this stuff. Here it is:</para>

      <example id="firewall-conf">
        <title>Firewall configuration</title>
        <programlisting><![CDATA[sub _configureFirewall
{
    my $self = shift;
    my $fw = EBox::Global->modInstance('firewall');

    if ($self->synchronized) {
        $fw->addOutputRule('udp', 123);
    } else {
        $fw->removeOutputRule('udp', 123);
    }

    if ($self->service and (!defined($fw->service('ntp')))) {
        $fw->addService('ntp', 'udp', 123, 0);
        $fw->setObjectService('_global', 'ntp', 'allow');
    } elsif ( !($self->service) and defined($fw->service('ntp')) ) {
        $fw->removeService('ntp');
    }
}]]>
        </programlisting>
      </example>

      <para>The eBox firewall module simplifies this job providing
      methods that let us add new rules to the firewall. First of all
      we need an instance of the firewall module, as usual we use
      <classname>EBox::Global</classname> to get it. Then we add the
      output rule if we need to connect to external servers or remove
      it if we do not need to and it had been previously added. The
      methods for this are <methodname>addOutputRule</methodname> and
      <methodname>removeOutputRule</methodname>.</para>

      <para>For our NTP server, we need to register our service with
      the firewall by calling <methodname>addService</methodname>
      and then we'll allow it by default by calling
      <methodname>setObjectService</methodname>. If the NTP server feature is
      disabled we remove the ntp service from the firewall by calling
      <methodname>removeService</methodname>.</para>

    </section>
    
    <section id='sect-example-conclusion'>
      <title>Conclusion</title>

      <para>We are done, we just created an eBox module form scratch. We've
      gone through every step needed and seen what issues to watch out for.
      Now it is time to try it out and do some tests to check that it works
      as we expect. We hope this guide has been helpful and encourages you
      to contribute to making it a better platform with new modules and
      features.</para>
    </section>

  </section>

  <section id="sect-short-way">
    
    <title>Short way to create a small module</title>

    <para>
      Previously in <xref linkend="long-way-sect"/>, a long way to create an 
      eBox module has been explained, however in this section we are going to
      use the MVC framework described in <xref linkend="sect-a-mvc-module"/>.
      This will reduce our development time turning into a less
      error-prone and with a greater quality. Since less code is
      required to be written and this code will handle the compulsory
      logic avoiding to do repetitive tasks such as CGI or template
      creation as well as manage database backend directly letting
      developer focus on what really cares to add the new service to
      eBox.
    </para>

    <para>
      As it was done in <xref linkend="long-way-sect"/>, we have
      chosen a service, in this case, the 
      <ulink url="http://www.w3.org/Protocols/">HyperText Transfer Protocol</ulink> server.
      We have selected the <ulink url="http://httpd.apache.org">Apache
      HTTP server version 2</ulink> to provide a simple glance of how
      powerful the MVC framework is to develop eBox agility and
      correctly. The web server eBox module has these following
      requirements:
    </para>
    
    <itemizedlist>
      <listitem>
        <para>Enable and disable the service as other eBox modules do</para>
      </listitem>
      <listitem>
        <para>Some general configuration settings as port number to listen to
        HTTP requests or enable Web pages provided by users' home in <filename>public_html</filename>
        subdirectory.</para>
      </listitem>
      <listitem>
        <para>Virtual host creation and configuration giving automatic 
        name resolution management using our DNS module.</para>
      </listitem>
    </itemizedlist>

    <para>
      These steps are going to follow to develop this module:
    </para>

    <itemizedlist>
      <listitem>
        <para>Define the <emphasis>data model</emphasis> to accomplish
        the requested features</para>
      </listitem>
      
      <listitem>
        <para>Define the graphical user interface using
        <emphasis>Composites</emphasis></para>
      </listitem>

      <listitem>
        <para>Create the new module from a template publishing the data 
        model and composites</para>
      </listitem>


      <listitem>
        <para>Common tasks done as well in the <link linkend="long-way-sect">long way Section</link>
        such as generate configuration files, control daemon execution, firewall rules and
        set menu and status summary.
        </para>
      </listitem>

      <listitem>
        <para>Expose the desired API to other eBox's modules, Perl script clients or SOAP interface</para>
      </listitem>
    </itemizedlist>

    <section id="define-data-model-sect">

      <title>Define data model</title>
      <para>
        In order to do the enable/disable web service, we can use the common form model which
        shows, store a boolean value to enable/disable service called
        <classname>EBox::Common::Model::EnableForm</classname>. So we delayed this feature till
        <xref linkend="publish-model-composite-sect"/> where the instantiation is done.
      </para>

      <para>
        The general apache configuration is a form which contains the
        port number which is a specific Port type and a Boolean type
        to enable users publish their own HTML pages under
        <filename>public_html</filename> directory from their own home
        directory. The description is displayed in <xref
        linkend="general-conf-example"/> inside the
        <classname>EBox::WebServer::Model::GeneralSettings</classname> class.

        <example id="general-conf-example">
          <title>General configuration settings description</title>
          <programlisting><![CDATA[
sub _table
{

    my @tableHeader =
      (
       new EBox::Types::Port(
                             fieldName     => 'port',
                             printableName => __('Listening port'),
                             editable      => 1,
                             defaultValue  => 80,
                            ),
       new EBox::Types::Boolean(
                                fieldName     => 'enableDir',
                                printableName => __x('Enable per user {dirName}',
                                                     dirName => PUBLIC_DIR),
                                editable      => 1,
                               ),
      );

    my $dataTable =
      {
       tableName          => 'GeneralSettings',
       printableTableName => __('General configuration settings'),
       defaultActions     => [ 'editField', 'changeView' ],
       tableDescription   => \@tableHeader,
       class              => 'dataForm',
       help               => __x('General Web server configuration. The listening port '
                                 . 'must not be got from another service. If you enable '
                                 . 'user to publish their own html pages, the pages will be '
                                 . 'loaded from {dirName} directory from their samba home directories',
                                 dirName => PUBLIC_DIR),
       messages           => {
                              update => __('General Web server configuration settings updated'),
                             },
       modelDomain        => 'WebServer',
      };

    return $dataTable;

}]]>
          </programlisting>
        </example>

        The <classname>Port</classname> type supported by services eBox module allows
        us to show and set a port number which resides in its data models, checking itself that
        the given number is a valid port and, if the firewall module is installed, check its
        availability.
      </para>

      <para>
        Once the general configuration is done, we are going to generate a list 
        of virtual hosts to live inside our web server. As the module is 
        a proof concept, only a name will be provided to generate a virtual host
        and additional check box to enable/disable the site.
        The document root is fixed and it is related to the virtual host's name
        and it is enabled by default. As it may live as many as we wish, a data
        model in a table is the best solution to address here. Its description is
        shown in <xref linkend="vhost-description-example"/> inside the
        <classname>EBox::WebServer::Model::VHostTable</classname> class.
        <example id="vhost-description-example">
          <title>Virtual host data model description</title>
          <programlisting><![CDATA[
sub _table
{
    my @tableHead =
        (
         new EBox::Types::Text(
                                fieldName     => 'name',
                                printableName => __('Name'),
                                size          => 12,
                                unique        => 1,
                                editable      => 1,
                             ),
        );

    my $dataTable =
      {
       tableName           => 'VHostTable',
       printableTableName  => __('Virtual hosts'),
       defaultActions      => ['add', 'del', 'editField',  'changeView' ],
       tableDescription    => \@tableHead,
       class               => 'dataTable',
       help                => __x('Virtual hosts are a form of web hosting service where '
                                  . 'many instances of the same web server is hosted on a '
                                  . 'single physical server. Different host names will point '
                                  . 'to the same web server. The DNS entry is automatically created'
                                  . ' if this is possible. The content must be placed under '
                                  . '{docRoot}/vHostName directory',
                                 docRoot => EBox::WebServer::PlatformPath::DocumentRoot()),
       printableRowName    => __('virtual host'),
       modelDomain         => 'WebServer',
       sortedBy            => 'name',
       enableProperty      => 1,
       defaultEnabledValue => 1,
      };

    return $dataTable;
}]]>
            
          </programlisting>
        </example>
        As you may see, the <parameter>enabled</parameter> field is
        not directly set as another type. The framework allows to set
        <property>enableProperty</property> to one with a default
        value, namely <property>defaultEnabledValue</property>, and
        automatically a new field called <varname>enabled</varname> is
        added to the model as a
        <classname>EBox::Types::Boolean</classname> type.
      </para>
      <para>
        As we want to order the virtual host by name, we must set the
        property <property>sortedBy</property> with the field name we
        want to order the table content.
      </para>

      <para>
        One of our requisites is to handle DNS domains automatically
        provided that the DNS is installed. This is done whenever a
        virtual host is added to the model through
        <methodname>addedRowNotify</methodname>. We try to add the
        domain and the host name from a new added virtual host split
        the virtual host's name from the first dot, i.e. having
        <emphasis>www.example.com</emphasis> as virtual host's name
        the host name is <emphasis>www</emphasis> and the domain
        <emphasis>example.com</emphasis>. If the domain does exist, it
        tries to add a host name. However, if the guessed IP address is
        already taken, an alias to the owner host name is added. Regarding
        to the IP address assigned to that host, we try to guess it
        from any static interface starting with internal one through
        <methodname>_guessWebIPAddr</methodname> private helper
        method. The program listing is shown in <xref
        linkend="added-dns-example"/>.
        <example id="added-dns-example">
          <title>Adding name resolution to the virtual host</title>
          <programlisting><![CDATA[
sub addedRowNotify
{
    my ($self, $row) = @_;

    # Get the DNS module
    my $gl = EBox::Global->getInstance();
    if (not  $gl->modExists('dns') ) {
        # no DNS module present, nothing to add then
        return;
    }

    my $dns = $gl->modInstance('dns');

    my $vHostName = $row->{plainValueHash}->{name};
    my ($hostName, $domain) = ( $vHostName =~ m/^(.*?)\.(.*)/g );

    # We try to guess the IP address
    my $ip = $self->_guessWebIPAddr();
    if ( $ip ) {
        if ( none(map { $_->{name} } @{$dns->domains()}) eq $domain ) {
            # The domain does not exist, add domain with hostname-ip mapping
            my $domainData = {
                              domain_name => $domain,
                              hostnames => [
                                            {
                                             hostname => $hostName,
                                             ip       => $ip,
                                            },
                                           ],
                             };
            $dns->addDomain($domainData);

            $self->setMessage(__x('Virtual host {vhost} added. A domain {domain} ' .
                                  'has been created with the mapping ' .
                                  'name {name} - IP address {ip} ',
                                  vhost => $vHostName,
                                  domain => $domain,
                                  name   => $hostName,
                                  ip     => $ip
                                 ));
        } else {
            my @hostNames = @{$dns->getHostnames($domain)};
            if ( none(map { $_->{name} } @hostNames ) eq $hostName ) {
                # Check the IP address
                my ($commonHostName) = grep { $_->{ip} eq $ip } @hostNames;
                unless ( $commonHostName ) {
                    # Add a host name
                    $dns->addHostName( $domain,
                                       hostname => $hostName,
                                       ipaddr => $ip);
                    $self->setMessage(__x('Virtual host {vhost} added. A mapping ' .
                                          'name {name} - IP address {ip} has been added ' .
                                          'to {domain} domain',
                                          vhost  => $vHostName,
                                          name   => $hostName,
                                          ip     => $ip,
                                          domain => $domain,
                                         ));
                } else {
                    # Add an alias
                    my $oldHostName = $commonHostName->{name};
                    try {
                        $dns->addAlias( "/$domain/$oldHostName",
                                        alias => $hostName);
                        $self->setMessage(__x('Virtual host {vhost} added as an alias {alias}'
                                              . ' to hostname {hostname}',
                                              vhost    => $vHostName,
                                              alias    => $hostName,
                                              hostname => $oldHostName));
                    } catch EBox::Exceptions::DataExists with {
                        $self->setMessage(__x('Virtual host {vhost} added',
                                              vhost => $vHostName));
                    }
                }
            } else {
                $self->setMessage(__x('Virtual host {vhost} added',
                                      vhost => $vHostName));
            }
        }
    } else {
        $self->setMessage(__('There is no static internal interface to ' .
                             'set the Web server IP address'));
    }

}

sub _guessWebIPAddr
{
    my ($self) = @_;

    my $netMod = EBox::Global->modInstance('network');

    my @ifaces = @{$netMod->ifaces()};

    @ifaces = grep { $netMod->ifaceMethod($_) eq 'static' } @ifaces;

    return '' unless (@ifaces > 0);

    my @intIfaces = grep { not $netMod->ifaceIsExternal($_) } @ifaces;

    if ( @intIfaces > 0 ) {
        return $netMod->ifaceAddress($intIfaces[0]);
    }

    my @extIfaces = grep { $netMod->ifaceIsExternal($_) } @ifaces;

    return $netMod->ifaceAddress($extIfaces[0]);

}]]>
          </programlisting>
        </example>
        The <methodname>setMessage</methodname> method implies the
        returning message shown to the user when the action is
        made. We use it to inform about the new DNS domain, host name
        or alias added to an existing domain or nothing done since no
        static internal interface has been set up.
      </para>
    </section>
        
    <section id="define-composite-sect">

      <title>Define module web GUI using Composites</title>
      <para>
        At this section, the layout display is explained and how
        easy and rapid the development process is. We want to show our
        previous defined models in a top bottom layout in this order:
        first, the enable/disable button for the web service, then the
        general configuration settings and, finally, the virtual host
        table. We assume the virtual host number for internal use
        will be small and it will match with the window height to see
        the web service configuration at one glance in the same
        page. To achieve so, we define a composite called
        <classname>EBox::WebServer::Composite::General</classname>
        which comprises the three elements in a top-bottom layout as
        <xref linkend="composite-desc-example"/> demonstrates:
        <example id="composite-desc-example">
          <title>General composite to display Web service configuration page</title>
          <programlisting><![CDATA[
sub _description
{

    my $wsMod = EBox::Global->modInstance('webserver');

    my $description =
      {
       components      => [
                           '/' . $wsMod->name() . '/EnableForm',
                           '/' . $wsMod->name() . '/GeneralSettings',
                           '/' . $wsMod->name() . '/VHostTable',
                          ],
       layout          => 'top-bottom',
       name            => 'General',
       printableName   => __('Web service'),
       compositeDomain => 'Web',
       help            => __('The eBox web service allows you ' .
                             'to host Web pages in plain HTML ' .
                             'within different virtual hosts'),
      };

    return $description;

}]]>
          </programlisting>
        </example>
        As you may notice, only the model names are required to integrate the
        components inside the composite.
      </para>

    </section>
    <section id="publish-model-composite-sect">

      <title>Publishing model and composite from this module</title>
      <para>
        In order to let eBox see the models and composites defined
        above, i.e. publish them on eBox framework, so 
        that they access and manipulate their data. Let's edit the
        main module class <classname>EBox::WebServer</classname>. To publish
        models and composites, we must override <methodname>modelsClasses</methodname> and
        <methodname>compositeClasses</methodname> methods from
        <classname>EBox::Model::ModelProvider</classname> and
        <classname>EBox::Model::CompositeProvider</classname> respectively as 
        <xref linkend="model-access-sect"/> describes.
        
        <example id="webserver-publish-example">
          <title>Publishing models and composites from web server module</title>
          <programlisting><![CDATA[
sub modelClasses
{
  return [
	  {
	   class => 'EBox::Common::Model::EnableForm',
	   parameters => [
			  enableTitle => __('Web service status'),
			  domain => 'ebox-webserver',
                          modelDomain => 'WebServer',
			 ],
	  },
	  'EBox::WebServer::Model::GeneralSettings',

          'EBox::WebServer::Model::VHostTable',
	 ];
}
sub compositeClasses
{
 return [
            'EBox::WebServer::Composite::General',
         ];
}]]>
          </programlisting>
        </example>
        With every method you must describe those models and
        composites you are going to use. The provider is in charge of
        instantiate the classes avoiding the developer to execute
        repetitive and error-prone tasks.
      </para>
      <para>
        In those cases where the model constructor requires
        parameters, as it happens in <xref
        linkend="webserver-publish-example"/>, two elements are used
        per component, the <parameter>class</parameter> string and its
        <parameter>parameters</parameter> in a hash form using the
        parameter name as key. The <classname>EnableForm</classname>
        is a common model which is intended to be used in different
        modules to enable/disable a service. Because of that, its
        construction is a bit different from the other ones, since the
        model is parametrised with the gettext domain
        (<parameter>domain</parameter>), its title 
        (<parameter>enableTitle</parameter>) and the model domain
        (<parameter>modelDomain</parameter>). The remainder two methods
        are general ones used along eBox the code.
      </para>
      <para>
        Once the model is published, you can access the instances via
        these helper methods offered by providers,
        <methodname>model</methodname> and
        <methodname>composite</methodname> which given the model name,
        it returns the instance of that model.
      </para>

    </section>
    <section id="common-tasks-sect">

      <title>Common tasks</title>
      <para>
        The differences between long way and short way are almost
        done. On this final part, the main difference is the way
        to access the stored information. Traditional way allows accessing
        data stored at GConf directly, however with the MVC scheme the data
        is got through the data model. These steps are required to finish
        the module:
        <itemizedlist>
          <listitem>
            <para>Generate the configuration files.</para>
          </listitem>
          <listitem>
            <para>Control the daemon execution.</para>
          </listitem>
          <listitem>
            <para>Make the module show up in eBox menu and status summary page.
            </para>
          </listitem>
          <listitem>
            <para>Establish rules through services and firewall modules to use
            Web service in eBox.</para>
          </listitem>
        </itemizedlist>
        Taking a look to the 
        <link linkend="long-steps-creating-module-list">long way of a module creation</link>,
        we can observe as we have removed any CGI or mason development. Inside
        this section the two steps of the three steps are going to be described
        in some detail.
      </para>

      <para>
        What is known the eBox module "backend" is done in <classname>EBox::WebServer</classname>.
        Firstly, the constructor must indicate to eBox its name and Gettext domain as
        <xref linkend="webserver-constructor-example"/> shows.
        <example id="webserver-constructor-example">
          <title>WebServer module constructor</title>
          <programlisting><![CDATA[
sub _create
{
	my $class = shift;
	my $self = $class->SUPER::_create(
                                          name => 'webserver',
                                          domain => 'ebox-webserver',
                                          @_,
                                         );
	bless($self, $class);
	return $self;
}]]>
          </programlisting>
        </example>
        Every time the Web service is restarted, the configuration is
        regenerated and the daemon(s) are restarted as well through
        the <methodname>_regenConfig</methodname> protected
        method. Its configuration is done as following:
        <example id="regen-Web-example">
          <title><methodname>_regenConfig</methodname> for web service</title>
          <programlisting><![CDATA[
sub _regenConfig
{

    my ($self) = @_;

    $self->_setWebServerConf();
    $self->_doDaemon();

}]]>
          </programlisting>
        </example>
        Both private methods
        <methodname>_setWebServerConf</methodname>, which sets up the
        web service configuration files, and
        <methodname>_doDaemon</methodname>, which manages the
        processes that develop the web services, are explained in the
        below sections and it is known as the module "backend".
      </para>
      
      <section id="configuring-apache2-service">

        <title>Configuring Apache2 service</title>

        <para>
          In order to manage the apache daemon and generate its
          configuration files, it is required to study the Apache web
          server and check if the features we wish to have in our
          service are available. The Apache2 web server is a quite
          complex software which handles several files to configure
          its service.
        </para>

        <para>
          The listening port is set by
          <filename>/etc/apache2/ports.conf</filename> which contains
          the <parameter>Listen</parameter> directive to achieve so.
        </para>

        <para>
          To enable the user directory, the <ulink
          url="http://httpd.apache.org/docs/2.0/mod/mod_userdir.html">mod_userdir</ulink>
          is used. Its availability comes with the debian package
          <classname>apache2-common</classname> and it must be listed
          in <filename>/etc/apache2/mods-available</filename>
          directory as two files <filename>userdir.conf</filename> and
          <filename>userdir.load</filename>. We want to allow userdir
          feature to our LDAP users, to do so we require to include
          another module called <ulink
          url="http://horde.net/~jwm/software/mod_ldap_userdir/">mod_ldap_userdir</ulink>
          which searches for home directory of LDAP users in their
          attributes on the cited database. This Apache2 plugin comes
          in the Debian package
          <emphasis>libapache2-mod-ldap-userdir</emphasis>.
        </para>
        <para>
          In order to enable any apache2 module, it is required to
          create symbolic links to those configuration files inside
          <filename>/etc/apache2/mods-enabled</filename>
          directory. This process is done by
          <command>a2enmod</command>, the disable process is done
          analogously with <command>a2dismod</command>.
          The default configuration is set up in
          <filename>userdir.conf</filename>.
        </para>

        <para>
          Related to the virtual hosts, every new virtual host has a
          predefined template to configure them and it is set under
          <filename>/etc/apache2/sites-available</filename>
          directory. Analogously to <emphasis>userdir</emphasis>
          module, the virtual host will be enabled when a symbolic
          link to that configuration file is placed in
          <filename>/etc/apache2/sites-enabled</filename>
          directory. As the configuration may be not enough for
          advanced users or LAMP installations, we create a directory
          to place the user defined configuration files with the
          following pattern
          <literal>user-ebox-$vhostName</literal>.
        </para>

        <para>
          Similarly as done in <xref linkend="sect-example-daemon"/>, we create a private
          method <methodname>_setWebServerConf</methodname> in order to set up every
          template in the web server configuration as <xref linkend="setup-webserver-conf-example"/>
          whenever the web service is restarted.
          <example id="setup-webserver-conf-example">
            <title>Generating web server configuration files</title>
            <programlisting><![CDATA[
sub _setWebServerConf
  {

      my ($self) = @_;

      $self->_setPort();
      $self->_setUserDir();
      $self->_setVHosts();

  }]]>
            </programlisting>
          </example>
          Every listed helper method sets up a certain part within the apache setup
          process. The first one sets the listening port, the second one enable/disable
          the user directory module and the last one it will set up every configured
          virtual host. The program listing from these modules is described in
          <xref linkend="setup-webserver-example"/>
          <example id="setup-webserver-example">
            <title>Setting up the web server</title>
            <programlisting><![CDATA[
# Set up the listening port
sub _setPort
{

    my ($self) = @_;

    # We can assume the listening port is ready available
    my $generalConf = $self->model('GeneralSettings');

    # Overwrite the listening port conf file
    $self->writeConfFile(PORTS_FILE,
                         "webserver/ports.conf.mas",
                         [ portNumber => $generalConf->portValue() ],
                        )

}

# Set up the user directory by enable/disable the feature
sub _setUserDir
{

    my ($self) = @_;

    my $generalConf = $self->model('GeneralSettings');

    if ( $generalConf->enableDirValue() ) {
        # User dir enabled
        foreach my $confFile (USERDIR_CONF_FILES) {
            unless ( -e AVAILABLE_MODS_DIR . $confFile ) {
                throw EBox::Exceptions::External(__x('The {userDirConfFile} ' .
                                                     'is missing! Please recover it',
                                                     userDirConfFile => AVAILABLE_MODS_DIR . $confFile));
            }
        }
        # Dump the configuration file
        $self->writeConfFile( AVAILABLE_MODS_DIR . (USERDIR_CONF_FILES)[0],
                              'webserver/userdir.conf.mas',
                              []);
        # Enable the module
        EBox::Sudo::root('a2enmod userdir');
    } else {
        # Disable the module
        EBox::Sudo::root('a2dismod userdir');
    }
}

# Set up the virtual hosts
sub _setVHosts
{

    my ($self) = @_;

    my $vHostModel = $self->model('VHostTable');

    my $vHosts = $vHostModel->rows();

    # Remove every available site using our vhost pattern ebox-*
    my $vHostPattern = VHOST_PREFIX . '*';
    EBox::Sudo::root('rm -f ' . SITES_AVAILABLE_DIR . "$vHostPattern");
    EBox::Sudo::root('rm -f ' . SITES_ENABLED_DIR . "$vHostPattern");

    foreach my $vHost (@{$vHostModel->rows()}) {
        # Access to the field values for every virtual host
        my $vHostValues = $vHost->{plainValueHash};

        my $destFile = SITES_AVAILABLE_DIR . VHOST_PREFIX . $vHostValues->{name};
        $self->writeConfFile( $destFile,
                              "webserver/vhost.mas",
                              [ vHostName => $vHostValues->{name} ],
                            );

        # Create the subdir if required
        my $userConfDir = SITES_AVAILABLE_DIR . 'user-' .  VHOST_PREFIX
          . $vHostValues->{name};
        unless ( -d $userConfDir ) {
            EBox::Sudo::root("mkdir $userConfDir");
        }

        if ( $vHostValues->{enabled} ) {
            # Create the symbolic link
            EBox::Sudo::root("ln -s $destFile " . SITES_ENABLED_DIR);
            # Create the directory content if it is not already
            # created
            my $dir = EBox::WebServer::PlatformPath::DocumentRoot()
              . '/' . $vHostValues->{name};
            unless ( -d $dir ) {
                EBox::Sudo::root("mkdir $dir");
            }
        }
    }

}]]>
            </programlisting>
          </example>
          We have accessed to the data model using two different ways. With regard
          to the general configuration form, we have used the auto-loaded methods
          that a <classname>DataForm</classname> has to access the model values
          directly, for instance <literal>$generalConf->portValue()</literal> and
          <literal>$generalConf->enableDirValue()</literal>. Regarding to
          the virtual host data model, as we have to visit each row the usage
          of <methodname>rows</methodname> is compulsory. Furthermore, accessing
          to the helper structure <varname>plainValueHash</varname> since only
          the values are important when a configuration is regenerated. The internal
          logic creates every virtual host configuration from a single template
          and it is written under <filename>sites-available</filename> directory
          using the pattern: <emphasis>ebox-$virtualHostName</emphasis>. If the
          virtual host is enabled, a symbolic link is created under 
          <filename>sites-enabled</filename> directory.
        </para>

        <para>
          The <filename>ports.conf.mas</filename> is pretty simple as
          <xref linkend="ports-example"/> shows. The
          <parameter>doc</parameter> part is set to indicate that
          everything inside them is documentation.
          <example id="ports-example">
            <title><filename>ports.conf.mas</filename> template</title>
            <programlisting><![CDATA[
<%doc>
  ports.conf.mas writes the listening port used by apache virtual host
  to serve Web pages.

  Parameters:

  portNumber - Int the port number to listen to Web requests

</%doc>
<%args>
  $portNumber
</%args>
Listen <% $portNumber %>]]>
            </programlisting>
          </example>
          Regarding to <filename>vhost.mas</filename>, its content is almost as 
          simple as the ports one as we see in <xref linkend="vhost-example"/>.
          <example id="vhost-example">
            <title><filename>vhost.mas</filename> template</title>
            <programlisting><![CDATA[
<%doc>
   Template to configure a simple named virtual host using the default
   site given with the apache2 debian package
   
   Parameters:

   vHostName - String the virtual host's name
</%doc>
<%args>
  $vHostName
</%args>
<%init>
  use EBox::WebServer;
  use EBox::WebServer::PlatformPath;
  my $vHostPrefix = EBox::WebServer::VHostPrefix();
  my $docRoot = EBox::WebServer::PlatformPath::DocumentRoot();
</%init>
NameVirtualHost *
<VirtualHost *>
        ServerAdmin webmaster@localhost

        ServerName <% $vHostName %>
        DocumentRoot <% $docRoot %>/<% $vHostName %>

        ErrorLog /var/log/apache2/error.log

        # Possible values include: debug, info, notice, warn, error, crit,
        # alert, emerg.
        LogLevel warn

        CustomLog /var/log/apache2/access.log combined
        ServerSignature On

        # Under this directory you can manually configure every thing
        # you may need of that stuff
        Include sites-available/<%  'user-' . "$vHostPrefix$vHostName" %>/*
</VirtualHost>]]>
            </programlisting>
          </example>
          Every virtual host may have an
          <filename>sites-available/user-ebox-$vHostName</filename>
          directory to include every manual configuration you may require.
        </para>
      </section>

      <section id="managing-apache2-daemon">

        <title>Manage Apache2 daemon execution</title>

        <para>
          Likewise it is done in <xref linkend="ntp-daemon-example"/>, the web service
          is managed by runit and the private method to manage is called
          <methodname>_doDaemon</methodname>. The <constant>WEB_SERVICE</constant> constant
          contains the <parameter>apache2</parameter> value to name the
          runit service afterwards.

          <example id="web-daemon-example">
            <title>Web daemon management method</title>
            <programlisting><![CDATA[
sub _doDaemon
  {

      my ($self) = @_;

      if ( $self->running() and $self->service() ) {
          EBox::Service::manage(WEB_SERVICE, 'restart');
      } elsif ( $self->service() ) {
          EBox::Service::manage(WEB_SERVICE, 'start');
      } else {
          EBox::Service::manage(WEB_SERVICE, 'stop');
      }

  }]]>
            </programlisting>
          </example>

          The shell script to launch the web service
          <filename>tools/runit/apache2</filename> contains this listing:
          <example id="apache2-runit-example">
            <title><filename>tools/runit/apache2</filename> file</title>
            <programlisting><![CDATA[
            #!/bin/sh
            exec 1>&2
            exec /usr/sbin/apache2 -DNO_DETACH]]>
            </programlisting>
          </example>

          In addition to the launcher, a finisher script, which is run
          whenever a service ends, is used in order to restart the service
          a fixed number of times in a time interval before
          ceasing. This is specially useful when a misconfiguration is
          done in any part of development or an incorrect daemon
          working. The <command>ebox-runit-finisher</command> requires
          two arguments:
          
          <variablelist>
            <varlistentry>
              <term><parameter>eBoxModule</parameter></term>
              <listitem>
                <para>This set the eBox module name</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term><parameter>serviceName</parameter></term>
              <listitem>
                <para>The runit service's name</para>
              </listitem>
            </varlistentry>
          </variablelist>
          The finisher script must follow this pattern: 
          <filename>${serviceName}.finish</filename>. In our example, the 
          shell script <filename>tools/runit/apache2.finish</filename> lists as following:
          <example id="apache2-runit-finisher-example">
            <title><filename>tools/runit/apache2.finish</filename> file</title>
            <programlisting><![CDATA[
            #!/bin/sh
            exec ebox-runit-finisher web apache2]]>
            </programlisting>
          </example>
          Whenever the web service is asked to stop by command line, i.e.
          <command>/etc/init.d/ebox web stop</command>, the 
          <methodname>_stopService</methodname> is called to stop the service as
          we do using the <methodname>EBox::Service::manage</methodname> class method.
          <example id="stop-web-example">
            <title>Stop web service with <methodname>_stopService</methodname> method</title>

            <programlisting><![CDATA[
sub _stopService
  {

      EBox::Service::manage(WEB_SERVICE, 'stop');

  }]]>
            </programlisting>
          </example>
        </para>
      </section>

      <section id="menu-web-sect">
        <title>Web service inclusion in eBox menu and summary</title>

        <para>
          In order to show up the web server in the menu, it is almost the same procedure than
          <xref linkend="sect-example-menu"/>. However, in this case we just add an
          item. The URL to set is going to show the view from the composite 
          <classname>GeneralComposite</classname> that we have defined in 
          <xref linkend="composite-desc-example"/>. To do so, the URL value must
          follow this pattern: <emphasis>$compositeDomain/Composite/$compositeName</emphasis>
          as <xref linkend="menu-webserver-example"/> describes.
          <example id="menu-webserver-example">
            <title>Adding WebServer to the menu</title>
            <programlisting><![CDATA[
sub menu
  {

      my ($self, $root) = @_;

      my $item = new EBox::Menu::Item(name  => 'WebServer',
                                      text  => __('Web'),
                                      url   => 'WebServer/Composite/General',
                                     );

      $root->add($item);

  }]]>
            </programlisting>
          </example>
          Regarding to status summary, the <methodname>statusSummary</methodname> method
          implementation is analogous to the one defined in 
          <xref linkend="ntp-summary-example"/> but swapping every NTP reference to
          Web.
        </para>

      </section>

      <section id="apache-firewall-sect">
        <title>Establish rules through services and firewall modules to use Web service 
        in eBox</title>

        <para>
          In order to establish the web service, we are going to add
          the <emphasis>http</emphasis> service to the
          <classname>services</classname> eBox module on the
          installation and add an internal rule to allow the users
          from internal network to access the service when it is
          enabled. As the listening port is configurable and it may
          differ from the default one, we may set
          the listening port on <classname>GeneralSettings</classname>
          model. This is configured at the firewall module
          through <guimenu>Firewall</guimenu>-><guimenuitem>Packet filter</guimenuitem>.
          It is required to develop two static methods, both are
          included in
          <classname>EBox::WebServer::Maintenance</classname> class to
          be run on installation and removal as <xref
          linkend="on-install-remove-example"/> explains.
          <example id="on-install-remove-example">
            <title><methodname>onInstall</methodname> and <methodname>onRemove</methodname>
            methods to configure web service</title>
            
            <programlisting><![CDATA[
sub onInstall
{
    # Become an eBox user
    EBox::init();

    # Get service module
    my $gl = EBox::Global->getInstance();
    my $serviceMod = $gl->modInstance('services');
    my $firewallMod = $gl->modInstance('firewall');
    my $port = 80; # Default port = 80

    # Add http service
    unless ( $serviceMod->serviceExists('name' => 'http')) {
        # Check port availability
        my $available = 0;
        do {
            $available = $firewallMod->availablePort('tcp', $port);
            unless ( $available ) {
                if ( $port == 80 ) {
                    $port = 8080;
                } else {
                    $port++;
                }
            }
        } until ( $available );
        $serviceMod->addService(
                                'name'            => 'http',
                                'description'     => __('HyperText Transport Protocol'),
                                'protocol'        => 'tcp',
                                'sourcePort'      => 'any',
                                'destinationPort' => $port,
                                'internal'        => 1,
                                'readOnly'        => 1,
                               );
        $firewallMod->setInternalService(
                                        'http',
                                        'accept',
                                       );
        # Save the changes
        $serviceMod->save();
        $firewallMod->save();
    } else {
        EBox::info('The http service is already exists, not adding');
        my $servId = $serviceMod->serviceId('http');
        $port = $serviceMod->serviceConfiguration($servId)->[0]->{destination};
    }
    # Save settings on the model
    my $webMod = $gl->modInstance('webserver');
    my $settingsModel = $webMod->model('GeneralSettings');
    $settingsModel->set(port => $port);
    $webMod->save();

}
sub onRemove
{
    # Become an eBox user
    EBox::init();

    my $serviceMod = EBox::Global->modInstance('services');

    if ($serviceMod->serviceExists('name' => 'http')) {
        $serviceMod->removeService('name' => 'http');
    } else {
        EBox::info("Not removing http service as it already exists");
    }

    $serviceMod->save();
}]]>
            </programlisting>
          </example>
          The default port number to use is 80, however it could be
          used by another service like the administration one. This is
          the reason to check any available port on the
          installation. When an available port is found, it is set on
          <classname>GeneralSettings</classname> model instead of
          using the default value given in model description. These
          methods are required to be executed as eBox user since
          both are called on the installation scripts. This
          is not done automatically and it is required to be called
          explicitly as <xref linkend="pre-post-script-example"/>
          shows on <filename>debian/ebox-web.postinst</filename> and 
          <filename>debian/ebox-web.prerm</filename>.

          <example id="pre-post-script-example">
            <title>Debian scripts</title>

            <programlisting><![CDATA[
# ebox-web.postinst script
...

onInstall() {

    perl -e 'use EBox::WebServer::Maintenance; EBox::WebServer::Maintenance::onInstall();'
}

case "$1" in
	configure)
                ...

		# don't start Web server with its script	
		update-rc.d -f apache2 remove

		onInstall

		invoke-rc.d ebox webserver restart
                invoke-rc.d ebox apache restart
esac

#DEBHELPER#

exit 0

# ebox-web.prerm script
...

#DEBHELPER#

onRemove() {

	perl -e 'use EBox::WebServer::Maintenance; EBox::WebServer::Maintenance::onRemove();'
}

case "$1" in
	upgrade)
		remove_gconf_schemas
		;;
	remove)
		onRemove
		/etc/init.d/ebox webserver stop || true
		remove_gconf_schemas
		;;	
esac]]>
            </programlisting>
          </example>
          As you may see, it is required to remove any previous
          apache2 daemon establishment in order to manage apache2
          server just by eBox.
        </para>
      </section>

    </section>
    <section id="expose-module-API-sect">

      <title>Expose module API</title>
      <para>
        The module has two options to expose the configuration settings. Firstly, it
        may open up every model and let the module client access directly to the data
        model or, secondly, it gives some common methods to access the data easily.
        The latter option is chosen by this tutorial.
      </para>

      <para>
        It seems useful to have a method to get the virtual hosts that already 
        exist in eBox, this is done by <methodname>virtualHosts</methodname> method.
        <example id="vHosts-method-example">
          <title><methodname>virtualHosts</methodname> method</title>
          <programlisting><![CDATA[
sub virtualHosts
{

    my ($self) = @_;

    my $vHostModel = $self->model('VHostTable');
    my @vHosts;
    foreach my $rowVHost (@{$vHostModel->rows()}) {
        my $values = $rowVHost->{plainValueHash};
        push ( @vHosts, {
                         name => $values->{name},
                         enabled => $values->{enabled},
                        });
    }

    return \@vHosts;

}]]>
          </programlisting>
        </example>
      </para>

      <para>
        Moreover, eBox framework allows to expose the methods you
        require by overriding a
        <classname>EBox::Model::ModelProvider</classname> protected
        method called <methodname>_exposedMethods</methodname> which
        is intended to help to develop this tedious part. With a
        simple method definition, you can expose some
        methods. Currently, you can add, delete, query and edit a
        single row. It is still not possible to apply these actions to
        a multiple rows.
      </para>

      <para>
        We want to display four methods as the following list:
        <variablelist>
          <varlistentry>
            <term>addVHost(name, enabled)</term>
            <listitem><para>Add a new virtual host</para></listitem>
          </varlistentry>
          <varlistentry>
            <term>removeVHost(name)</term>
            <listitem><para>Remove an existing virtual host</para></listitem>
          </varlistentry>
          <varlistentry>
            <term>updateVHost(name, [name|enabled]</term>
            <listitem><para>Update an existing virtual host
            configuration</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>vHost(name)</term>
            <listitem><para>Get virtual host
            configuration</para></listitem>
          </varlistentry>
        </variablelist>
        There are used to simplify the virtual host management using
        name field as index. The definition for the above method
        signature is described in <xref
        linkend="exposed-methods-example"/>.
        <example id="exposed-methods-example">
          <title><methodname>_exposedMethods</methodname> method</title>
          <programlisting><![CDATA[
sub _exposedMethods
{
    my ($self) = @_;

    my %exposedMethods =
      (
       'addVHost'    => { action  => 'add',
                          path    => [ 'VHostTable' ],
                        },
       'removeVHost' => { action  => 'del',
                          path    => [ 'VHostTable' ],
                          indexes => [ 'name' ],
                        },
       'updateVHost' => { action  => 'set',
                          path    => [ 'VHostTable' ],
                          indexes => [ 'name' ],
                        },
       'vHost'       => { action  => 'get',
                          path    => [ 'VHostTable' ],
                          indexes => [ 'name' ],
                        },
       );

    return \%exposedMethods;
}]]>
          </programlisting>
        </example>
        It is quite self-describing. The exposed methods are stored
        in a named list acting the method name as key. As value it
        contains different parameters which are explained below:
        <variablelist>
          <varlistentry>
            <term>action</term>
            <listitem>
              <para>The action to be performed by the
              method. Currently, there are four possible actions to be
              affected only by one row: 'add', 'del', 'set' or 'get'.
              </para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>path</term>
            <listitem>
              <para>The path to access to the desired row. The first
              element of the array must be the model name. If the row
              is in a submodel realm, the way to get it is setting up
              the name of the field in the model which acts as a key
              to get the model. That is, the field name for the
              <classname>HasMany</classname> type within the selected
              model.
              </para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>indexes</term>
            <listitem>
              <para>The index field name to access to the model, it
              must be the same number of elements in indexes and path
              parameters. If there is no unique field which is a
              candidate key to set as an index, you must set
              <emphasis>id</emphasis> value to access the
              model by identifier or position in the model content.
              </para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>selector</term>
            <listitem>
              <para>This parameter is optional and only applicable to
              'set' and 'get' actions. Both cases are used to
              discriminate those fields which the action will be
              performed. If there are a single element, the framework
              allows to update its value without saying which field
              element you are modifying. In 'get' case, the returned
              value is not a row with a single type instance but the
              self type instance from the field element.
              </para>
            </listitem>
          </varlistentry>
        </variablelist>
        In order to clarify the usage of exposed methods, the <xref
        linkend="exposed-methods-calls-example"/> describes a simple
        usage of these methods within a simple perl script.
        <example id="exposed-methods-calls-example">
          <title><methodname>_exposedMethods</methodname> usage by a
          Perl script</title>
          <programlisting><![CDATA[
my $webMod = EBox::Global->modInstance('webserver');

# Adding devendra.banhart.com virtual host as valid one
$webMod->addVHost( name => 'devendra.banhart.com',
                   enabled => 1);

$webMod->isVHostEnabled( 'devendra.banhart.com'); # Returns true

$webMod->updateVHost( 'devendra.banhart.com', enabled => 0);
# Store the vhost configuration row (name, enabled)

my $vHostRow = $webMod->vHost( 'devendra.banhart.com' );
$vHostRow->{plainValueHash}->{enabled} # Return false
$vHostRow->{plainValueHash}->{name} # Return 'devendra.banhart.com'

# Deleting the virtual host
$webMod->removeVHost( 'devendra.banhart.com' );
]]>
          </programlisting>
        </example>
        As we see, the Web module API is pretty enhanced to support
        model management easily and human-readable way, making eBox
        framework powerful and completely scriptable.
      </para>
      
    </section>

    <section id='sect-short-way-conclusion'>
      <title>Conclusion</title>

      <para>
        As we have seen, eBox framework has been improved constantly
        and the developer burden is too much lower than previously to
        have an eBox module up and running. This makes eBox platform
        an easy customisable, extensive and stable platform to manage
        your own services and needs.
      </para>
    </section>
    
  </section>

</chapter>
