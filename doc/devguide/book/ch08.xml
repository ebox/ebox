<chapter id="ch-examplemod">

  <title>How to create a module</title>

  <section id="sect-long-way">

    <title>Long way to create a small module</title>

    <simplesect id="long-create-model-introduction">

      <para>Once you've seen the eBox internals, we are going to apply all
      the knowledge explained in the previous chapters creating a module
      from scratch. The first thing to do is choose a network service that
      you want to integrate into eBox. In our case we've chosen the Network
      Time Protocol server because it is one of the most simple that exist in
      eBox. Our module will provide eBox these features:</para>

      <itemizedlist>
        <listitem>
          <para>Date and time synchronization with an external server.</para>
        </listitem>

        <listitem>
          <para>Let clients synchronize their time and date with
          eBox.</para>
        </listitem>
      </itemizedlist>

      <para>And these are the steps we are going to follow in the development for
      the module:</para>

      <itemizedlist id="long-steps-creating-module-list">
        <listitem>
          <para>Study the NTP server and its features.</para>
        </listitem>

        <listitem>
          <para>Create a new module from the module template.</para>
        </listitem>

        <listitem>
          <para>Define and implement an API to manage its configuration.</para>
        </listitem>

        <listitem>
          <para>Develop CGIs and mason templates.</para>
        </listitem>

        <listitem>
          <para>Make our module show up in the eBox menu and in the summary
          page.</para>
        </listitem>

        <listitem>
          <para>Generate the configuration files and control the daemon
          execution.</para>
        </listitem>

        <listitem>
          <para>Establish custom rules in the firewall that let our module
          work.</para>
        </listitem>
      </itemizedlist>

    </simplesect>
    
    <section id='sect-example-define'>
      <title>Studying the NTP service and its features</title>

      <para>We've decided to develop this module using the ntp server from <ulink
      url='http://www.ntp.org'>www.ntp.org</ulink>. Debian includes packages for
      the server so we are going to use two of them:
      <emphasis>ntp-server</emphasis> to provide the time synchronization service
      to clients and <emphasis>ntpdate</emphasis> to make synchronization queries
      to external servers.</para>

      <para>After choosing the software we have to study how it works, its
      configuration files and the configurable parameters within them. With all
      this information we will be able to choose what degree of control the user
      of our module will have. We'll try to strike a balance between flexibility
      in the configuration and ease of use.</para>

      <para>For the module we are developing we only need to tune some of the
      parameters contained in the <filename>/etc/ntp.conf</filename> file,
      which holds the configuration for the ntp daemon. Of all the possible
      configuration options contained in that file, we are only interested in
      two:</para>

      <itemizedlist>
        <listitem>
          <para>The list of ntp servers we are going to use to synchronize our
          date and time. This can be achieved by adding lines like the following
          as many times as necessary to the configuration file:</para>

          <programlisting> <![CDATA[ server ntp_server_ip ]]>
          </programlisting>
        </listitem>

        <listitem>
          <para>The ability to act as an NTP server for clients in our network.
          This is done using the <varname>server</varname> attribute, as seen
          above, with an special IP address:</para>

          <programlisting> <![CDATA[ server 127.127.1.0 ]]> </programlisting>
        </listitem>
      </itemizedlist>

      <para>The NTP server has more configuration options, but we have
      decided to leave them with sane default values that are transparent to
      the user. We will concentrate on those features that will be generally
      most interesting to our users.</para>

      <para>We will also add the possibility for the user to manually change
      the system time and date and the time zone, in case there is no
      possibility to synchronize the time with external NTP servers.</para>

      <para>Time and date modification is easily done using the
      <command>/bin/date</command> command.</para>

      <para>Time zone configuration is easy too.
      <filename>/etc/localtime</filename> is a symbolic link that points
      to a file named after the location we are in. All possible timezones
      are stored under the <filename>/usr/share/zoneinfo/</filename>
      directory. Each location is stored inside its continent,
      so if our time zone is <emphasis>Madrid/Europe</emphasis>,
      then <filename>/etc/localtime</filename>must point to
      <filename>/usr/share/zoneinfo/Europe/Madrid</filename>. The
      operation of modifying the time zone is as simple as changing the
      <filename>/etc/localtime</filename> symlink.</para>

    </section>

    <section id='sect-example-module-bootstrap'>
      <title>Create a new module from the module template.</title>

      <para>As we have seen above, eBox modules have a complex directory
      structure that can be tedious to set up. Because of that, a module
      template is provided inside the tools directory in the base ebox
      module. This template provides a basic skeleton for an eBox module and
      can be cloned to create a new one. Note that you should replace the
      string modulename with your module name. </para>

      <para>eBox uses <command>autoconf</command> and
      <command>automake</command> for module configuration and
      installation. The files <filename>autogen.sh</filename>,
      <filename>configure.ac</filename> and <filename>Makefile.am</filename>
      contain the basic autotools configuration for a standard module and are
      also included in the template. The template also provides a
      <filename>m4/ebox.m4</filename> file, used by modules to detect the
      current eBox installation paths. </para>

      <para>The <ulink
      url="http://www.gnu.org/software/autoconf/manual/">Autoconf</ulink>
      and <ulink
      url="http://www.gnu.org/software/automake/manual/">Automake</ulink>
      manuals are the best autotools reference.</para>

    </section>

    <section id='sect-example-api'>
      <title>Defining and implementing the API</title>

      <para>At this point we should have gained a good degree of familiarity
      with the network service we are going to work with. We should also
      know what features will be exposed to our future users. In addition
      we have a template to use as a base for our module. The next step
      is to define the API for our module's backend. We must define which
      methods will be needed to let the rest of the modules read and write
      all the configuration options and to manage the daemon: start, stop,
      etc...</para>

      <para>The backend of our module is going to be in the
      <classname>EBox::NTP</classname> class. It will inherit from
      <classname>EBox::GConfModule</classname> and it will contain all the
      methods that conform the NTP API. This is its constructor:</para>

      <example id="constructor-example">
        <title><classname>EBox::NTP</classname> constructor</title>
        <programlisting><![CDATA[sub _create 
        {
        my $class = shift;
        my $self = $class->SUPER::_create(name => 'ntp', 
        domain => 'ebox-ntp',
        @_);
        bless($self, $class);
        return $self;
        }]]></programlisting>
      </example>

      <para>After the analysis performed in the previous
      section we can define the following methods in
      <classname>EBox::NTP</classname>(remember that we use a leading
      underscore for private method names):</para>

      <itemizedlist>
        <listitem>
          <para>setService</para>
        </listitem>
        <listitem>
          <para>service</para>
        </listitem>
        <listitem>
          <para>setSynchronized</para>
        </listitem>
        <listitem>
          <para>synchronized</para>
        </listitem>
        <listitem>
          <para>setServers</para>
        </listitem>
        <listitem>
          <para>servers</para>
        </listitem>
        <listitem>
          <para>setNewData</para>
        </listitem>
        <listitem>
          <para>setNewTimeZone</para>
        </listitem>
        <listitem>
          <para>_restartAllServices</para>
        </listitem>
      </itemizedlist>

      <variablelist>
        
        <varlistentry>
          <term><methodname>setService</methodname></term>
          <listitem>

            <para>This method gets a boolean argument that enables or disables the
            NTP service, which will allows clients in the local network
            synchronize their time and date with eBox.</para>

            <para>Here is its implementation:</para>
            
            <example id="enable-NTP-example">
              <title>Enabling the NTP server</title>
              <programlisting><![CDATA[sub setService 
              {
              my ($self, $active) = @_;
              if ($active xor $self->service) {
              $self->set_bool('active', $active);
              }
              } ]]> </programlisting>
            </example>

            <para>First we read the <parameter>active</parameter> argument
            and then we use the <methodname>service</methodname> method
            to find out if the server is currently enabled. Only if the
            new value is different than the old one we go on to set
            the <parameter>active</parameter> gconf key, by calling
            <methodname>set_bool</methodname>.</para>

          </listitem>
        </varlistentry>

        <varlistentry>
          <term><methodname>service</methodname></term>
          <listitem>

            <para>This method returns whether the NTP server is currently
            enabled or not. Its implementation is trivial, all we need is
            to fetch the <parameter>active</parameter> gconf key and return
            it:</para>

            <example id="state-example">
              <title>Reading the state of the NTP server</title>
              <programlisting><![CDATA[sub service 
              {
              my $self = shift;
              return $self->get_bool('active');
              } ]]> </programlisting>
            </example>

          </listitem>
        </varlistentry>

        <varlistentry>
          <term><methodname>setSynchronized</methodname></term>
          <listitem>

            <para>This method receives a boolean parameter that decides
            whether eBox will synchronize its date and time with external
            NTP servers. As you can see, its implementation is similar
            to <methodname>setService</methodname>, we just use the
            <parameter>synchronized</parameter> gconf key instead:</para>

            <example id="enable-NTP-sync-example">
              <title>Enabling the external NTP synchronization</title>
              <programlisting><![CDATA[sub setSynchronized # (synchronized)
              {
              my ($self, $synchronized) = @_;

              if ($synchronized xor $self->synchronized) {
              $self->set_bool('synchronized', $synchronized);
              }
              } ]]> </programlisting>
            </example>

          </listitem>
        </varlistentry>

        <varlistentry>
          <term><methodname>synchronized</methodname></term>
          <listitem>

            <para>This method returns the value of the
            <parameter>synchronized</parameter> gconf key.
            Its implementation is quite simple and similar to
            <methodname>service</methodname>.</para>

            <example id="external-sync-example">
              <title>Fetching the configuration for external
              synchronization</title>

              <programlisting><![CDATA[sub synchronized 
              { 
              my $self = shift;
              return $self->getbool('synchronized');
              } ]]> </programlisting>
            </example>

          </listitem>
        </varlistentry>

        <varlistentry>
          <term><methodname>setServers</methodname></term>
          <listitem>

            <para>This allows us to store the names of the ntp servers we
            will use to synchronize our time and date in the gconf database.
            Its implementation checks whether an IP address or a domain name
            were introduced and checks the syntax of the value accordingly.
            If the syntax is correct the servers will be stored in the
            gconf database calling the <methodname>set_string</methodname>
            method. In addition to that, we won't let the user set a
            secondary server if no primary server has been set, and the
            same for the third server. Let's see part <footnote><para>The
            complete implementation can be found in the subversion
            repository</para></footnote>of its implementation:</para>

            <example id="setting-external-NTP-example">
              <title>Setting the external NTP servers</title>
              <programlisting><![CDATA[sub setServers # (server1, server2, server3) 
              {
              my ($self, $s1, $s2, $s3) = @_;

              if ($s1 =~ /^(\d{1,3}\.){3}\d{1,3}$/) {
              checkIP($s1, __("primary server IP address"));
              $self->set_string('server1', $s1);
              } else {
              checkDomainName($s1, __("primary server name "));
              $self->set_string('server1', $s1);
              }

              if (defined($s2) and ($s2 ne "")) {
              if ($s2 =~ /^(\d{1,3}\.){3}\d{1,3}$/) {
              checkIP($s2, __("secondary server IP address"));
              $self->set_string('server2', $s2);
              } else {

              ...
              ]]> </programlisting>
            </example>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><methodname>servers</methodname></term>
          <listitem>

            <para>It returns an array that contains the NTP external
            servers stored in gconf:</para>

            <example id="getting-external-NTP-example">
              <title>Getting the list of external NTP servers</title>
              <programlisting><![CDATA[sub servers 
              {
              my $self = shift;
              my @servers;
              @servers = ($self->get_string('server1'),
              $self->get_string('server2'),
              $self->get_string('server3'));

              return @servers;
              } ]]> </programlisting>
            </example>
          </listitem>
        </varlistentry>
        
        <varlistentry>
          <term><methodname>setNewDate</methodname></term>
          <listitem>

            <para>This method changes the system's date and time. This is its
            implementation:</para>
            
            <example id="setting-time-date-example">
              <title>Setting a new system time and date</title>
              <programlisting><![CDATA[sub setNewDate # (day, month, year, hour, minute, second)
              {
              my ($self, $day, $month, $year, $hour, $min, $sec) = @_;

              my $newdate = "$year-$month-$day $hour:$min:$sec";
              my $command = "/bin/date --set \"$newdate\"";
              root($command);

              $self->_restartAllServices;
              } ]]> </programlisting>
            </example>

            <para>We receive as arguments every piece of data necessary to set the
            time and date in the system: day, month, year, hour, minutes and
            seconds.</para>

            <para>We build the complete command in the
            <varname>command</varname> variable and a call is made to the
            <function>root</function> function that executes it. This
            command must be run as root using <command>sudo</command>, that's
            why we don't run it directly.</para>

            <para>When the system time changes, some system services and eBox
            modules need to be restarted. This is implemented in the
            <methodname>_restartAllServices</methodname> method seen in <xref
            linkend='ex-ntp-restart-all'/>.</para>
          </listitem> 
        </varlistentry>

        <varlistentry>
          <term><methodname>setNewTimeZone</methodname></term>
          <listitem>
            
            <para>Along with the time and date, the time zone may be changed too.
            For this purpose we implemented this method:</para>

            <example id="setting-timezone-example">
              <title>Setting a new time zone</title>
              <programlisting><![CDATA[sub setNewTimeZone # (continent, country)
              {
              my ($self, $continent, $country) = @_;

              my $command = "ln -s /usr/share/zoneinfo/$continent/$country" .
              " /etc/localtime";
              $self->set_string('continent', $continent);
              $self->set_string('country', $country);
              root("rm /etc/localtime");
              root($command);
              $self->_restartAllServices;
              } ]]></programlisting>
            </example>

            <para>It gets two arguments: <parameter>continent</parameter>
            and <parameter>country</parameter>. We use them to redo
            the symbolic link in <filename>/etc/localtime</filename>
            so that it points to the new time zone. For example,
            if the two arguments are <literal>Africa</literal> and
            <literal>Africa</literal>, <filename>/etc/localtime</filename>
            will be changed so that it points to
            <filename>/usr/share/zoneinfo/Africa/Dakar</filename>.</para>

            <para>We store both arguments in gconf too, making to calls to
            <methodname>set_string</methodname>. When the time zone has
            been changed some eBox modules and the system log services are
            restarted so that they don't run with the wrong time.</para>

          </listitem>
        </varlistentry>

        <varlistentry>
          <term><methodname>_restartAllServices</methodname></term>
          <listitem>

            <para>Operations that change the system's time and date may leave some
            parts of the system in an inconsistent state. To avoid having eBox
            modules and system log services with a time shift we'll write a
            method that will restart all those services so that they get the new
            time and date. Here it goes:</para>

            <example id='ex-ntp-restart-all'>
              <title>Restarting eBox modules and system services</title>
              <programlisting> <![CDATA[sub _restartAllServices
              {
              my $self = shift;
              my $global = EBox::Global->getInstance();
              my @names = grep(!/^network$/, @{$global->modNames});
              @names = grep(!/^firewall$/, @names);
              my $log = $global->logger;
              my $failed = "";
              $log->info("Restarting all modules");
              
              foreach my $name (@names) {
              my $mod = $global->modInstance($name);
              try {
              $mod->restartService();
              } catch EBox::Exceptions::Internal with {
              $failed .= "$name ";
              };
              }
              
              if ($failed ne "") {
              throw EBox::Exceptions::Internal("The following modules ".
              "failed while being restarted, their state is ".
              "unknown: $failed");
              }

              $log->info("Restarting system logs");
              try {
              root("/etc/init.d/sysklogd restart");
              root("/etc/init.d/klogd restart");
              root("/etc/init.d/cron restart");
              } catch EBox::Exceptions::Internal with {
              };
              } ]]> </programlisting>
            </example>

            <para>First we get an <classname>EBox::Global</classname>
            instance that will build instances of every eBox module.
            We restart all modules except <emphasis>network</emphasis>
            and <emphasis>firewall</emphasis>, catching any exception
            that may be thrown while restarting them. Then we manually
            restart the system daemons: <emphasis>sysklogd</emphasis>,
            <emphasis>klogd</emphasis> and <emphasis>crond</emphasis>.
            Doing this requires root privileges so we invoke the
            <function>root</function> function.</para>

          </listitem>
        </varlistentry>
      </variablelist>

    </section>

    <section id='sect-example-cgis'>
      <title>Creating CGIs and templates</title>

      <para>After designing and implementing the API, it is time to create
      the layer that will interact with it: CGIs and mason templates. As
      you saw in <xref linkend='sect-example-define'/>, this module is
      going to answer NTP queries for clients in the local network. The
      API that enables and disables this service was implemented in <xref
      linkend='sect-example-api'/>. We will now create two CGIs and a mason
      template that will use these methods to give the user an interface for
      this feature:</para>

      <para>The two CGIs are <classname>EBox::CGI::NTP::Index</classname> and
      <classname>EBox::CGI::NTP::Enable</classname>, the template is called
      <filename>ntp/index.mas</filename>.</para>

      <para>Our first CGI is <classname>EBox::CGI::NTP::Index</classname>.
      It inherits from <classname>EBox::CGI::ClientBase</classname> and
      implements a constructor that sets the title for our page and the name
      of the template associated to this CGI. This is the constructor:</para>

      <example id="cgi-constructor-example"> 
        <title>Constructor for <classname>EBox::CGI::NTP::Index</classname>
        </title>
        <programlisting><![CDATA[package EBox::CGI::NTP::Index;

        use strict;
        use warnings;

        use base 'EBox::CGI::ClientBase';

        use EBox::Global;
        use EBox::Gettext;

        sub new {
        my $class = shift;
        my $self = $class->SUPER::new('title'    => NTP,
        'template' => 'ntp/index.mas', @_);

        $self->{domain} = "ebox-ntp";
        bless($self, $class);
        return $self;
        } ]]> </programlisting>
      </example>

      <para>A noteworthy detail is the fact that the title string in this
      CGI is not translatable, and thus we haven't followed the instructions
      in <xref linkend='sect-i18n-developers'/> for i18n. If the title was
      translatable we would have followed those instructions.</para>

      <para>We are now ready to implement the
      <methodname>_process</methodname> method, which reads the current
      configuration for the NTP server and feeds it to the mason
      template.</para>

      <example id="mason-template-example">
        <title>Feeding the configuration of the NTP server to the mason
        template</title>

        <programlisting><![CDATA[sub _process
        {
        my $self = shift;
        my $ntp = EBox::Global->modInstance('ntp');

        my @array = ();
        my $active = 'no';

        if ($ntp->service()) {
        $active = 'yes';
        }

        push (@array, 'active'     => $active);
        $self->{params} = \@array;
        }]]></programlisting>
      </example>

      <para>You can see that the first thing we do is create an instance of
      our module (ntp) using <classname>EBox::Global</classname>. We use this
      instance to invoke the <methodname>service</methodname> method, which
      returns the configuration of the server and we pass it to the mason
      template placing it in the <structfield>param</structfield> attribute
      of the CGI. If the mason template needed more arguments we would just add
      them to the <varname>array</varname> variable.</para>

      <para>This CGI we just implemented, along with its mason template,
      shows the current configuration for the NTP server. We will now
      implement the CGI that will receive a new configuration from the user
      and will tell the backend to change it.</para>

      <example id="cgi-enable-ntp-example">
        <title>CGI to enable and disable the NTP server</title>
        <programlisting><![CDATA[package EBox::CGI::NTP::Enable;

use strict;
use warnings;

use base 'EBox::CGI::ClientBase';

use EBox::Global;
use EBox::Gettext;

sub new 
{
    my $class = shift;
    my $self = $class->SUPER::new('title' => 'NTP', @_);
    $self->{redirect} = "NTP/Index";
    $self->{domain} = "ebox-ntp";
    bless($self, $class);

    return $self;
}

sub _process
{
    my $self = shift;
    my $ntp= EBox::Global->modInstance('ntp');

    $self->_requireParam('active', __('module status'));
    $ntp->setService(($self->param('active') eq 'yes'));
}

1; ]]> </programlisting>
      </example>

      <para>Its implementation is quite simple, only a couple of details are
      noteworthy.</para>

      <para>First, the constructor sets the
      <structfield>redirect</structfield> attribute to
      <literal>NTP/Index</literal>. This will make the browser invoke that
      CGI after setting the configuration so that the value shown to the user
      is refreshed.</para>

      <para>Finally, we use the <methodname>setService</methodname> method,
      and we pass it a boolean argument that results from the reading of the
      <parameter>active</parameter> parameter from the HTTP request. HTTP
      parameters are fetched by invoking the <methodname>param</methodname>
      method from the parent class.</para>

      <para>Next we are going to create the mason template that will
      display the configuration and the form to change it. This is an
      special case, since most eBox modules will need to enable/disable
      network services. A common way of doing this is provided by the
      <filename>enable.mas</filename> mason template, which is part of the
      basic framework.</para>

      <para>It is very easy to use it. We create a template that receives an
      argument with the current configuration of the server. As explained
      in <xref linkend='sect-mason'/> we can include an external template
      by writing: 
      <programlisting><![CDATA[<& template.mas, @arguments &>]]></programlisting>.
      We are going to include <filename>enable.mas</filename> and we give it two
      arguments, the title and the current configuration of the NTP server. It
      looks like this:</para>

      <example id="mason-template-NTP-example"> 
        <title>Mason template for enabling the NTP server</title> 
        <programlisting><![CDATA[<%args> $active </%args>
        <%init> use EBox::Gettext; </%init>

        <div class='ntpnew'>
        <br />
        <& enable.mas, title => __('Enable the local NTP server'),
        active => $active &>
        </div>
        ]]></programlisting>
      </example>

      <para>Using <filename>enable.mas</filename> requires that
      the CGI that enables or disables the service be called
      <classname>Enable</classname>, since that is hard-coded into
      <filename>enable.mas</filename>. If you take another look at the CGI
      we implemented for this purpose, you'll see that its classname is
      <classname>EBox::CGI::NTP::Enable</classname>, just as required.</para>

      <para>We are now missing the CGIs that change the time zone, the time
      and date, and set the external NTP servers. These CGIs and templates
      are quite simple, it you want to see their source code you can check
      the subversion repository, their code will not be shown here, we'll
      limit ourselves to a quick overview of the files involved and their
      relationships.</para>

      <para>Two CGIs handle the time zone changing feature:</para>

      <itemizedlist>
        <listitem>
          <para><classname>Timezone</classname> uses a mason template
          (<filename>timezone.mas</filename>) to display the current timezone
          configuration.</para>
        </listitem>
        <listitem>

          <para><classname>ChangeTimeZone</classname> receives
          the new timezone from the web browser and invokes the
          <methodname>SetNewTimeZone</methodname>.</para>
        </listitem>
      </itemizedlist>

      <para>There is one more detail about the
      <classname>TimeZone</classname> CGI. It sends the current country and
      continent to the mason template, but it also sends a list with all
      possible continents and a hash that links each continents with the
      list of countries it contains. All this information is read from the
      <filename>/usr/share/zoneinfo/zone.tab</filename> file.</para>

      <para>Finally, our module provides two ways to establish the system's
      time and date: manually and synchronizing with external NTP servers.
      Each of these two methods excludes the other one (the user can only
      use one of the two methods). The <classname>Datetime</classname> CGI
      displays the information about the current time and date and the
      configuration of the external NTP servers stored in gconf. Two CGIs let
      the user change the settings shown in <classname>Datetime</classname>:
      <classname>Synch</classname> enables the synchronization against
      external NTP servers and <classname>ChangeDate</classname> changes the
      time and date manually.</para>

      <para>We just said that only one of the two methods may be used at
      the same time. This is enforced by the mason templates, and we are
      going to see how it's done. The <filename>datetime.mas</filename>
      template gets its arguments from the <classname>Datetime</classname>
      CGI, it includes the template <filename>synch.mas</filename>
      which lets the user choose whether he wants to set the time
      manually or use external NTP servers. Then, depending on the
      current configuration it loads the NTP server selection template
      (<filename>servers.mas</filename>) or the manual time and date
      configuration template (<filename>date.mas</filename>).</para>

      <example id="datetime-tmpl-example">
        <title><filename>datetime.mas</filename> template</title>
        <programlisting><![CDATA[<& /ntp/synch.mas, title => __('Synchronize with external NTP servers'),
        synchronized => $synchronized &>

        % if ($synchronized eq 'yes') {
        <& /ntp/servers.mas, title => __('External NTP servers'), servers => \@servers
        &>
        % }

        % if ($synchronized eq 'no') {
        <& /ntp/date.mas, title => __('Change Date and Time'), date => \@date &>
        % }]]></programlisting>
      </example>

      <para><filename>synch.mas</filename>, <filename>server.mas</filename>
      and <filename>date.mas</filename> just display the information that
      <filename>datetime.mas</filename> sends them as arguments.</para>
    </section>

    <section id='sect-example-menu'>
      <title>Showing the menu and the Summary page</title>

      <para>We are already in the final steps in the development of our
      module. Now we are going to add a new section to the eBox menu that
      will let the user access the user interface of our module and a section
      to the summary page with information about the ntp module.</para>

      <para>Adding a new section to the menu is as simple as
      implementing the <methodname>menu</methodname> method in our
      <classname>EBox::NTP</classname> class. This method gets an instance
      of <classname>EBox::Menu::Root</classname> to which we will add
      a new NTP section with several items: <quote>NTP Server</quote>,
      <quote>Date/Time</quote> and <quote>Time zone</quote>. Here is the
      <methodname>menu</methodname> method:</para>

      <example id="entries-menu-example">
        <title>Adding entries to the eBox menu</title>
        <programlisting><![CDATA[sub menu
        {
        my ($self, $root) = @_;
        my $folder = new EBox::Menu::Folder('name' => 'NTP',
        'text' => __('NTP'));

        $folder->add(new EBox::Menu::Item('url' => 'NTP/Index',
        'text' => __('NTP server')));
        $folder->add(new EBox::Menu::Item('url' => 'NTP/Datetime',
        'text' => __('Date/time')));
        $folder->add(new EBox::Menu::Item('url' => 'NTP/Timezone',
        'text' => __('Time zone')));
        $root->add($folder);
        }]]></programlisting>
      </example>

      <para>As you saw in <xref linkend='sect-menu'/>, a new section is
      created with an instance of <classname>EBox::Menu::Folder</classname>,
      which needs to be given a name.</para>

      <para>The we add to it instances of
      <classname>EBox::Menu::Item</classname> which needs a name and a URL
      (as we explained in <xref linkend='sect-cgi'/>, we only need to specify
      <quote>NTP/Index</quote>, not the whole path).</para>

      <para>The NTP module is not going to have its own section in the
      summary page as there is not much information to display. We'll just
      add an entry in the status table at top of that page. For that we are going
      to implement the <methodname>statusSummary</methodname> method in
      <classname>EBox::NTP</classname>:</para>

      <example id="ntp-summary-example">
        <title><methodname>statusSummary</methodname> in 
        <classname>EBox::NTP</classname></title>

        <programlisting><![CDATA[sub statusSummary
        {
        my $self = shift;
        return new EBox::Summary::Status('ntp', __('NTP local server'),
        $self->isRunning, $self->service);
        }]]></programlisting>
      </example>

    </section>

    <section id='sect-example-daemon'>
      <title>Generating config files and managing the NTP server</title>

      <para>Let's see how you can use mason templates to generate the config
      file for the NTP server. In <xref linkend='sect-example-define'/>
      we saw that the NTP server reads all its configuration from the
      <filename>/etc/ntp.conf</filename> file. We'll use the same system we
      use to generate HTML for this file.</para>

      <para>This part of the module belongs in the backend, so
      all the methods needed to implemented will be placed in
      <classname>EBox::NTP</classname>.</para>

      <para>We have created a private method called
      <methodname>_setNTPConf</methodname> which will be invoked every time
      we need to generate the config file. Here it is:</para>

      <example id="generating-NTP-conf-example">
        <title> Generating the <filename>/etc/ntp.conf</filename> config
        file</title>

        <programlisting><![CDATA[sub _setNTPConf
        {
        my $self = shift;
        my @array = ();
        my @servers = $self->servers;
        my $synch = 'no';
        my $active = 'no';

        ($self->synchronized) and $synch = 'yes';
        ($self->service) and $active = 'yes';

        push(@array, 'active'   => $active);
        push(@array, 'synchronized'  => $synch);
        push(@array, 'servers'  => \@servers);

        $self->writeConfFile(NTPCONFFILE, "ntp/ntp.conf.mas", \@array);
        }]]></programlisting>
      </example>

      <para>It is very simple, we just add all the arguments for the mason
      template to the <varname>array</varname> variable. Our arguments
      are:</para>

      <variablelist>
        <varlistentry>
          <term><parameter>active</parameter></term>
          <listitem>
            <para>It tells the template whether we are going to offer the NTP
            service for clients in our network or not.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><parameter>synchronized</parameter></term>
          <listitem>
            <para>It tells the template whether we are going to synchronize our
            system's time with external NTP servers.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><parameter>servers</parameter></term>
          <listitem>
            <para>It's an array with the list of external NTP servers.</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <para>After building the array with the arguments we call
      <methodname>writeConfFile</methodname>, which generates the configuration
      file with proper permissions and needs these arguments:</para>
      
      <itemizedlist>
        <listitem>
          <para>The absolute path to the configuration file. In our case it is the
          <constant>NTPCONFFILE</constant> constant, which is defined in the
          beginning of our module: </para>
          <programlisting><![CDATA[use constant NTPCONFFILE => "/etc/ntp.conf";]]></programlisting>
        </listitem>

        <listitem>
          <para>The path to the mason template that generates the file.</para>
        </listitem>

        <listitem>
          <para>An array with the arguments for the template.</para>
        </listitem>
      </itemizedlist>

      <para>And now let's see the template. We decided to leave some of the
      values in the config file with fixed values, other values are dynamic and
      are generated based on the arguments received:</para>

      <example id="gen-tmpl-NTP-example">
        <title>Template to generate
        <filename>/etc/ntp.conf</filename></title>
        <programlisting><![CDATA[<%args>
        $active
        $synchronized
        @servers
        </%args>
        # /etc/ntp.conf, configuration for ntpd
        # Generated by EBox

        driftfile /var/lib/ntp/ntp.drift
        statsdir /var/log/ntpstats/

        % if ($synchronized eq 'yes') {
        %       if ($servers[0]) {
        server <% $servers[0] %>
        %       }
        %       if ($servers[1]) {
        server <% $servers[1] %>
        %       }
        %       if ($servers[2]) {
        server <% $servers[2] %>
        %       }
        % }
        % if ($active eq 'yes') {
        server 127.127.1.0
        % }
        fudge 127.127.1.0 stratum 13

        restrict default kod notrap nomodify nopeer noquery

        restrict 127.0.0.1 nomodify]]></programlisting>
      </example>

      <para>The only thing left is the code to manage the ntp
      daemon. We have to implement several methods, the first is an
      abstract method defined in <classname>EBox::Module</classname>:
      <methodname>_regenConfig</methodname>. It is invoked when services
      are restarted or when a new configuration for a module is saved.
      It has to generate the config file, using the already seen
      <methodname>_setNTPConf</methodname> method. Let's see it:</para>

      <example id="regenConfig-example">
        <title><methodname>_regenConfig</methodname> method</title>
        <programlisting><![CDATA[sub _regenConfig
        {
        my $self = shift;

        $self->_setNTPConf;
        $self->_doDaemon();
        }]]></programlisting>
      </example>

      <para>Besides invoking <methodname>_setNTPConf</methodname>,
      it needs to restart the daemon, it does so by calling
      a private method: <methodname>_doDaemon</methodname>.
      Together with methods <methodname>_stopService</methodname>, and
      <methodname>isRunning</methodname>, <methodname>_doDaemon</methodname>
      performs the management of the daemon. Let's see them one by
      one:</para>

      <example id="ntp-daemon-example">
        <title>NTP daemon management method</title>
        <programlisting><![CDATA[sub _doDaemon
        {
           my $self = shift;
           my $logger = EBox::Global->logger;

           if (($self->service or $self->synchronized) and $self->isRunning) {
                 EBox::Service::manage('ntpd','stop');
                 sleep 2;
                 if ($self->synchronized) {
                     my $exserver = $self->get_string('server1');
                     try {
                         root("/usr/sbin/ntpdate $exserver");
                     } catch EBox::Exceptions::Internal with {
                         $logger->info("Error, ntpdate could" .
                                       " not be started.");
                     };
                 }
                 EBox::Service::manage('ntpd','start');
            } elsif ($self->service or $self->synchronized) {
                 if ($self->synchronized) {
                    my $exserver = $self->get_string('server1');
                    try {
                       root("/usr/sbin/ntpdate $exserver");
                    } catch EBox::Exceptions::Internal with {
                       $logger->info("Error ntpdate could" .
                                     " not be started.");
                    };
                 }
                 EBox::Service::manage('ntpd','start');
            } elsif ($self->isRunning) {
                 EBox::Service::manage('ntpd','stop');
                 if ($self->synchronized) { 
                     EBox::Service::manage('ntpd','start');
                 }
           }
        }]]></programlisting>
      </example>

      <para>This method is invoked:</para>
      
      <itemizedlist>
        <listitem>
          <para>To launch the server if it was stopped.</para>
        </listitem>
        <listitem>
          <para>To restart the server when it is running.</para>
        </listitem>
        <listitem>
          <para>To stop the server.</para>
        </listitem>
      </itemizedlist>

      <para>Depending on which case we are in it calls
      <methodname>EBox::Service::manage</methodname> telling it which action we want to
      perform: start or stop. If the system date is to be synchronized
      with external servers we should try to make a manual query with the
      <command>/usr/sbin/ntpdate</command> before starting the daemon. This
      is a recommended practice before launching the ntp daemon.</para>

      <para>Let's see how <methodname>EBox::Service::manage</methodname> works,
      it starts, stops or restarts a service directly depending on its
      argument. It uses <ulink url="http://smarden.org/runit/">
      <application>runit</application></ulink> application to manage automatically
      daemon by its supervision. This allows us to check the daemon status,
      for how long and restart the service everytime is goes down.</para>

      <para>
        In order to configure a runit service, it is required to edit a shell script
        with the service name, in our case <parameter>ntpd</parameter>, indicating
        how the service is run in foreground mode. This file must place in
        <filename>tools/runit/</filename> directory.
      </para>

      <example id="ntpd-runit-example">
        <title><filename>tools/runit/ntpd</filename> file</title>
        <programlisting><![CDATA[
#!/bin/sh
exec 2>&1
exec /usr/sbin/ntpd -n -g]]>

        </programlisting>
      </example>

      <para>There only two methods left for you to see.
      <methodname>_stopService</methodname> is defined as an abstract method by
      <classname>EBox::Module</classname>, it just stops the service.
      <methodname>isRunning</methodname> tells us whether the ntp daemon is
      currently running, it does so by checking its process id (PID).</para>

      <example id="stopservice-example">
        <title><methodname>_stopService</methodname> method.</title>
        <programlisting><![CDATA[sub _stopService
        {
        my $self = shift;

        if ($self->isRunning) {
        $self->_daemon('stop');
        }
        }
        ]]> </programlisting>
      </example>

      <example id="ntp-running-example">
        <title>Telling whether the NTP daemon is running or not.</title>
        <programlisting><![CDATA[sub isRunning
        {
        my $self = shift;
        return $self->pidFileRunning(PIDFILE);
        }
        ]]> </programlisting>
      </example>
    </section>

    <section id='sect-example-firewall'>
      <title>Setting up proper firewall rules</title>

      <para>The last step in creating this module is to let the firewall know
      about our needs, so that the ntp service works fine. If our date is set
      by querying external servers we will need to make UDP connections on
      port 123 to them. We also need to let clients connect to our 123 UDP
      port if we are going to be an NTP server. We created a private method
      called <methodname>_configureFirewall</methodname> that takes care of
      all this stuff. Here it is:</para>

      <example id="firewall-conf">
        <title>Firewall configuration</title>
        <programlisting><![CDATA[sub _configureFirewall
        {
        my $self = shift;
        my $fw = EBox::Global->modInstance('firewall');

        if ($self->synchronized) {
        $fw->addOutputRule('udp', 123);
        } else {
        $fw->removeOutputRule('udp', 123);
        }

        if ($self->service and (!defined($fw->service('ntp')))) {
        $fw->addService('ntp', 'udp', 123, 0);
        $fw->setObjectService('_global', 'ntp', 'allow');
        } elsif ( !($self->service) and defined($fw->service('ntp')) ) {
        $fw->removeService('ntp');
        }
        }]]></programlisting>
      </example>

      <para>The eBox firewall module simplifies this job providing
      methods that let us add new rules to the firewall. First of all
      we need an instance of the firewall module, as usual we use
      <classname>EBox::Global</classname> to get it. Then we add the
      output rule if we need to connect to external servers or remove
      it if we do not need to and it had been previously added. The
      methods for this are <methodname>addOutputRule</methodname> and
      <methodname>removeOutputRule</methodname>.</para>

      <para>For our NTP server, we need to register our service with
      the firewall by calling <methodname>addService</methodname>
      and then we'll allow it by default by calling
      <methodname>setObjectService</methodname>. If the NTP server feature is
      disabled we remove the ntp service from the firewall by calling
      <methodname>removeService</methodname>.</para>

    </section>
    
    <section id='sect-example-conclusion'>
      <title>Conclusion</title>

      <para>We are done, we just created an eBox module form scratch. We've
      gone through every step needed and seen what issues to watch out for.
      Now it is time to try it out and do some tests to check that it works
      as we expect. We hope this guide has been helpful and encourages you
      to contribute to making it a better platform with new modules and
      features.</para>
    </section>

  </section>

  <section id="sect-short-way">
    
    <title>Short way to create a small module</title>

    <para>
      Previously in <xref linkend="sect-long-way"/>, a long way to create an 
      eBox module has been explained, however in this section we are going to
      use the MVC framework described in <xref linkend="sect-a-mvc-module"/>.
      This will reduce our development time, less error-prone and greater quality
      since less code is required to be written and this code will handle the
      compulsory logic avoiding to do repetitive tasks such as CGI or template
      creation as well as manage database backend directly letting developer
      focuses on what really cares to add the new service to eBox.
    </para>

    <para>
      As it was done in <xref linkend="long-create-model-introduction"/>, we have
      chosen a service, in this case, the HyperText Transfer Protocol server.
      We have selected the <ulink url="http://httpd.apache.org">Apache HTTP server version 2</ulink>
      to provide a simple glance of how powerful is the MVC framework to develop
      eBox agility and correctly. The Apache eBox module will provide these features:
    </para>
    
    <itemizedlist>
      <listitem>
        <para>Enable and disable the service as other eBox modules</para>
      </listitem>
      <listitem>
        <para>Some general configuration settings as port number to listen
        HTTP request or enable HTML provided by users home at <filename>public_html</filename>
        directory.</para>
      </listitem>
      <listitem>
        <para>Virtual host creation and configuration giving automatic 
        name resolution management using our DNS module.</para>
      </listitem>
    </itemizedlist>

    <para>
      These steps are going to follow to develop this module:
    </para>

    <itemizedlist>
      <listitem>
        <para>Define the data model to manage the requested features</para>
      </listitem>
      
      <listitem>
        <para>Define the graphical user interface using Composites</para>
      </listitem>

      <listitem>
        <para>Create the new module from a template publishing the data 
        model and composites</para>
      </listitem>


      <listitem>
        <para>Common tasks done in the <link linkend="sect-long-way">long way Section</link>
        such as generate configuration files, control daemon execution, firewall rules and
        set menu and status summary.
        </para>
      </listitem>

      <listitem>
        <para>Expose the desired API to other eBox's modules or to the SOAP interface</para>
      </listitem>
    </itemizedlist>

    <section id="define-data-model-sect">

      <title>Define data model</title>
      <para>
        In order to do the enable/disable web service, we can use the common form model which
        shows, store a boolean value to enable/disable service called
        <classname>EBox::Common::Model::EnableForm</classname>, we delayed this feature till
        <xref linkend="publish-model-composite-sect"/>.
      </para>

      <para>
        The general apache configuration is a form which contains the port number which is a simple
        Int type and a Boolean type to enable users publish their own HTML pages under
        <filename>public_html</filename> directory from their home. The description is displayed
        in <xref linkend="general-conf-example"/> inside the
        <classname>EBox::WebServer::Model::GeneralConfigurationForm</classname> class.

        <example id="general-conf-example">
          <title>General Configuration description</title>
          <programlisting><![CDATA[
sub _table
  {

      my @tableHeader =
        (
         new EBox::Types::Int(
                              fieldName     => 'port',
                              printableName => __('Listening port'),
                              size          => 6,
                              editable      => 1,
                              defaultValue  => 80,
                             ),
         new EBox::Types::Boolean(
                                  fieldName     => 'enableDir',
                                  printableName => __x('Enable user publishing from their ',
                                                       'home directories using {dirName}',
                                                       dirName => 'public_html'),
                                  editable      => 1,
                                 ),
                             );

      my $dataTable =
        {
         tableName          => 'GeneralConfigurationForm',
         printableTableName => __('General Configuration'),
         defaultActions     => [ 'editField', 'changeView' ],
         tableDescription   => \@tableHeader,
         class              => 'dataForm',
         help               => __('General Web server configuration. The listening port ' .
                                  'must not be got from another service. If you enable ' .
                                  'user to publish their own html pages, the pages will be ' .
                                  'loaded from public_html directory from their samba home directories'),
         messages           => {
                                update => __('General Web server configuration updated'),
                               }
        };

      return $dataTable;

  }]]>
          </programlisting>
        </example>

        As the user input can be incorrect if the port number is not correct or is already in use
        by any other eBox module, the check is compulsory and it is done as
        <xref linkend="validate-example"/> shows.

        <example id="validate-example">
          <title>Validate input data</title>
          <programlisting><![CDATA[
sub validateTypedRow
  {

      my ($self, $action, $params) = @_;

      my $portNumber = $params->{port}->value();

      EBox::Validate::checkPort($portNumber,
                                __('Invalid port number'));

      my $gl = EBox::Global->getInstance();
      my $firewall = $gl->modInstance('firewall');

      unless ( $firewall->availablePort('tcp', $portNumber) ) {
          throw EBox::Exceptions::DataExists(
                                             'data'  => __('listening port'),
                                             'value' => $portNumber,
                                             );
      }

  }]]>
          </programlisting>
        </example>
      </para>

      <para>
        Once the general configuration is done, we are going to generate a list 
        of virtual hosts to live inside our web server. As the module is done as 
        a proof concept only a name will be provided to generate a virtual host.
        The document root is fixed and it is related to the virtual host's name
        and it is enabled by default. As it can exist as many as we wish, a data
        model in a table is the best solution to address here. Its description is
        shown in <xref linkend="vhost-description-example"/> inside the
        <classname>EBox::WebService::Model::VHostTable</classname> class.
        <example id="vhost-description-example">
          <title>Virtual host data model description</title>
          <programlisting><![CDATA[
sub _table
{
    my @tableHead =
        (
         new EBox::Types::Text(
                                fieldName     => 'name',
                                printableName => __('Name'),
                                size          => 12,
                                unique        => 1,
                                editable      => 1,
                             ),
         new EBox::Types::Boolean(
                                  fieldName     => 'enabled',
                                  printableName => __('Enabled'),
                                  editable      => 1,
                                  # The virtual host is enabled by default
                                  defaultValue  => 1,
                                 ),
        );

    my $dataTable =
      {
       tableName          => 'VHostTable',
       printableTableName => __('Virtual hosts'),
       defaultActions     => ['add', 'del', 'editField',  'changeView' ],
       tableDescription   => \@tableHead,
       class              => 'dataTable',
       help               => __('Virtual hosts are a form of web hosting service where ' .
                                'many instances of the same web server is hosted on a ' .
                                'single physical server. Different host names will point ' .
                                'to the same web server. The DNS entry is automatically created'),
       printableRowName   => __('virtual host'),
       modelDomain        => 'Web',
      };

    return $dataTable;
}]]>
            
          </programlisting>
        </example>
        As we want to order the virtual host by name, we override the 
        <methodname>_tailoredOrder</methodname> protected method to achieve so.
        <programlisting><![CDATA[
sub _tailoredOrder # (rows)
{

    my ($self, $rows_ref) = @_;

    # Order rules per priority
    my @orderedRows = sort { $a->{valueHash}->{name}->value()
        cmp $b->{valueHash}->{name}->value() }
      @{$rows_ref};

    return \@orderedRows;

}]]>
        </programlisting>

      </para>

    </section>
        
    <section id="define-composite-sect">

      <title>Define module web GUI using Composites</title>
      <para>
        We want to show our previous defined models in a top bottom layout in this order:
        first the enable/disable button for the web service, then the general configuration
        settings and, finally, the virtual host table. We assume the number of virtual hosts
        for internal use will be small and it will match with the window height to see the
        web service configuration at one glance in the same page. To achieve so, we define a
        composite called <classname>EBox::WebService::Model::GeneralComposite</classname>
        which comprises the three elements in a top-bottom layout as
        <xref linkend="composite-desc-example"/> demonstrates:
        <example id="composite-desc-example">
          <title>General composite to display Web service configuration page</title>
          <programlisting><![CDATA[
sub _description
  {

      my $description =
        {
         components      => [
                             'EnableForm',
                             'GeneralConfigurationForm',
                             'VHostTable',
                            ],
         layout          => 'top-bottom',
         name            => 'WebServerComposite',
         printableName   => __('Web service'),
         compositeDomain => 'Web',
         help            => __('The eBox web service allows you ' .
                               'to host Web pages in plain HTML' .
                               'within different virtual hosts'),
        };

      return $description;

  }]]>
          </programlisting>
        </example>
        As you may notice, only the model names are required to integrate the
        components inside the composite.
      </para>

    </section>
    <section id="publish-model-composite-sect">

      <title>Publishing model and composite from this module</title>
      <para>
        In order to let eBox see the models and composites defined above, so 
        that they will be shown and accessed to their data, let's edit the
        main module class <classname>EBox::WebServer</classname>. To publish
        models and composites, we must override <methodname>models</methodname> and
        <methodname>composites</methodname> methods respectively as 
        <xref linkend="model-access-sect"/> describes.
        
        <example id="webserver-publish-example">
          <title>Publishing models and composites from web server module</title>
          <programlisting><![CDATA[
sub models
{
    my ($self) = @_;

    return [
            $self->_enableForm(),
            $self->_generalConfigurationForm(),
            $self->_vHostModel(),
           ];

}

sub composites
{

    my ($self) = @_;

    return [
            $self->_generalComposite()
           ];

}]]>
          </programlisting>
        </example>
        The private methods instantiates the models (composite) just once and 
        it returns back a reference to them. The 
        <xref linkend="model-creation-example"/> describes the creation of the 
        enable form, virtual host model and the composite as examples for
        instantiation of models and composites.
        <example id="model-creation-example">
          <title>Model and composite instatation</title>
          <programlisting><![CDATA[
# Singleton method to create the enable form
sub _enableForm
  {

      my ($self) = @_;

      unless ( exists $self->{enableForm}) {
          $self->{enableForm} = new EBox::Common::Model::EnableForm(
                                    gconfmodule => $self,
                                    directory   => 'EnableForm',
                                    domain      => 'ebox-web',
                                    enableTitle => __('Web service status'),
                                    modelDomain => 'Web',
                                                                   );
      }

      return $self->{enableForm};

  }

# Singleton method to create the virtual host model
sub _vHostModel
  {

      my ($self) = @_;

      unless ( exists $self->{vHostModel}) {
          $self->{vHostModel} =
            new EBox::WebServer::Model::VHostTable(
                                                   gconfmodule => $self,
                                                   directory   => 'VHostTable',
                                                  );
      }

      return $self->{vHostModel};

  }

# Singleton method to create the general composite to show the web
# service configuration
sub _generalComposite
  {

      my ($self) = @_;

      unless ( exists $self->{generalComposite}) {
          $self->{generalComposite} =
            new EBox::WebServer::Model::GeneralComposite();
      }

      return $self->{generalComposite};

  }]]>
          </programlisting>
        </example>
        The enable form is a common model which is intended to be used
        in different modules to enable/disable a service. For this reason,
        its construction is a bit different from the rest, since the 
        model is parametrised with the gettext domain 
        (<parameter>domain</parameter>), its title 
        (<parameter>enableTitle</parameter>) and the model domain
        (<parameter>modelDomain</parameter>). The remainder two methods
        are general ones used along eBox code.
      </para>

    </section>
    <section id="common-tasks-sect">

      <title>Common tasks</title>
      <para>
        Every different thing is almost done. The only different is the way
        to access the stored information. Traditional way allows accessing
        data stored at GConf directly, however with the MVC scheme the data
        is accessed using the data model. These steps are required to finish
        the module:
        <itemizedlist>
          <listitem>
            <para>Generate the configuration files.</para>
          </listitem>
          <listitem>
            <para>Control the daemon execution.</para>
          </listitem>
          <listitem>
            <para>Make the module show up in eBox menu and status summary page.
            </para>
          </listitem>
          <listitem>
            <para>Establish custom rules in the using services and firewall
            modules.</para>
          </listitem>
        </itemizedlist>
        Taking a look to the 
        <link linkend="long-steps-creating-module-list">long way of a module creation</link>,
        we can observe as we have removed any CGI or mason development. Inside
        this section the two steps of the three steps are going to be described
        in some detail.
      </para>

      <para>
        What is known the eBox module "backend" is done in <classname>EBox::WebServer</classname>.
        Firstly, the constructor must indicate to eBox its name and Gettext domain as
        <xref linkend="webserver-constructor-example"/> shows.
        <example id="webserver-constructor-example">
          <title>WebServer module constructor</title>
          <programlisting><![CDATA[
sub _create
{
	my $class = shift;
	my $self = $class->SUPER::_create(
                                          name => 'web',
                                          domain => 'ebox-web',
                                          @_,
                                         );
	bless($self, $class);
	return $self;
}]]>
          </programlisting>
        </example>
      </para>
      
      <section id="configuring-apache2-service">

        <title>Configuring Apache2 service</title>

        <para>
          In order to generate the configuration files and manage the apache daemon,
          it is required to study the Apache web server and handled the features we
          wish to have in our service. The Apache2 web server is a quite complex
          software which manages several files to configure its service.
        </para>

        <para>
          The listening port is set by <filename>/etc/apache2/ports.conf</filename> which
          contains the <parameter>Listen</parameter> directive to achieve so.
        </para>

        <para>
          To enable the user directory, the
          <ulink url="http://httpd.apache.org/docs/2.0/mod/mod_userdir.html">mod_userdir</ulink>
          is used. Its availability comes with the debian package <classname>apache2</classname>
          and it must be listed in <filename>/etc/apache2/mods-available</filename> directory
          as two files <filename>userdir.conf</filename> and <filename>userdir.load</filename>.
          In order to enable the apache2 module, it is required to create symbolic links to
          both previous files inside <filename>/etc/apache2/mods-enabled</filename> directory.
          The default configuration is set up in <filename>userdir.conf</filename>.
        </para>

        <para>
          Related to the virtual hosts, every new virtual host has a predefined template
          to configure them and it is set under <filename>/etc/apache2/sites-available</filename>
          directory. Analogously to the previous module, the virtual host will be enabled
          when a symbolic link to that configuration file is placed in 
          <filename>/etc/apache2/sites-enabled</filename> directory.
        </para>

        <para>
          Similarly as done in <xref linkend="sect-example-daemon"/>, we create a private
          method <methodname>_setWebServerConf</methodname> in order to set up every
          template in the web server configuration as <xref linkend="setup-webserver-conf-example"/>
          whenever the web service is restarted.
          <example id="setup-webserver-conf-example">
            <title>Generating web server configuration files</title>
            <programlisting><![CDATA[
sub _setWebServerConf
  {

      my ($self) = @_;

      $self->_setPort();
      $self->_setUserDir();
      $self->_setVHosts();

  }]]>
            </programlisting>
          </example>
          Every different private method sets up a certain part within the apache setup
          process. The first one sets the listening port, the second one enable/disable
          the user directory module and the last one it will set up every configurated
          virtual host. The program listing from these modules is described in
          <xref linkend="setup-webserver-example"/>
          <example id="setup-webserver-example">
            <title>Setting up the web server</title>
            <programlisting><![CDATA[
# Set up the listening port
sub _setPort
  {

      my ($self) = @_;

      # We can assume the listening port is ready available
      my $generalConf = $self->_generalConfigurationForm();

      # Overwrite the listening port conf file
      $self->writeConfFile(PORTS_FILE,
                           "web/ports.conf.mas",
                           [ portNumber => $generalConf->portValue() ],
                          )

  }

# Set up the user directory by enable/disable the feature
sub _setUserDir
  {

      my ($self) = @_;

      my $generalConf = $self->_generalConfigurationForm();

      if ( $generalConf->enableDirValue() ) {
          # User dir enabled
          foreach my $confFile (USERDIR_CONF_FILES) {
              unless ( -e $confFile ) {
                  throw EBox::Exceptions::External(__x('The {userDirConfFile} ' .
                                                       'is missing! Please recover it',
                                                       userDirConfFile => $confFile));
              }
          }
          # Create the symbolic link
          EBox::Sudo::root('ln -s ' . join ( ' ', USERDIR_CONF_FILES) . ' ' .
                           MODS_ENABLED_DIR);
      } else {
          # Remove any user dir link
          EBox::Sudo::root('rm -f ' . join ( ' ', USERDIR_CONF_FILES));
      }

  }

# Set up the virtual hosts
sub _setVHosts
  {

      my ($self) = @_;

      my $vHostModel = $self->_vHostModel();

      my $vHosts = $vHostModel->rows();

      # Remove every available site using our vhost pattern ebox-*
      my $vHostPattern = VHOST_PREFIX . '*';
      EBox::Sudo::root('rm -f ' . SITES_AVAILABLE_DIR . " $vHostPattern");
      EBox::Sudo::root('rm -f ' . SITES_ENABLED_DIR . " $vHostPattern");

      foreach my $vHost (@{$vHostModel->rows()}) {
          # Access to the field values for every virtual host
          my $vHostValues = $vHost->{plainValueHash};

          my $destFile = SITES_AVAILABLE_DIR . VHOST_PREFIX . $vHostValues->{name};
          writeConfFile( $destFile,
                         "web/vhost.mas",
                         [ vHostName => $vHostValues->{name} ],
                       );

          if ( $vHostValues->{enabled} ) {
              # Create the symbolic link
              EBox::Sudo::root("ln -s $destFile " . SITES_ENABLED_DIR);
          }
      }

  }]]>
            </programlisting>
          </example>
          We have accessed to the data model using two different ways. With regard
          to the general configuration form, we have used the auto-loaded methods
          that a <classname>DataForm</classname> has to access the model values
          directly, for instance <literal>$generalConf->portValue()</literal> and
          <literal>$generalConf->enableDirValue()</literal>. Regarding to
          the virtual host data model, as we have to pass each row the usage
          of <methodname>rows</methodname> is compulsory. Furthermore, accessing
          to the helper structure <varname>plainValueHash</varname> since only
          the values are important when a configuration is regenerated. The internal
          logic creates every virtual host configuration from a single template
          and it is written under <filename>sites-available</filename> directory
          using the pattern: <emphasis>ebox-$virtualHostName</emphasis>. If the
          virtual host is enabled, a symbolic link is created under 
          <filename>sites-enabled</filename> directory.
        </para>

        <para>
          The <filename>ports.conf.mas</filename> is pretty simple as
          <xref linkend="ports-example"/> shows. The <parameter>doc</parameter>
          is set that everything inside them is documentation.
          <example id="ports-example">
            <title><filename>Ports.conf.mas</filename> template</title>
            <programlisting><![CDATA[
<%doc>
  ports.conf.mas writes the listening port used by apache virtual host
  to serve Web pages.

  Parameters:

  portNumber - Int the port number to listen to Web requests

</%doc>
<%args>
  $portNumber
</%args>
Listen <% $portNumber %>]]>
            </programlisting>
          </example>
          Regarding to <filename>vhost.mas</filename>, its content is almost as 
          simple as the ports one as we see in <xref id="vhost-example"/>.
          <example id="vhost-example">
            <title><filename>vhost.mas</filename> template</title>
            <programlisting><![CDATA[
<%doc>
   Template to configure a simple named virtual host using the default
   site given with the apache2 debian package
   
   Parameters:

   vHostName - String the virtual host's name
</%doc>
<%args>
  $vHostName
</%args>
<%init>
  my $vHostPrefix = 'custom-ebox-';
</%init>
NameVirtualHost *
<VirtualHost *>
        ServerAdmin webmaster@localhost

        ServerName <% vHostName %>
        DocumentRoot /var/www/<% $vHostName %>

        ErrorLog /var/log/apache2/error.log

        # Possible values include: debug, info, notice, warn, error, crit,
        # alert, emerg.
        LogLevel warn

        CustomLog /var/log/apache2/access.log combined
        ServerSignature On

        # Under this directory you can manually configure every thing
        # you may need of that stuff
        Include sites-available/<% "$vHostPrefix$vHostName" %>/*
</VirtualHost>]]>
            </programlisting>
          </example>
          Every virtual host may have an <filename>sites-available/custom-ebox-$vHostName</filename>
          directory to include every manual configuration you may require.
        </para>
      </section>

      <section id="managing-apache2-daemon">

        <title>Manage Apache2 daemon execution</title>

        <para>
          Likewise it is done in <xref linkend="ntp-daemon-example"/>, the web service
          is managed by runit and the private method to manage is called
          <methodname>_doDaemon</methodname>.

          <example id="web-daemon-example">
            <title>Web daemon management method</title>
            <programlisting><![CDATA[
sub _doDaemon
  {

      my ($self) = @_;

      if ( $self->running() and $self->service() ) {
          EBox::Service::manage(WEB_SERVICE, 'restart');
      } elsif ( $self->service() ) {
          EBox::Service::manage(WEB_SERVICE, 'start');
      } else {
          EBox::Service::manage(WEB_SERVICE, 'stop');
      }

  }]]>
            </programlisting>
          </example>

          The shell script to launch the web service
          <filename>tools/runit/apache2</filename> contains this listing:
          <example id="apache2-runit-example">
            <title><filename>tools/runit/apache2</filename> file</title>
            <programlisting><![CDATA[
            #!/bin/sh
            exec 1>&2
            exec /usr/sbin/apache2 -DNO_DETACH]]>
            </programlisting>
          </example>

          In addition to the launcher, a finisher script, which is run
          whenever a service ends, is used in order to restart the service
          a fixed number of times in a time interval before ceasing. The
          <command>ebox-runit-finisher</command> requires two arguments:
          
          <variablelist>
            <varlistentry>
              <term><parameter>eBoxModule</parameter></term>
              <listitem>
                <para>This set the eBox module name</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term><parameter>serviceName</parameter></term>
              <listitem>
                <para>The runit service's name</para>
              </listitem>
            </varlistentry>
          </variablelist>
          The finisher script must follow this pattern: 
          <filename>${serviceName}.finish</filename>. In our example, the 
          shell script <filename>tools/runit/apache2.finish</filename> lists as following:
          <example id="apache2-runit-finisher-example">
            <title><filename>tools/runit/apache2.finish</filename> file</title>
            <programlisting><![CDATA[
            #!/bin/sh
            exec ebox-runit-finisher web apache2]]>
            </programlisting>
          </example>
        </para>
      </section>

    <para>
        In order to show up the web server in the menu, it is almost the same procedure than
        <xref linkend="sect-example-menu"/>. However, in this case we just add an
        item. The URL to set is going to show the view from the composite 
        <classname>GeneralComposite</classname> that we have defined in 
        <xref linkend="composite-desc-example"/>. To do so, the URL value must
        follow this pattern: <emphasis>$compositeDomain/Composite/$compositeName</emphasis>
        as <xref linkend="menu-webserver-example"/> describes.
        <example id="menu-webserver-example">
          <title>Adding WebServer to the menu</title>
          <programlisting><![CDATA[
sub menu
  {

      my ($self, $root) = @_;

      my $item = new EBox::Menu::Item(name  => 'WebServer',
                                      text  => __('Web'),
                                      url   => 'Web/Composite/GeneralComposite',
                                     );

      $root->add($item);

  }]]>
          </programlisting>
        </example>
        Regarding to status summary, the <methodname>statusSummary</methodname> method
        implementation is analogous to the one defined in 
        <xref linkend="ntp-summary-example"/> but swapping every NTP reference to
        Web.
      </para>

    </section>
    <section id="expose-module-API-sect">

      <title>Expose module API</title>
      <para>
        The module has two options to expose the configuration settings. Firstly, it
        may open up every model and let the module client access directly to the data
        model or, secondly, it gives some common methods to access the data easily.
        The latter option is chosen by this tutorial.
      </para>

    </section>

        
  </section>

</chapter>
