<!-- vim: ts=2 sw=2
-->
<chapter id="ch-frontend">

	<title>Frontend web</title>

	<section id="sect-cgi">
		<title>CGIs</title>

		<para>El interfaz de administración de eBox está basado en web,
		utilizando <application>mod_perl</application> por encima de
		<application>apache</application>. La información es recogida desde
		los backends de los distintos módulos por scripts CGI y es mostrada a
		través del sistema de plantillas <application>mason</application>.</para>

		<para>La separación por barras de las URLs están asociados con nombres
		de clases de perl. La URL <uri>Network/Index</uri> es traducida al
		nombre de la clase
		<classname>EBox::CGI::Network::Index</classname>. De hecho, la raíz
		del espacio de nombres es <uri>/ebox/</uri>, por lo que la URL actual
		sería <uri>/ebox/Network/Index</uri>, pero esa parte es
		automáticamente manejada por la plataforma. Así que si se necesita
		escribir un CGI para mostrar algún dato o dejarle al usuario
		configurar algo, se debe escribir la clase en el espacio de nombres
		<classname>EBox::CGI</classname> y todas las peticiones coincidentes
		serán enviadas a ésta.</para>

		<para>Hay muchas funcionalidades comunes compartidas por la mayoría de
		CGIs en eBox: manejo de errores, validación de datos de entrada,
		llamada a las plantillas de mason, muestra de mensajes y avisos,
		impresión del menú, etc.</para>

		<para>Por esta razón hay una clase padre de la cual todos los CGI
		deberían heredar. Esta clase implementa todas aquellas funciones que
		que casi no intervienen con las clases hijas, esto es el por qué
		tantos CGI acaban siendo de unas 20 líneas de código. Toda esta
		funcionalidad ahora se divide en dos clases, porque hay una pequeña
		parte específica a la parte del cliente de eBox. Esta parte es
		mantenida por el cliente, y es la clase de la que se debe
		heredar:<classname>EBox::CGI::ClientBase</classname>.</para>

		<para>La otra clase, <classname>EBox::CGI::Base</classname>, tiene la
		mayor parte del código, y reside en <application>libebox</application>
		por lo que puede ser rechazada por el lado del
		servidor. <classname>EBox::CGI::ClientBase</classname> hereda de
		<classname>EBox::CGI::Base</classname>, por lo que se puede olvidar de
		manera segura que son dos clases y únicamente recordar la primera.</para>

		<para>Heredar de <classname>EBox::CGI::ClientBase</classname> mostrará
		una página con la barra de titulo normal y el menú, pero con el cuerpo
		vacío. Si se pasa el argumento <parameter>title</parameter> al
		constructor de la clase padre, se mostrará también.</para>

		<example id='ex-cgi-hello'>
			<title>CGI Hola mundo</title>

			<programlisting><![CDATA[package EBox::CGI::Hello::World;

use strict;
use warnings;

use base 'EBox::CGI::ClientBase';

use EBox::Gettext;

sub new 
{
	my $class = shift;
	my $self = $class->SUPER::new('title' => __('Hola Mundo!'), @_);
	bless($self, $class);
	return $self;
}]]></programlisting>
		</example>

		<para>En la gran mayoría de casos, sólo será necesario implementar la
		función abstracta <methodname>_process</methodname> en las clases para
		conseguir el resultado deseado. Es llamada por la clase padre, la cual
		realiza distintas acciones dependiendo del estado del objeto después
		de la llamada a <methodname>_process</methodname>. Hay ciertos
		atributos en la clase que pueden cambiarse para modificar el
		comportamiento de la clase padre. La propia función
		<methodname>_process</methodname> normalmente haría alguna de estas
		dos cosas (quizá ambas):</para>

		<itemizedlist>
			<listitem>
				<para>Obtener información del backend del módulo y
				dárselo a una plantilla de mason que la mostraría.</para>
			</listitem>

			<listitem>
				<para>Leer los campos de entrada de la petición HTTP y
				usarlos para realizar alguna acción en el backend del módulo.</para>
			</listitem>
		</itemizedlist>

		<para>La próxima cosa que hay que saber es como hacer que un CGI
		utilice una plantilla de mason para mostrar información. Es realmente
		sencillo. Se puede pasar únicamente un argumento
		<parameter>template</parameter> al constructor del padre, o configurar
		el atributo <structfield>template</structfield> en cualquier momento
		antes del return de su función <methodname>_process</methodname>. Este
		código muestra ambas aproximaciones:</para>

		<example>
			<title>Configurando la plantilla mason para un CGI</title>

			<programlisting><![CDATA[# Configurando la plantilla en el constructor
sub new 
{
	my $class = shift;
	my $self = $class->SUPER::new('title' => __('Hola Mundo!'), 
					'template' => 'hello/world.mas',
					@_);
	bless($self, $class);
	return $self;
}

# Setting the template in _process
sub _process
{
	my $self = shift;
	$self->setTemplate('hello/world.mas');
}]]></programlisting>
		</example>

		<para>En segundo lugar, necesitamos poder pasar alguna información a
		la plantilla mason. Esto se hace utilizando el atributo
		<structfield>params</structfield>. Debería ser una referencia a un
		array que contenga todos los parámetros y sus nombres. Esto es la
		función <methodname>_process</methodname> para la página de
		configuración general (la que contiene el puerto, contraseña e
		idioma):</para>

		<example>
			<title>Enviando argumentos a la plantilla de mason</title>
			<programlisting><![CDATA[sub _process
{
	my $self = shift;

	my $global = EBox::Global->getInstance();
	my $apache = $global->modInstance('apache');

	my @array = ();
	push(@array, 'port' => $apache->port());
	push(@array, 'lang' => EBox::locale());

	$self->{params} = \@array;
}]]></programlisting>
		</example>

		<para>Eso está así para utilizar plantillas desde los CGIs. Los
		detalles acerca de la escritura están descritos en <xref
		linkend='sect-mason'/>.</para>

		<para>Hay otro mecanismo para mostrar los datos al usuario. Puede
		mostrar mensajes configurando los atributos
		<structfield>msg</structfield> y <structfield>error</structfield> para
		mostrar cualquier texto que se quiera. Ambos tipos de mensajes se
		muestran en una caja en la parte superior de la página. Necesita tener
		algo de cuidado con el atributo <structfield>error</structfield>,
		siendo que serán sobreescritas si una excepción es capturada por la
		clase padre.</para>

		<example>
			<title>Estableciendo el atributo 'msg'</title>
			<programlisting><![CDATA[sub _writeBackupToDiscAction
{
  my ($self) = @_;
 
  my $backup = new EBox::Backup;
  my $id     = $self->param('id');
  
  $backup->writeBackupToDisc($id);

  $self->setMsg(__('Backup was written to CD/DVD disk'));
}]]></programlisting>
		</example>


		<para>Leyendo los argumentos enviados en la petición HTTP es muy
		sencillo. La clase padre utiliza el módulo de perl
		<classname>CGI</classname> para acceder a esta información, y provee
		de un recubridor sobre esta función <function>param</function>, que
		hace algunas comprobaciones en la entrada de datos. Esta es la función
		<methodname>_process</methodname> en el CGI que cambia el puerto TCP
		del interfaz web:</para>

		<example id='ex-http-params'>
			<title>Utilizando parámetros de la petición HTTP</title>
			<programlisting><![CDATA[sub _process
{
	my $self = shift;

	my $global = EBox::Global->getInstance();
	my $apache = $global->modInstance('apache');

	$apache->setPort($self->param('port'));
}]]></programlisting>
		</example>

		<para>Es tan simple porque todas las comprobaciones sobre los datos
		son realizados por el backend (utilizando el módulo de perl
		<classname>EBox::Validate</classname>) y por la clase padre. Otra
		razón para conseguir la simplicidad del código de arriba es que el
		manejo de errores es automático.</para>

		<para>Mientras se hacen todas esas cosas, las excepciones se pueden
		lanzar. A no ser que haya una buena razón para capturar una excepción
		(p.ej. espera el error y no quiere que se muestre como un error)
		probablemente será suficiente que las excepciones sean lanzadas y
		escribir el código como si no existieran realmente. El comportamiento
		estándar es que las excepciones que hereden de
		<classname>EBox::Exceptions::Internal</classname> causen un mensaje de
		error genérico, mandando al usuario a consultar los registros si
		necesitase ver los detalles. Las subclases de
		<classname>EBox::Exceptions::External</classname> son mostradas
		textualmente, el uso más común para estas excepciones es cuando los
		datos introducidos por el usuario se validan.</para>

		<para>La última parte que necesita aprender es como redirigir las
		peticiones a otros CGIs. Hay pocas razones por las cuales se requiere
		hacer eso, por ejemplo, escribir un CGI que tome unos datos del
		usuario desde el navegador, cambie algo en el backend del módulo y
		redirija la petición al CGI que muestra los datos. El CGI mostrado en
		<xref linkend='ex-http-params'/> no llama a ninguna plantilla de
		mason, únicamente cambia el puerto de apache y no hace nada
		más. Queremos que el usuario vea la misma página que veía antes de
		cambiar el puerto, con el nuevo valor. <xref
		linkend='ex-http-redirect'/> muestra el constructor para ese CGI:</para>

		<example id='ex-http-redirect'>
			<title>Redirigiendo una petición a un CGI distinto</title>
			<programlisting><![CDATA[sub new
	my $class = shift;
	my $self = $class->SUPER::new(@_);
	bless($self, $class);
	$self->setRedirect("EBox/General");
	return $self;
}]]></programlisting>
		</example>

		<para>Se puede ver que el constructor configura el atributo
		<structfield>redirect</structfield> con el valor de la URL de la
		página a la que queremos ser redirigidos. Eso es todo lo que hace
		falta hacer. A <structfield>redirect</structfield> se le da un valor y
		la clase padre hará una redirección HTTP después de que haya acabado
		la función <methodname>_process</methodname>.</para>

		<para>Una redirección HTTP hace que el navegador lance una nueva
		petición HTTP, por lo que toda la información de estado de la antigua
		petición se pierde. Habrá casos en los que querremos mantener la
		información para el nuevo CGI, y para ello tenemos dos formas de
		hacerlo. Podría hacerse pasando los parámetros GET en la URL de la
		redirección, pero es mucho más sencillo hacerlo en una redirección
		interna, sin que pase a través del navegador.</para>

		<para>Si necesita mantener la información, como un mensaje o una
		advertencia la usuario, puede utilizar el atributo
		<structfield>chain</structfield>. Funciona exactamente de la misma
		forma que <structfield>redirect</structfield> pero en vez de enviar
		una respuesta HTTP al navegador, la clase padre procesa la URL,
		instancia el CGI coincidente, copia todos los datos en él y lo
		ejecuta. Los mensajes y errores son copiados automáticamente, los
		parámetros en la petición HTTP no, ya que un error causado por uno de
		ellos se podría propagar al siguiente CGI.</para>

		<!-- FIXME - example -->

		<para>Si necesita mantener los parámetros HTTP puede utilizar la
		función <methodname>keepParam</methodname> de la clase padre. Toma el
		nombre del parámetro como un argumento y lo añade a la lista de
		parámetros que se le copiarán al nuevo CGI si se usa el atributo
		<structfield>chain</structfield>.</para>

		<!-- FIXME - example -->

		<para>Los errores son un caso especial. Cuando aparece un error, no se
		desea hacer redirecciones, ya que el mensaje de error se perdería. Si
		aparece un error y <structfield>redirect</structfield> tiene un valor,
		entonces ese valor se utiliza como si fuera
		<structfield>chain</structfield>. Sin embargo, algunas veces se desea
		encadenarlo a un CGI aparte si hay un error, por ejemplo si la causa
		del error es la ausencia de un parámetro de entrada necesario para
		mostrar la página. Si se da ese caso, se puede utilizar el atributo
		<structfield>errorchain</structfield>, el cual tiene una prioridad más
		alta que <structfield>chain</structfield> y
		<structfield>redirect</structfield> si hay un error.</para>

		<para>Finalmente, el último detalle que hace falta conocer acerca de
		los CGIs es como hacer que funcione correctamente la
		internacionalización, tanto en los CGIs como en las plantillas de
		mason. Siendo que el módulo no tendrá el mismo dominio gettext en la
		plataforma eBox, la plataforma necesita conocer el dominio para poder
		configurarlo antes de llamar al CGI y a la plantilla. Es tan simple
		como pasarle como argumento al constructor del padre. El constructor
		"Hola mundo" en <xref linkend='ex-cgi-hello'/> sería así:</para>

		<example id='ex-cgi-domain'>
			<title>Configurando el dominio gettext en un CGI</title>

			<programlisting><![CDATA[sub new 
{
	my $class = shift;
	my $self = $class->SUPER::new('title' => __('Hola mundo!'),
					'domain' => 'ebox-hello',
					@_);
	bless($self, $class);
	return $self;
}]]></programlisting>
		</example>

		<para>Si el título se puede traducir, debería configurarlo de nuevo en
		la función <function>_process</function>, como:
			<programlisting>
				$self->{title} = __('Hello world');
			</programlisting>
		o de otra forma no será traducido correctamente.
		</para>

		<para>Por otra parte, note que no debería utilizar nunca
		<function>__</function> con cadenas no traducibles, como nombres de
		protocolo (p. ej., DHCP, NTP, ...).</para>
		       
	</section>

	<section id="sect-mason">
		<title>Plantillas mason</title>

		<para>Esta sección cubrirá sólo unos pocos aspectos básicos de la
		escritura de las plantillas de mason, especialmente aquellos detalles
		relacionados con eBox. Si necesita información concreta acerca de
		algún aspecto debería revistar la <ulink
		url='http://www.masonhq.com/'>documentación de mason</ulink> o el
		<ulink url='http://www.masonbook.com/'>libro de mason</ulink>. Más
		ejemplos se pueden encontrar en <xref linkend='ch-examplemod'/>.</para>
			
		<para>La primera cosa que la plantilla de mason debe tener es la
		declaración de los argumentos que espera. Únicamente se ha de escribir
		el nombre de las variables, una por línea y nada más. Los argumentos
		declarados como arrays en la plantilla serán pasados como la
		referencia a un array por el CGI.</para>
		
		<para>En nuestro ejemplo vamos a enviar un array con nombres a la
		plantilla, y la plantilla saludará a cada uno de ellos por
		separado. Utilizamos un array vacío como valor por defecto para la
		variable, aunque los valores por defecto  son opcionales. Si no se le
		da nada y ni se le pasa ese argumento a la plantilla, se lanzará una
		excepción.</para>

		<example>
			<title>Declarando argumentos en una plantilla de mason</title>

			<programlisting><![CDATA[<%args>
	@people => ()
</%args>]]></programlisting>
		</example>

		<para>La siguiente parte es la sección de inicialización. En esta
		sección podemos escribir código perl normal. Es opcional y la mayor
		parte de las veces no necesario. Sin embargo, todas las plantillas de
		eBox tienen uno, porque siempre está la necesidad de tener i18n, por
		lo que importaremos <classname>EBox::Gettext</classname>:</para>

		<example>
			<title>Sección init en las plantillas de mason</title>

			<programlisting><![CDATA[<%init>
use EBox::Gettext;
</%init>]]></programlisting>
		</example>

		<para>Ahora podemos escribir el cuerpo de la plantilla. La idea es
		escribir únicamente HTML y utilizar un par de características
		sintácticas para insertar código de perl cuando es necesario. Primero,
		aprenderemos a controlar el flujo de la plantilla. Todas las lineas
		que comiencen por <literal>%</literal> son interpretadas como código
		de perl.</para>

		<example>
			<title>Incluyendo código perl en una plantilla de mason</title>
			<programlisting><![CDATA[<ul>
% foreach my $person (@people) {
	<li>Hello</li>
% }
</ul>]]></programlisting>
		</example>

		<para>Queremos imprimir el nombre de una persona por cada elemento de
		la lista. Incluir expresiones de perl en las marcas especiales
		<literal>&lt;% %&gt;</literal> imprime el valor de la expresión en la
		salida de la plantilla. Vamos a utilizar esta característica para
		imprimir el nombre de la persona y traducir la cadena "Hola"
		(internacionalización es explicada en <xref linkend='sect-i18n'/>).</para>

		<example>
			<title>Imprimiendo cadenas en una plantilla de mason</title>
			<programlisting><![CDATA[<ul>
% foreach my $person (@people) {
	<li><% __('Hola ') %> <% $person %></li>
% }
</ul>]]></programlisting>
		</example>

		<para>La macro m4 de ebox exporta la ruta de instalación para las
		plantillas de mason como <varname>TEMPLATESPATH</varname>, por lo que
		deberían instalarse bajo ese directorio, posiblemente creando un
		subdirectorio para el módulo. Cuando se necesite referenciar una
		plantilla en el código, se puede usar una ruta relativa a
		<varname>TEMPLATESPATH</varname>. Siguiendo nuestro ejemplo, se usará
		un subdirectorio llamado <filename>hello</filename> para nuestras
		plantillas, y colocaremos una plantilla denominada
		<filename>world.mas</filename> en él.</para>

		<section id='sect-gui-style'>
			<title>Elementos estándar de la GUI</title>	
			
			<para>Hay unos pocos elementos de la GUI que son mostrados de
			la misma forma en todos los módulos de eBox. Cosas como
			consejos, mensajes, avisos, errores, tablas y formularios
			mantienen un estilo común. Todas estas cosas están definidas
			en un fichero CSS, para que todos los módulos tengan un estilo
			consistente. Algunos de estos elementos tienen un
			comportamiento dinámico también. Los consejos son ocultados
			cuando la página se carga, y se muestran si el usuario pulsa
			sobre el enlace de la esquina superior derecha de la
			página. Esta sección da una repaso a todos estos elementos y
			como usarlos para alcanzar un interfaz de usuario consistente
			con el resto de módulos de eBox.</para>

			<para>Toda información que queramos mostrar al usuario, ya sea para
			advertirle que una operación tiene riesgo, notificarle un error,
			mostrarle ayuda o darle una información relevante la escribiremos
			siguiendo el mismo esquema en html pero usando diferentes estilos 
			CSS.</para>

			<example>
				<title>Esquema html para mostrarle información al usuario</title>
				<programlisting><![CDATA[<div class='class-name'>
	Mensaje para el usuario.
</div>]]></programlisting>
			</example>

			<variablelist>
				
				<title>Nombres de clases CSS para mostrarle información al usuario</title>

				<varlistentry>

					<term><emphasis>help</emphasis></term>	

					<listitem>
						<para>Para mostrar ayuda al usuario. Recordemos que al usar este
						estilo la ayuda aparecerá oculta al usuario hasta que el decida que
						sea visible.</para>
					</listitem>

				</varlistentry>

				<varlistentry>

					<term><emphasis>error</emphasis></term>	

					<listitem>
						<para>Para notificar un error al usuario.</para>
					</listitem>

				</varlistentry>

				<varlistentry>

					<term><emphasis>note</emphasis></term>	

					<listitem>
						<para>Para notificar al usuario ayuda de forma permanente. Cuando
						queremos que el usuario conozca una determinada información sin
						necesidad de activar la ayuda.</para>
					</listitem>

				</varlistentry>

				<varlistentry>

					<term><emphasis>warning</emphasis></term>	

					<listitem>
						<para>Para mostrar advertencias al usuario, por ejemplo, si queremos
						advertirle cuando va a borrar un determinado dato.</para>
					</listitem>

				</varlistentry>

			</variablelist>

			<para>Si queremos mostrar un listado de datos, por ejemplo un listado de
			usuarios, usamos una tabla con los elementos <sgmltag>thead</sgmltag> y
			<sgmltag>tbody</sgmltag> para mostrar la cabecera del listado y su
			contenido respectivamente. El estilo CSS para esta tabla es 
			<emphasis>dataTable</emphasis>.</para>

			<example>
				<title>Tabla de listado de datos</title>
				<programlisting><![CDATA[<table class='dataTable'>
	<caption><% __('Object List') %></caption>
	<thead>
		<tr>
			<th class='tleft'><% __('Name') %></th>
			<th class='thOptions'><% __('Action') %></th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td></td>
			<td class='tcenter'>
				<a href='Del?objectname=<% $obj->{'name'} %>'>
						<img src='/data/images/delete.gif'
						     title="<% __('Delete') %>"
						     alt="<% __('Delete') %>"/>
				</a>
			</td>
		</tr>
	</tbody>
</table>]]></programlisting>
			</example>

			<para>Como vemos en el ejemplo la tabla tiene una etiqueta
			<sgmltag>caption</sgmltag> para especificar el título de la tabla, no es
			obligatorio pero es de ayuda para identificar el tipo de datos que estamos
			listando.</para>

			<para>El resto de estilos CSS se usan para alinear el texto de las 
			columnas:</para>

			<variablelist>
				
				<varlistentry>

					<term><emphasis>tleft</emphasis></term>

					<listitem>
						<para>Las columnas de cabecera (<emphasis>thead</emphasis>) tienen
						por defecto la alineación en el centro, nosotros obligamos a que sea
						a la izquierda para facilitar la lectura en los listados de 
						datos.</para>
					</listitem>

				</varlistentry>

				<varlistentry>

					<term><emphasis>tcenter</emphasis></term>

					<listitem>
						<para>Las acciones que podemos ejecutar sobre cada fila de un
						listado se alinean en el centro con este estilo.</para>
					</listitem>

				</varlistentry>

				<varlistentry>

					<term><emphasis>thOptions</emphasis></term>

					<listitem>
						<para>Ajusta el tamaño de la columna al mínimo necesario y alinea el
						texto en el centro.</para>
					</listitem>

				</varlistentry>

			</variablelist>

			<para>Para mostrar un formulario usamos una tabla de dos columnas con el
			estilo <emphasis>formTable</emphasis>.</para>

			<example>
				<title>Formulario de entrada de datos</title>
				<programlisting><![CDATA[<table class='formTable'>
	<tr>
		<td class='tright'>
			<span class='ftitle'><% __('Name') %>:</span>	
		</td>
		<td>
			<input class='inputText' type='text' name='name' />
		</td>
	</tr>
	<tr>
		<td></td>
		<td>
			<input class='inputButton' type='submit' />
		</td>
	</tr>
</table>]]></programlisting>
			</example>

			<para>La primera columna contiene la descripción correspondiente al dato 
			que vamos a introducir. Alineamos la columna de la descripción a la 
			derecha usando la clase <emphasis>tright</emphasis>, y el texto lo 
			escribimos dentro de la etiqueta <sgmltag>span</sgmltag> con la clase
			<emphasis>ftitle</emphasis> para resaltarlo más.</para>

			<para>La entrada de texto en la columna derecha tiene la clase
			<emphasis>inputText</emphasis> para decorar la caja de entrada de 
			texto.</para>

			<para>El botón del formulario tiene el estilo
			<emphasis>inputButton</emphasis> con un propósito meramente 
			decorativo.</para>

		</section>

	</section>

	<section id="sect-menu">
		<title>El menú</title>

		<para>El menú en el interfaz de la administración es dinámicamente
		generado, permitiendo a todos los módulos instalados añadir nuevos
		objetos y carpetas a él. Hay un juego de clases bajo el espacio de
		nombres <classname>EBox::Menu</classname> que pueden ser utilizadas
		para construir las estructuras del menú. Las importantes son
		<classname>EBox::Menu::Item</classname> y
		<classname>EBox::Menu::Folder</classname>.</para>

		<para>El constructor para <classname>EBox::Menu::Item</classname> toma
		dos argumentos nombrados <parameter>text</parameter> y
		<parameter>url</parameter>. <parameter>url</parameter> debería ser
		relativo a la ruta raíz para el interfaz de configuración, por
		ejemplo, la página de filtrado de paquetes del firewall tiene
		<uri>Firewall/Filter</uri> como su <parameter>url</parameter>.</para>

		<para>El constructor de <classname>EBox::Menu::Folder</classname> no
		toma el argumento <parameter>url</parameter>, pero toma el
		<parameter>name</parameter>. El nombre es utilizado internamente como
		un identificador en la implementación del menú javascript.</para>

		<para>Ambos elementos y carpetas tienen un argumento opcional
		<parameter>order</parameter> en sus constructores, que debería ser un
		entero entre 1 y 10. Los elementos del menú están ordenador desde los
		valores más bajos a los más altos. El valor por defecto es 5.</para>

		<para>Una carpeta puede contener elementos, por lo que se pueden
		añadir instancias de <classname>EBox::Menu::Item</classname> a
		<classname>EBox::Menu::Folder</classname>.</para>

		<para>Finalmente, la forma de añadir elementos del menú y/o carpetas
		al menú es simplemente implementar la función
		<methodname>menu</methodname> en el módulo. Esta función toma una
		instancia <classname>EBox::Menu::Root</classname> como argumento, y
		puede añadir tantos elementos y carpetas como se quieran. Ésta es la
		función <methodname>menu</methodname> para el módulo firewall:</para>		

		<example>
			<title>Añadiendo carpetas y elementos al menú</title>
			<programlisting><![CDATA[sub menu
{
	my ($self, $root) = @_;
	my $folder = new EBox::Menu::Folder('name' => 'Firewall',
				'text' => __('Firewall'),
				'order' => 4);

	$folder->add(new EBox::Menu::Item('url' => 'Firewall/Filter',
				'text' => __('Packet Filter')));
	$folder->add(new EBox::Menu::Item('url' => 'Firewall/Redirects',
				'text' => __('Redirects')));

	$root->add($folder);
}]]></programlisting>
		</example>

		<!-- FIXME - screenshot -->

	</section>

	<section id="sect-summarypage">
		<title>Resumen</title>

		<para>La interfaz de usuario de eBox tiene  una página "Resumen" donde
		se muestra la información del estado de cada módulo. Esta página tiene
		dos partes:</para>

		<itemizedlist>
			<listitem>
				<para>La primera parte es una tabla con el estado de
				todos los servicios de red instalados: si están
				ejecutándose o no y los botones correspondientes para reiniciarlos.</para>
			</listitem>

			<listitem>
				<para>La segunda parte de la página tiene una sección
				separada para cada módulo, donde se puede mostrar una
				información más detallada.</para>
			</listitem>
		</itemizedlist>

		<!-- FIXME  screenshot -->

		<para>La información del resumen es recogida llamando a dos funciones
		abstractas definidas en <classname>EBox::Module</classname>, si no
		desea implementarlas, entonces no se mostrará información sobre ese
		módulo. <methodname>statusSummary</methodname> rellena la tabla en la
		que se mostrará el estado de los servicios de red y
		<methodname>summary</methodname> crea la sección resumen para el módulo.</para>

		<para>La forma en que el resumen está construido es muy parecida a la
		forma en que lo está el menú, como se puede ver en <xref
		linkend='sect-menu'/>. Hay unas cuantas clases en el espacio de
		nombres <classname>EBox::Summary</classname> que se pueden usar para
		construir la información de
		resumen. <methodname>statusSummary</methodname> debería devolver un
		objeto de tipo <classname>EBox::Summary::Status</classname> mientras
		que <methodname>summary</methodname> es libre de devolver cualquier
		objeto cuyo tipo sea un subtipo de
		<classname>EBox::Summary::Item</classname>, aunque la mayor parte de
		los módulos sólo devuelvan un
		<classname>EBox::Summary::Module</classname>.</para>

		<para>Cada uno de las subclases de
		<classname>EBox::Summary::Item</classname> tiene algunos atributos y
		pueden contener otros objetos
		<classname>EBox::Summary::Item</classname>, y que todos ellos saquen
		algo de código HTML. <classname>EBox::Summary::Module</classname>
		tiene un atributo <structfield>title</structfield>, que cuando llega
		el momento de generar la página muestra el título
		<structfield>title</structfield> y el html para sus hijos por debajo
		suyo.</para>

		<para>Para ver como está construida la sección resumen, vamos a echar
		un vistazo al módulo network. La salida de su resumen es un título y
		una sección por cada interfaz de red, con un título en negrita y una
		tabla que muestra su dirección MAC, dirección IP, máscara de red,
		etc. <xref linkend='ex-network-summary'/> muestra las partes
		importantes de su función <methodname>summary</methodname>.</para>

		<example id='ex-network-summary'>

			<title>Implementación de ejemplo de <methodname>summary</methodname></title>

			<programlisting><![CDATA[my $item = new	EBox::Summary::Module(__("Interfaces de red"));

foreach my $iface (@{$ifaces}) {
	my $status = __("down");
	my $section = new EBox::Summary::Section($iface);
	$item->add($section);

	if (iface_is_up($iface)) {
		$status = __("up");
	}
	$section->add(new EBox::Summary::Value (__("Status"), $status));

	my $ether = iface_mac_address($iface);
	if ($ether) {
		$section->add(new EBox::Summary::Value(
			__("dirección MAC"), $ether));
	}

	my @ips = iface_addresses($iface);
	foreach my $ip (@ips) {
		$section->add(new EBox::Summary::Value(
			__("dirección IP"), "$ip"));
	}
}
return $item;]]></programlisting>
		</example>

		<!-- FIXME screenshot -->

		<para>Primero se crea un objeto
		<classname>EBox::Summary::Module</classname>. Éste objeto mantendrá
		toda la información del resumen.</para>

		<para>Entonces se creará un objeto de tipo
		<classname>EBox::Summary::Section</classname> para cada interfaz de
		red. Es una sección con un título (pasado como argumento al
		constructor) y contiene varios objetos
		<classname>EBox::Summary::Value</classname>, los cuales muestran el
		nombre y un valor asociado como filas de una tabla en la sección. Por
		tanto, varios valores se añaden a cada sección y las secciones son
		añadidas al objeto <classname>EBox::Summary::Module</classname>. El
		resultado es un árbol de objetos, y su raíz es la
		<classname>EBox::Summary::Module</classname>. Cuando se le pide
		imprimirse, muestra su título y pide a cada uno de sus hijos que se
		impriman. Para ver como es, sólo hace falta abrir la página Resumen de
		una instalación de eBox.</para>

		<!-- FIXME - screenshot -->

		<para><methodname>summary</methodname> puede devolver cualquier objeto
		siempre que herede de <classname>EBox::Summary::Item</classname>,
		puede crearse uno propio si las necesidades no son cubiertas por los
		elementos estándar que vienen con la plataforma.</para>

		<para><methodname>statusSummary</methodname> es más sencillo. Solo ha
		de devolver un objeto <classname>EBox::Summary::Status</classname>. El
		constructor para esta clase necesita tres argumentos:</para>

		<itemizedlist>

			<listitem>
				<para>El nombre del servicio.</para>
			</listitem>

			<listitem>
				<para>Un valor booleano que indique si el servicio
				está ejecutándose.</para>
			</listitem>

			<listitem>
				<para>Un valor booleano que indica si el servicio está
				activado o no.</para>
			</listitem>
		</itemizedlist>

		<para>La razón por la cual existe este tercer argumento es que existen
		servicios que el usuario no debería poder iniciar, en la página de
		resumen, porque no han sido configurados. Así si, por ejemplo, el
		servicio de squid está desconectado, el usuario tendrá que ir a la
		página de configuración de squid y activar allí el servicio. <xref
		linkend='ex-squid-status'/> muestra la implementación de la función
		<methodname>statusSummary</methodname> en el módulo squid, además de
		algunas funciones relacionadas.</para>
				
		<example id='ex-squid-status'>

			<title>Ejemplo de implementación de
			<methodname>statusSummary</methodname></title>

			<programlisting><![CDATA[sub statusSummary
{
	my $self = shift;
	return new EBox::Summary::Status('squid', __('Proxy HTTP'),
					$self->isRunning, $self->service);
}

sub isRunning
{
	my $self = shift;
	return $self->pidFileRunning(PIDFILE);
}

sub service
{
	my $self = shift;
	return $self->get_bool('active');
}]]></programlisting>

		</example>
		
		<para>De nuevo, se puede comprobar como se ve en la página de Resumen
		en una instalación de eBox que tiene el módulo squid incluido.</para>

	</section>

</chapter>
