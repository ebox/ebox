<!-- vim: ts=2 sw=2
-->
<chapter id="ch-frontend">

	<title>Frontend web</title>

	<section id="sect-cgi">
		<title>CGIs</title>

		<para>El interfaz de administración de eBox está basado en web,
		utilizando <application>mod_perl</application> por encima de
		<application>apache</application>. La información es recogida desde
		los backends de los distintos módulos por scripts CGI y es mostrada a
		través del sistema de plantillas <application>mason</application>.</para>

		<para>La separación por barras de las URLs están asociados con nombres
		de clases de perl. La URL <uri>Network/Index</uri> es traducida al
		nombre de la clase
		<classname>EBox::CGI::Network::Index</classname>. De hecho, la raíz
		del espacio de nombres es <uri>/ebox/</uri>, por lo que la URL actual
		sería <uri>/ebox/Network/Index</uri>, pero esa parte es
		automáticamente manejada por la plataforma. Así que si se necesita
		escribir un CGI para mostrar algún dato o dejarle al usuario
		configurar algo, se debe escribir la clase en el espacio de nombres
		<classname>EBox::CGI</classname> y todas las peticiones coincidentes
		serán envíadas a ésta.</para>

		<para>Hay muchas funcionalidades comunes compartidas por la mayoría de
		CGIs en eBox: manejo de errores, validación de datos de entrada,
		llamada a las plantillas de mason, muestra de mensajes y avisos,
		impresión del menú, etc.</para>

		<para>Por esta razón hay una clase padre de la cual todos los CGI
		deberían heredar. Esta clase implementa todas aquellas funciones que
		que casi no intervienen con las clases hijas, esto es el por qué
		tantos CGI acaban siendo de unas 20 líneas de código. Toda esta
		funcionalidad ahora se divide en dos clases, porque hay una pequeña
		parte específica a la parte del cliente de eBox. Esta parte es
		mantenida por el cliente, y es la clase de la que se debe
		heredar:<classname>EBox::CGI::ClientBase</classname>.</para>

		<para>La otra clase, <classname>EBox::CGI::Base</classname>, tiene la
		mayor parte del código, y reside en <application>libebox</application>
		por lo que puede ser rechazada por el lado del
		servidor. <classname>EBox::CGI::ClientBase</classname> hereda de
		<classname>EBox::CGI::Base</classname>, por lo que se puede olvidar de
		manera segura que son dos clases y únicamnete recordar la primera.</para>

		<para>Heredar de <classname>EBox::CGI::ClientBase</classname> mostrará
		una página con la barra de titulo normal y el menú, pero con el cuerpo
		vacío. Si se pasa el argumento <parameter>title</parameter> al
		constructor de la clase padre, se mostrará también.</para>

		<example id='ex-cgi-hello'>
			<title>CGI Hola mundo</title>

			<programlisting><![CDATA[package EBox::CGI::Hello::World;

use strict;
use warnings;

use base 'EBox::CGI::ClientBase';

use EBox::Gettext;

sub new 
{
	my $class = shift;
	my $self = $class->SUPER::new('title' => __('Hola Mundo!'), @_);
	bless($self, $class);
	return $self;
}]]></programlisting>
		</example>

		<para>En la gran mayoría de casos, sólo será necesario implementar la
		función abstracta <methodname>_process</methodname> en las clases para
		conseguir el resultado deseado. Es llamada por la clase padre, la cual
		realiza distintas acciones dependiendo del estado del objeto después
		de la llamada a <methodname>_process</methodname>. Hay ciertos
		atributos en la clase que pueden cambiarse para modificar el
		comportamiento de la clase padre. La propia función
		<methodname>_process</methodname> normalmente haría alguna de estas
		dos cosas (quizá ambas):</para>

		<itemizedlist>
			<listitem>
				<para>Obtener información del backend del módulo y
				dárselo a una plantilla de mason que la mostraría.</para>
			</listitem>

			<listitem>
				<para>Leer los campos de entrada de la petición HTTP y
				usarlos para realizar alguna acción en el backend del módulo.</para>
			</listitem>
		</itemizedlist>

		<para>La próxima cosa que hay que saber es como hacer que un CGI
		utilice una plantilla de mason para mostrar información. Es realmente
		sencillo. Se puede pasar únicamente un argumento
		<parameter>template</parameter> al constructor del padre, o configurar
		el atributo <structfield>template</structfield> en cualquier momento
		antes del return de su función <methodname>_process</methodname>. Este
		código muestra ambas aproximaciones:</para>

		<example>
			<title>Configurando la plantilla mason para un CGI</title>

			<programlisting><![CDATA[# Configurando la plantilla en el constructor
sub new 
{
	my $class = shift;
	my $self = $class->SUPER::new('title' => __('Hola Mundo!'), 
					'template' => 'hello/world.mas',
					@_);
	bless($self, $class);
	return $self;
}

# Setting the template in _process
sub _process
{
	my $self = shift;
	$self->{template} = 'hello/world.mas';
}]]></programlisting>
		</example>

		<para>En segundo lugar, necesitamos poder pasar alguna información a
		la plantilla mason. Esto se hace utilizando el atributo
		<structfield>params</structfield>. Debería ser una referencia a un
		array que contenga todos los parámetros y sus nombres. Esto es la
		función <methodname>_process</methodname> para la página de
		configuración general (la que contiene el puerto, contraseña e
		idioma):</para>

		<example>
			<title>Enviando argumentos a la plantilla de mason</title>
			<programlisting><![CDATA[sub _process
{
	my $self = shift;

	my $global = EBox::Global->getInstance();
	my $apache = $global->modInstance('apache');

	my @array = ();
	push(@array, 'port' => $apache->port());
	push(@array, 'lang' => EBox::locale());

	$self->{params} = \@array;
}]]></programlisting>
		</example>

		<para>Eso está así para utilizar plantillas desde los CGIs. Los
		detalles acerca de la escritura están descritos en <xref
		linkend='sect-mason'/>.</para>

		<para>Hay otro mecanismo para mostrar los datos al usuario. Puede
		mostrar mensajes configurando los atributos
		<structfield>msg</structfield> y <structfield>error</structfield> para
		mostrar cualquier texto que se quiera. Ambos tipos de mensajes se
		muestran en una caja en la parte superior de la página. Necesita tener
		algo de cuidado con el atributo <structfield>error</structfield>,
		siendo que serán sobreescritas si una excepción es capturada por la
		clase padre.</para>

		<!-- FIXME example -->

		<para>Leyendo los argumentos enviados en la petición HTTP es muy
		sencillo. La clase padre utiliza el módulo de perl
		<classname>CGI</classname> para acceder a esta información, y provee
		de un recubridor sobre esta función <function>param</function>, que
		hace algunas comprobaciones en la entrada de datos. Esta es la función
		<methodname>_process</methodname> en el CGI que cambia el puerto TCP
		del interfaz web:</para>

		<example id='ex-http-params'>
			<title>Utilizando parámetros de la petición HTTP</title>
			<programlisting><![CDATA[sub _process
{
	my $self = shift;

	my $global = EBox::Global->getInstance();
	my $apache = $global->modInstance('apache');

	$apache->setPort($self->param('port'));
}]]></programlisting>
		</example>

		<para>Es tan simple porque todas las comprobaciones sobre los datos
		son realizados por el backend (utilizando el módulo de perl
		<classname>EBox::Validate</classname>) y por la clase padre. Otra
		razón para conseguir la simplicidad del código de arriba es que el
		manejo de errores es automático.</para>

		<para>Mientras se hacen todas esas cosas, las excepciones se pueden
		lanzar. A no ser que haya una buena razón para capturar una excepción
		(p.ej. espera el error y no quiere que se muestre como un error)
		probablemente será suficiente que las excepciones sean lanzadas y
		escribir el código como si no existieran realmente. El comportamiento
		estándar es que las excepciones que hereden de
		<classname>EBox::Exceptions::Internal</classname> causen un mensaje de
		error genérico, mandando al usuario a consultar los registros si
		necesitase ver los detalles. Las subclases de
		<classname>EBox::Exceptions::External</classname> son mostradas
		textualmente, el uso más común para estas excepciones es cuando los
		datos introducidos por el usuario se validan.</para>

		<para></para>

		<para>The last bit you should learn is how to redirect requests to
		other CGIs. There are a few reasons why you could want to do that, e.g.
		you could write a CGI that takes some input parameters from the web
		browser, changes something in the module backend and then redirects
		the request to the CGI that displays the data. The CGI shown in <xref
		linkend='ex-http-params'/> does not call any mason template at all, it
		just changes the apache port and does nothing else. We want the user to
		see the same page they were seeing before changing the port, with the
		new value. <xref linkend='ex-http-redirect'/> shows the constructor for
		that CGI:</para>

		<example id='ex-http-redirect'>
			<title>Redirecting a request to a different CGI</title>
			<programlisting><![CDATA[sub new
	my $class = shift;
	my $self = $class->SUPER::new(@_);
	bless($self, $class);
	$self->{redirect} = "EBox/General";
	return $self;
}]]></programlisting>
		</example>

		<para>You can see that the constructor sets the
		<structfield>redirect</structfield> attribute to the URL of
		the page we want to redirect to. That's all there is to
		do, if <structfield>redirect</structfield> is set to some
		value, the parent class will do an HTTP redirect after the
		<methodname>_process</methodname> method returns.</para>

		<para>An HTTP redirect makes the browser issue a new HTTP request, so
		all the status data in the old request gets lost, but there are cases
		when you want to keep that data for the new CGI. This could be done
		passing GET parameters in the redirect URL, but it is simpler to do an
		internal redirect, without going through the browser.</para>

		<para> If you need to keep data, like a message or warning to the user,
		you can use the <structfield>chain</structfield> attribute. It works
		exactly the same way as <structfield>redirect</structfield> but instead
		of sending an HTTP response to the browser, the parent class parses the
		URL, instantiates the matching CGI, copies all data into it and runs
		it. Messages and errors are copied automatically, the parameters in
		the HTTP request are not, since an error caused by one of them could
		propagate to the next CGI.</para>

		<!-- FIXME - example -->

		<para> If you need to keep HTTP parameters you can use the
		<methodname>keepParam</methodname> method in the parent class. It
		takes the name of the parameter as an argument and adds it to the
		list of parameters that will be copied to the new CGI if a "chain" is
		performed.</para>

		<!-- FIXME - example -->

		<para>Errors are a special case here, when an error happens you don't
		want redirects at all, as the error message would be lost. If an error
		happens and <structfield>redirect</structfield> has been set, then
		that value is used as if it was <structfield>chain</structfield>.
		However, sometimes you want to chain to a different CGI if there is
		an error, for example if the cause of the error is the absence of an
		input parameter necessary to show the page. If that's the case you
		can set the <structfield>errorchain</structfield> attribute, which
		will have a higher priority than <structfield>chain</structfield> and
		<structfield>redirect</structfield> if there's an error.</para>

		<para>Finally, the last detail there is to know about CGIs is how to
		make i18n work properly, both in the CGIs themselves and in mason
		templates. Since your module will not have the same gettext domain a
		the eBox framework, the framework needs to know your domain so that it
		can set it before calling your CGI and your template. It is as simple
		as passing it as an argument to the parent's constructor, the "Hello
		world" constructor in <xref linkend='ex-cgi-hello'/> would look like
		this:</para>

		<example id='ex-cgi-domain'>
			<title>Setting the gettext domain in a CGI</title>

			<programlisting><![CDATA[sub new 
{
	my $class = shift;
	my $self = $class->SUPER::new('title' => __('Hello World!'),
					'domain' => 'ebox-hello',
					@_);
	bless($self, $class);
	return $self;
}]]></programlisting>
		</example>

		<para>
		If your title is translatable you should set it again in the
		<function>_process</function> function, like:
		<programlisting>
$self->{title} = __('Hello world');
		</programlisting>
		otherwise it will not be translated correctly.
		</para>

		<para>
		On the other hand, note that you should never use <function>__</function>
		with non translatable strings, like protocol names (i.e., DHCP, NTP, ...).
		</para>

	</section>

	<section id="sect-mason">
		<title>Mason templates</title>

		<para>This section will only cover a few basic aspects of writing
		mason templates, specially those details related to eBox. If you need
		complete documentation about a certain aspect you should check the
		<ulink url='http://www.masonhq.com/'>mason documentation</ulink> or the
		<ulink url='http://www.masonbook.com/'>mason book</ulink>. Additional
		examples can be found in <xref linkend='ch-examplemod'/>.</para>

		<para>The first thing your mason template will have is the declarations
		of the arguments it expects. Just write the name of the variables, one
		per line and you are done. Arguments declared as arrays in the template
		will be passed as array references by your CGI.</para> 

		<para> In our example we are going to give the template an array with
		names, and the template will say hello to each one of them separately.
		We use an empty array as a default value for the variable, although
		default values are optional. If none is given and you don't pass that
		argument to the template an exception will be thrown.</para>

		<example>
			<title>Declaring arguments in a mason template</title>

			<programlisting><![CDATA[<%args>
	@people => ()
</%args>]]></programlisting>
		</example>

		<para>The next thing is the initialization section, in this
		section we can write regular perl code. It is optional and most
		of the times not needed. However all eBox templates have one,
		because there is always the need to have i18n, so we import
		<classname>EBox::Gettext</classname>:</para>

		<example>
			<title>init section in mason templates</title>

			<programlisting><![CDATA[<%init>
use EBox::Gettext;
</%init>]]></programlisting>
		</example>

		<para>Now we can go on and write the body of the template. The idea is
		to just write HTML and use a couple of syntactic features to insert
		perl code wherever we need. First, we'll learn how to do control flow.
		All lines that start with a <literal>%</literal> are interpreted as
		perl code.</para>

		<example>
			<title>Embedding perl code in a mason template</title>
			<programlisting><![CDATA[<ul>
% foreach my $person (@people) {
	<li>Hello</li>
% }
</ul>]]></programlisting>
		</example>

		<para>We want to print the name of a person in each list item.
		Embedding perl expressions in the special tags <literal>&lt;%
		%&gt;</literal> prints the value of the expression in the output of
		the template. We are going to use this feature to print the name of
		the person and translate the "Hello" string (internationalization is
		explained in <xref linkend='sect-i18n'/>).</para>

		<example>
			<title>Printing strings in a mason template</title>
			<programlisting><![CDATA[<ul>
% foreach my $person (@people) {
	<li><% __('Hello') %> <% $person %></li>
% }
</ul>]]></programlisting>
		</example>

		<para>The ebox m4 macro exports the installation path for
		mason templates as <varname>TEMPLATESPATH</varname>, so you
		should install them under that directory, possibly creating a
		subdirectory for your module. Whenever you need to reference
		a template in your code, you can just use a path relative to
		<varname>TEMPLATESPATH</varname>. Following our example, will use a
		subdirectory named <filename>hello</filename> for our templates, and
		place a template called <filename>world.mas</filename> in it.</para>

		<section id='sect-gui-style'>
			<title>Standard GUI elements</title>

			<para>There are a few GUI elements that are displayed the same way
			in all eBox modules. Things like tips, messages, warnings, errors,
			tables and forms keep a common style. All this stuff is defined in
			the CSS file, so that all modules can show a consistent look and
			feel. Some of these elements have a dynamic behavior too, the tips
			are hidden when the page is loaded and shown if the user clicks on
			a link on the top-right corner of the page. This section gives an
			overview of all of these elements and how to use them to achieve an
			user interface that is consistent with all other eBox modules.</para>

			<para>Toda información que queramos mostrar al usuario, ya sea para
			advertirle que una operación tiene riesgo, notificarle un error,
			mostrarle ayuda o darle una información relevante la escribiremos
			siguiendo el mismo esquema en html pero usando diferentes estilos 
			CSS.</para>

			<example>
				<title>Esquema html para mostrarle información al usuario</title>
				<programlisting><![CDATA[<div class='class-name'>
	Mensaje para el usuario.
</div>]]></programlisting>
			</example>

			<variablelist>
				
				<title>Nombres de clases CSS para mostrarle información al usuario</title>

				<varlistentry>

					<term><emphasis>help</emphasis></term>	

					<listitem>
						<para>Para mostrar ayuda al usuario. Recordemos que al usar este
						estilo la ayuda aparecerá oculta al usuario hasta que el decida que
						sea visible.</para>
					</listitem>

				</varlistentry>

				<varlistentry>

					<term><emphasis>error</emphasis></term>	

					<listitem>
						<para>Para notificar un error al usuario.</para>
					</listitem>

				</varlistentry>

				<varlistentry>

					<term><emphasis>note</emphasis></term>	

					<listitem>
						<para>Para notificar al usuario ayuda de forma permanente. Cuando
						queremos que el usuario conozca una determinada información sin
						necesidad de activar la ayuda.</para>
					</listitem>

				</varlistentry>

				<varlistentry>

					<term><emphasis>warning</emphasis></term>	

					<listitem>
						<para>Para mostrar advertencias al usuario, por ejemplo, si queremos
						advertirle cuando va a borrar un determinado dato.</para>
					</listitem>

				</varlistentry>

			</variablelist>

			<para>Si queremos mostrar un listado de datos, por ejemplo un listado de
			usuarios, usamos una tabla con los elementos <sgmltag>thead</sgmltag> y
			<sgmltag>tbody</sgmltag> para mostrar la cabecera del listado y su
			contenido respectivamente. El estilo CSS para esta tabla es 
			<emphasis>dataTable</emphasis>.</para>

			<example>
				<title>Tabla de listado de datos</title>
				<programlisting><![CDATA[<table class='dataTable'>
	<caption><% __('Object List') %></caption>
	<thead>
		<tr>
			<th class='tleft'><% __('Name') %></th>
			<th class='thOptions'><% __('Action') %></th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td></td>
			<td class='tcenter'>
				<a href='Del?objectname=<% $obj->{'name'} %>'>
						<img src='/data/images/delete.gif'
						     title="<% __('Delete') %>"
						     alt="<% __('Delete') %>"/>
				</a>
			</td>
		</tr>
	</tbody>
</table>]]></programlisting>
			</example>

			<para>Como vemos en el ejemplo la tabla tiene una etiqueta
			<sgmltag>caption</sgmltag> para especificar el título de la tabla, no es
			obligatorio pero es de ayuda para identificar el tipo de datos que estamos
			listando.</para>

			<para>El resto de estilos CSS se usan para alinear el texto de las 
			columnas:</para>

			<variablelist>
				
				<varlistentry>

					<term><emphasis>tleft</emphasis></term>

					<listitem>
						<para>Las columnas de cabecera (<emphasis>thead</emphasis>) tienen
						por defecto la alineación en el centro, nosotros obligamos a que sea
						a la izquierda para facilitar la lectura en los listados de 
						datos.</para>
					</listitem>

				</varlistentry>

				<varlistentry>

					<term><emphasis>tcenter</emphasis></term>

					<listitem>
						<para>Las acciones que podemos ejectutar sobre cada fila de un
						listado se alinean en el centro con este estilo.</para>
					</listitem>

				</varlistentry>

				<varlistentry>

					<term><emphasis>thOptions</emphasis></term>

					<listitem>
						<para>Ajusta el tamaño de la columna al mínimo necesario y alinea el
						texto en el centro.</para>
					</listitem>

				</varlistentry>

			</variablelist>

			<para>Para mostrar un formulario usamos una tabla de dos columnas con el
			estilo <emphasis>formTable</emphasis>.</para>

			<example>
				<title>Formulario de entrada de datos</title>
				<programlisting><![CDATA[<table class='formTable'>
	<tr>
		<td class='tright'>
			<span class='ftitle'><% __('Name') %>:</span>	
		</td>
		<td>
			<input class='inputText' type='text' name='name' />
		</td>
	</tr>
	<tr>
		<td></td>
		<td>
			<input class='inputButton' type='submit' />
		</td>
	</tr>
</table>]]></programlisting>
			</example>

			<para>La primera columna contiene la descripción correspondiente al dato 
			que vamos a introducir. Alineamos la columna de la descripción a la 
			derecha usando la clase <emphasis>tright</emphasis>, y el texto lo 
			escribimos dentro de la etiqueta <sgmltag>span</sgmltag> con la clase
			<emphasis>ftitle</emphasis> para resaltarlo más.</para>

			<para>La entrada de texto en la columna derecha tiene la clase
			<emphasis>inputText</emphasis> para decorar la caja de entrada de 
			texto.</para>

			<para>El botón del formulario tiene el estilo
			<emphasis>inputButton</emphasis> con un propósito meramente 
			decorativo.</para>

		</section>

	</section>

	<section id="sect-menu">
		<title>El menu</title>

		<para>El menú en el interfaz de la administración es dinámicamente
		generado, permitiendo a todos los módulos instalados añadir nuevos
		objetos y carpetas a él. Hay un juego de clases bajo el espacio de
		nombres <classname>EBox::Menu</classname> que pueden ser utilizadas
		para construir las estructuras del menú. Las importantes son
		<classname>EBox::Menu::Item</classname> y
		<classname>EBox::Menu::Folder</classname>.</para>

		<para>El constructor para <classname>EBox::Menu::Item</classname> toma
		dos argumentos nombrados <parameter>text</parameter> y
		<parameter>url</parameter>. <parameter>url</parameter> debería ser
		relativo a la ruta raíz para el interfaz de configuración, por
		ejemplo, la página de filtrado de paquetes del firewall tiene
		<uri>Firewall/Filter</uri> como su <parameter>url</parameter>.</para>

		<para>El constructor de <classname>EBox::Menu::Folder</classname> no
		toma el argumento <parameter>url</parameter>, pero toma el
		<parameter>name</parameter>. El nombre es utilizado internamente como
		un identificador en la implementación del menú javascript.</para>

		<para>Ambos elementos y carpetas tienen un argumento opcional
		<parameter>order</parameter> en sus constructores, que debería ser un
		entero entre 1 y 10. Los elementos del menú están ordenador desde los
		valores más bajos a los más altos. El valor por defecto es 5.</para>

		<para>Una carpeta puede contener elementos, por lo que se pueden
		añadir instancias de <classname>EBox::Menu::Item</classname> a
		<classname>EBox::Menu::Folder</classname>.</para>

		<para>Finalmente, la forma de añadir elementos del menú y/o carpetas
		al menú es simplemente implementar la función
		<methodname>menu</methodname> en el módulo. Esta función toma una
		instancia <classname>EBox::Menu::Root</classname> como argumento, y
		puede añadir tantos elementos y carpetas como se quieran. Esta es la
		función <methodname>menu</methodname> para el módulo firewall:</para>		

		<example>
			<title>Añadiendo carpetas y elementos al menú</title>
			<programlisting><![CDATA[sub menu
{
	my ($self, $root) = @_;
	my $folder = new EBox::Menu::Folder('name' => 'Firewall',
				'text' => __('Firewall'),
				'order' => 4);

	$folder->add(new EBox::Menu::Item('url' => 'Firewall/Filter',
				'text' => __('Packet Filter')));
	$folder->add(new EBox::Menu::Item('url' => 'Firewall/Redirects',
				'text' => __('Redirects')));

	$root->add($folder);
}]]></programlisting>
		</example>

		<!-- FIXME - screenshot -->

	</section>

	<section id="sect-summarypage">
		<title>Resumen</title>

		<para>La interfaz de usuario de eBox tiene  una página "Resumen" donde
		se muestra la información del estado de cada módulo. Esta página tiene
		dos partes:</para>

		<itemizedlist>
			<listitem>
				<para>La primera parte es una tabla con el estado de
				todos los servicios de red instalados: si están
				ejecutándose o no y los botones correspondientes para reiniciarlos.</para>
			</listitem>

			<listitem>
				<para>La segunda parte de la página tiene una sección
				separada para cada módulo, donde se puede mostrar una
				información más detallada.</para>
			</listitem>
		</itemizedlist>

		<!-- FIXME  screenshot -->

		<para>La información del resumen es recogida llamando a dos funciones
		abstractas definidas en <classname>EBox::Module</classname>, si no
		desea implementarlas, entonces no se mostrará información sobre ese
		módulo. <methodname>statusSummary</methodname> rellena la tabla en la
		que se mostrará el estado de los servicios de red y
		<methodname>summary</methodname> crea la sección resumen para el módulo.</para>

		<para>La forma en que el resumen está construido es muy parecida a la
		forma en que lo está el menú, como se puede ver en <xref
		linkend='sect-menu'/>. Hay unas cuantas clases en el espacio de
		nombres <classname>EBox::Summary</classname> que se pueden usar para
		construir la información de
		resumen. <methodname>statusSummary</methodname> debería devolverun
		objeto de tipo <classname>EBox::Summary::Status</classname> mientras
		que <methodname>summary</methodname> es libre de devolver cualquier
		objeto cuyo tipo sea un suptipo de
		<classname>EBox::Summary::Item</classname>, aunque la mayor parte de
		los módulos sólo devuelvan un
		<classname>EBox::Summary::Module</classname>.</para>

		<para>Cada uno de las subclases de
		<classname>EBox::Summary::Item</classname> tiene algunos atributos y
		pueden contener otros objetos
		<classname>EBox::Summary::Item</classname>, y que todos ellos saquen
		algo de código HTML. <classname>EBox::Summary::Module</classname>
		tiene un atributo <structfield>title</structfield>, que cuando llega
		el momento de generar la página muestra el título
		<structfield>title</structfield> y el html para sus hijos por debajo
		suyo.</para>

		<para>Para ver como está construida la sección resumen, vamos a echar
		un vistazo al módulo network. La salida de su resumen es un título y
		una sección por cada interfaz de red, con un título en negrita y una
		tabla que muestra su dirección MAC, dirección IP, máscara de red,
		etc. <xref linkend='ex-network-summary'/> muestra las partes
		importantes de su función <methodname>summary</methodname>.</para>

		<example id='ex-network-summary'>

			<title>Implementación de ejemplo de <methodname>summary</methodname></title>

			<programlisting><![CDATA[my $item = new	EBox::Summary::Module(__("Interfaces de red"));

foreach my $iface (@{$ifaces}) {
	my $status = __("down");
	my $section = new EBox::Summary::Section($iface);
	$item->add($section);

	if (iface_is_up($iface)) {
		$status = __("up");
	}
	$section->add(new EBox::Summary::Value (__("Status"), $status));

	my $ether = iface_mac_address($iface);
	if ($ether) {
		$section->add(new EBox::Summary::Value(
			__("dirección MAC"), $ether));
	}

	my @ips = iface_addresses($iface);
	foreach my $ip (@ips) {
		$section->add(new EBox::Summary::Value(
			__("dirección IP"), "$ip"));
	}
}
return $item;]]></programlisting>
		</example>

		<!-- FIXME screenshot -->

		<para>Primero se crea un objeto
		<classname>EBox::Summary::Module</classname>. Éste objeto mantendrá
		toda la información del resumen.</para>

		<para>

		<para> Then an <classname>EBox::Summary::Section</classname>
		is created for each network interface, a section has a title
		(passed as an argument to its constructor) and it contains several
		<classname>EBox::Summary::Value</classname> objects, which display a
		name and an associated value as rows in a table within the section.
		So each several values are added to each section and the sections
		are added to the <classname>EBox::Summary::Module</classname>
		object. The result is a tree of objects, and its root is the
		<classname>EBox::Summary::Module</classname>, when it is asked to print
		itself it prints its title and asks each of its children to print
		itself. To see what it looks like just open the summary page in an eBox
		installation.</para>

		<!-- FIXME - screenshot -->

		<para><methodname>summary</methodname> may return any object as long as
		it inherits from <classname>EBox::Summary::Item</classname>, you can
		create your own if your needs are not covered by the standard items
		that come with the framework.</para>

		<para><methodname>statusSummary</methodname> is easier, it just has
		to return an <classname>EBox::Summary::Status</classname> object.
		The constructor for this class needs three arguments:</para>

		<itemizedlist>

			<listitem>
				<para>The name of the service.</para>
			</listitem>

			<listitem>
				<para>A boolean indicating whether the service is running.</para>
			</listitem>

			<listitem>
				<para>A boolean indicating whether the service is enabled or not.</para>
			</listitem>
		</itemizedlist>

		<para> The reason for this third argument is that services that the
		user should not be able to use the summary page to start services that
		have not been configured, so if, for example, the squid service is
		disabled, the user will have to go to the squid configuration page and
		enable the service there. <xref linkend='ex-squid-status'/> shows the
		<methodname>statusSummary</methodname> implementation in the squid
		module, along with some related methods.</para>

		<example id='ex-squid-status'>

			<title>Ejemplo de implementación de
			<methodname>statusSummary</methodname></title>

			<programlisting><![CDATA[sub statusSummary
{
	my $self = shift;
	return new EBox::Summary::Status('squid', __('Proxy HTTP'),
					$self->isRunning, $self->service);
}

sub isRunning
{
	my $self = shift;
	return $self->pidFileRunning(PIDFILE);
}

sub service
{
	my $self = shift;
	return $self->get_bool('active');
}]]></programlisting>

		</example>
		
		<para>De nuevo, se puede comprobar como se ve en la página de Resumen
		en una instalación de eBox que tiene el módulo squid incluido.</para>

	</section>

</chapter>
