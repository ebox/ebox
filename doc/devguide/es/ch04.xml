<!-- vim: ts=2 sw=2 tw=75
-->
<chapter id="ch-interacting">

	<title>Interactuando con otros componentes</title>

	<section id="sect-interacting-intro">
		<title>Introducción</title>

		<para>Hay tres razones diferentes por las cuales tu módulo puede
		necesitar interactuar con otros módulos:</para>

		<itemizedlist>

			<listitem>

				<para>El caso más simple es sólo la necesidad de
				cambiar alguna configuración de otro módulo utilizando
				su API. Un ejemplo de esto son todos los módulos que
				ofrecen servicios de red. Todos ellos necesitan
				decirle al firewall en que puerto van a estar
				escuchando, para que pueda mostrar todos los servicios
				en la configuración del interfaz, dejando al usuario
				que elija quien hace uso de cada uno. Este caso es
				trivial, sólo cree una instancia del módulo que quiera
				llamar y use su API para lo que necesite.</para>

			</listitem>

			<listitem>

				<para>El segundo caso son las dependencias. Una
				dependencia se observa cuando un módulo mantiene una
				referencia a partes de la configuración manejada por
				otros módulos y necesita reiniciarse cuando los otros
				módulos cambian la configuración. Un ejemplo de este
				caso es el firewall, te deja definir reglas por cada
				objeto de red definido en el modulo objects. Sin
				embargo si crea reglas para un objeto, y entonces usa
				el interfaz de usuario de objects para añadir nuevos
				miembros a ese objeto, el firewall necesitaría
				reiniciarse también, para que esas reglas creadas se
				apliquen también al nuevo objeto. Esta situación es
				muy sencilla de manejar, el firewall declara una
				dependencia en el módulo network en su esquema de
				GConf y entonces la plataforma automáticamente
				reinicia el módulo firewall cuando el módulo objects
				es reiniciado. La declaración de dependencias está
				explicada en <xref linkend='sect-schemas'/></para>

			</listitem>

			<listitem>

				<para>Finalmente, la situación más compleja es cuando
				alguna información de la configuración del módulo en
				desarrollo depende de la configuración de otros. En el
				ejemplo del firewall, ¿que pasaría si se borrase el
				objeto para el cual se han definido ciertas reglas?
				Este tipo de situación requiere cooperación entre
				ambos módulos para que puedan ofrecer un
				comportamiento consistente al usuario. Esto es sobre
				lo que trata todo este capítulo. Las siguientes
				secciones describirán como los módulos objects,
				firewall y network resuelvan este problema (estos
				módulos son los, normalmente, más necesitados por
				otros), y mostrará como resolver este problema en
				nuestros propios desarrollos de módulos.</para>

        </listitem>

		</itemizedlist>

		<section id='sect-observers-intro'>
			<title>Observers</title>

			<para>Suponga que está escribiendo un módulo DHCP y desea
			configurar el servicio DHCP con una base distinta por cada
			interfaz de red. Sin embargo, no a todos los interfaces se les
			debe permitir tener un demonio DHCP corriendo en ellos. Si el
			usuario configura el interfaz eth1 como cliente DHCP, entonces
			no tiene sentido dejarle configurar un servidor DHCP en dicho
			interfaz. Así que, se decide que las páginas de configuración
			de DHCP sólo mostrarán los interfaces de red que tengan
			configurada una IP estática. Eso está bien, pero ¿que pasaría
			si el usuario configura el servicio DHCP en un interfaz
			estático y más tarde intenta cambiar el interfaz a DHCP o sin
			nada?</para>

			<para>Aquellos módulos que pudieran informar a otros módulos
			sobre ciertos eventos definen clases abstractas
			<emphasis>observer</emphasis>, las cuales otros módulos pueden
			extender si ellos necesitan ser notificados cuando ocurran
			tales eventos. El módulo network provee de la clase
			<classname>EBox::NetworkObserver</classname> para este
			propósito. Esta clase tiene varias funciones abstractas, por
			lo que el módulo podría implementar cualquiera de estas
			funciones y ser notificado cuando un evento relevante sucediera.</para>

			<!-- FIXME - example? diagram? -->

		</section>

	</section>

	<section id="sect-objectsmod">
		<title>Módulo objects</title>

		<para>El módulo objects mantiene una lista de objetos de red creada
		por el usuario. Estos objetos pueden contener cualquier número de
		direcciones IP y bloques CIDR.</para>

		<para>Su interfaz es muy simple. La clase
		<classname>EBox::ObjectObserver</classname> tiene dos funciones
		abstractas que deben ser implementadas por los módulos que hacen uso
		del módulo objects:</para>

		<variablelist>

			<varlistentry>
				<term><methodname>usesObject</methodname></term>
				<listitem>

					<para>Recibe el nombre de un objeto como
					argumento y devuelve <literal>true</literal>
					si el módulo está haciendo uso del objeto dado
					en su configuración, y
					<literal>false</literal> en caso contrario.</para>

				</listitem>
			</varlistentry>

			<varlistentry>
				<term><methodname>freeObject</methodname></term>
				<listitem>

					<para>También recibe el nombre de un objeto
					como argumento. Este método le dice al módulo
					que el usuario ha pedido la eliminación del
					objeto dado (incluso si estaba siendo usado
					por los otros módulos). El módulo debería
					borrar todas las referencias al objeto en su
					configuración cuando se llame a
					<methodname>freeObject</methodname>.</para>

				</listitem>
			</varlistentry>

		</variablelist>

		<para>Como ejemplo, aquí está la implementación de ambas funciones en
		el módulo firewall:</para>

		<example>
			<title>Implementación de la clase
				<classname>EBox::ObjectsObserver</classname></title>

			<programlisting><![CDATA[sub usesObject # (object)
{
	my ($self, $object) = @_;
	defined($object) or return undef;
	($object ne "") or return undef;
	return $self->dir_exists("objects/$object");
}

sub freeObject # (object)
{
	my ($self, $object) = @_;
	defined($object) or return;
	($object ne "") or return;
	$self->delete_dir("objects/$object");
}]]></programlisting>

		</example>

	</section>

	<section id="sect-networkmod">
		<title>Módulo network</title>

		<para>El caso de network es más complejo. Hay varios cambios
		potenciales en la configuración de la red que otros módulos podrían
		necesitar conocer. <classname>EBox::NetworkObserver</classname> tiene
		cuatro funciones que el módulo network llama cuando se hacen distintos
		tipos de cambios, y dos funciones que avisan a los módulos para que
		eliminen las referencias a ciertos interfaces de red de sus
		configuraciones:</para>

		<variablelist>

			<varlistentry>
				<term><methodname>staticIfaceAddressChanged</methodname></term>
				<listitem>

					<para>Se llama cuando la dirección de un
					interfaz estático de red va a cambiarse. Este
					método recibe las direcciones antigua y nueva
					y sus respectivas máscaras como argumentos. La
					devolución de un valor <literal>true</literal>
					significa que la configuración de este módulo
					pasaría a ser inconsistente si tal cambio se
					hiciese. En ese caso el módulo de red no haría
					el cambio, pero en vez de eso, avisaría al
					usuario.</para>

				</listitem>
			</varlistentry>

			<varlistentry>
				<term><methodname>ifaceMethodChanged</methodname></term>
				<listitem>

					<para>Se le llama cuando la forma de
					configurar un interfaz va a cambiar. Tanto la
					forma anterior como la nueva, son pasadas como
					argumentos para esta función. Son cadenas:
					<literal>static</literal>,
					<literal>dhcp</literal>,
					<literal>trunk</literal> o
					<literal>notset</literal>. Como en la función
					anterior, la devolución de un valor
					<literal>true</literal> prevendrá de que el
					cambio se produzca.</para>

					</listitem>
			</varlistentry>

			<varlistentry>
				<term><methodname>vifaceAdded</methodname></term>
				<listitem>

					<para>Se llama cuando un nuevo interfaz
					virtual se va a crear. Sus argumentos son el
					interfaz real al cual se le va a añadir, el
					nombre del nuevo interfaz, su dirección IP y
					su máscara de red. Funciona de la misma forma:
					devolverá <literal>true</literal> si la
					creación del interfaz virtual es incompatible
					con la configuración actual del módulo.</para>

				</listitem>
			</varlistentry>

			<varlistentry>
				<term><methodname>vifaceDelete</methodname></term>
				<listitem>

					<para>Se le llama cuando un interfaz virtual
					va a ser eliminado. Sus argumentos son los
					nombres del interfaz real y el
					virtual. Funciona de la misma forma que para
					las tres funciones que acabamos de
					describir.</para>

				</listitem>
			</varlistentry>

			<varlistentry>
				<term><methodname>freeIface</methodname></term>
				<listitem>

					<para>Le pide eliminar todas las referencias a
					un interfaz de red, de la configuración. Es
					normalmente llamada después de devolver
					<literal>true</literal> en uno de las
					funciones arriba descritas y el usuario
					insistió en hacer el cambio que estaba
					intentando hacer.</para>

				</listitem>
			</varlistentry>

			<varlistentry>
				<term><methodname>freeViface</methodname></term>
				<listitem>

					<para>Idéntica situación que en
					<methodname>freeIface</methodname>, pero para
					los interfaces virtuales.</para>

				</listitem>
			</varlistentry>

		</variablelist>

		<para><xref linkend='ex-network-observer'/> muestra la implementación
		de las funciones <classname>EBox::NetworkObserver</classname> en el
		módulo firewall.</para>

		<example id='ex-network-observer'>

			<title>Implementando un	<classname>EBox::NetworkObserver</classname></title>

			<programlisting><![CDATA[sub ifaceMethodChanged # (iface, oldmethod, newmethod)
{
	 my ($self, $iface, $oldm, $newm) = @_;

	 ($newm eq 'static') and return undef;
	 ($newm eq 'dhcp') and return undef;

	 return $self->usesIface($iface);
}

sub vifaceDelete # (iface, viface)
{
	 my ($self, $iface, $viface) = @_;
	 return $self->usesIface("$iface:$viface");
}

sub usesIface # (iface)
{
	 my ($self, $iface) = @_;
	 my @reds = $self->all_dirs("redirections");
	 foreach (@reds) {
		  if ($self->get_string("$_/iface") eq $iface) {
			   return 1;
		  }
	 }
	 return undef;
}

sub freeIface # (iface)
{
	 my ($self, $iface) = @_;
	 $self->removePortRedirectionOnIface($iface);
}

sub freeViface # (iface, viface)
{
	 my ($self, $iface, $viface) = @_;
	 $self->removePortRedirectionOnIface("$iface:$viface");
}]]></programlisting>

		</example>

	</section>

	<section id="sect-firewallmod">
		<title>Módulo firewall</title>

		<para>Los módulos firewall necesitan permitir que otros módulos
		inserten reglas NAT y de filtrado a medida. Tiene un API limitado que
		permite a los módulos modificar las reglas de filtrado. Por ejemplo,
		si un módulo necesita conectar a servidores HTTP de internet, llamaría
		a <methodname>addOutputRule</methodname> y el firewall abriría los
		puertos necesarios.</para>

		<para>Sin embargo, este mecanismo no es muy flexible desde que hay
		módulos con necesidades muy específicas. El módulo squid necesita
		configurar varias reglas NAT y de filtrado para su funcionar
		transparentemente.</para>

		<para>La clase <classname>EBox::FirewallObserver</classname> fue
		creada para estos casos más complejos. Cuando el firewall se reinicia
		pide a todos los módulos que heredan de
		<classname>EBox::FirewallObserver</classname> para ver si necesitan
		insertar sus propias reglas. Los módulos pueden insertar cualquier
		regla que quieran, con la sintaxis de
		<application>iptables</application>. La única cosa que no pueden
		controlar es donde exactamente son colocadas esas reglas. Los módulos
		de firewall tienen varios enganches a través de las distintas cadenas
		y tablas donde ponen estas reglas a medida.</para>

		<para><classname>EBox::FirewallObserver</classname> define dos
			funciones:</para>

		<itemizedlist>
			<listitem>
				<para><methodname>firewallHelper</methodname></para>
			</listitem>
			<listitem>
				<para><methodname>usesPort</methodname></para>
			</listitem>
		</itemizedlist>

		<para><methodname>firewallHelper</methodname> debería devolver
		<literal>undef</literal> (el comportamiento por defecto) o un objeto
		de tipo <classname>EBox::FirewallHelper</classname>. Esta clase define
		varias funciones que deberían devolver reglas que el firewall
		insertaría en cada uno de los enganches definidos para este propósito.</para>

		<para>La sintaxis de las reglas provistas por los módulos es simple:
		sólo utilizan la misma sintaxis que se usaría en la línea de comandos
		de <application>iptables</application>, pero excluyendo la cadena,
		tabla y el comando <application>iptables</application> al principio:</para>

		<para>Estas son las funciones definidas en
		<classname>EBox::FirewallHelper</classname>, cada uno de ellos para
		cada tipo distinto de reglas, todos ellos devuelven una referencia a
		un array que contienen las reglas:</para>

		<variablelist>

			<varlistentry>
				<term><methodname>prerouting</methodname></term>
				<listitem>

					<para>Las reglas devueltas por esta función
					son añadidas a la cadena
					<literal>PREROUTING</literal> en la tabla
					<literal>nat</literal>. Puedes usarlas para
					hacer NAT en la dirección de destino de los paquetes.</para>

				</listitem>
			</varlistentry>

			<varlistentry>
				<term><methodname>postrouting</methodname></term>
				<listitem>

					<para>Las reglas devueltas por esta función
					son añadidas a la cadena <literal>POSTROUTING>
					en la tabla <literal>nat</literal>. Puedes
					usarla para hacer NAT en la dirección de
					origen de los paquetes.</literal></para>

				</listitem>
			</varlistentry>

			<varlistentry>
				<term><methodname>forward</methodname></term>
				<listitem>

					<para>Las reglas devueltas por esta función se
					añadirán a la cadena
					<literal>FORWARD</literal> en la tabla
					<literal>filter</literal>. Puedes usarlas para
					filtrar paquetes a través del firewall.</para>

				</listitem>
			</varlistentry>

			<varlistentry>
				<term><methodname>input</methodname></term>
				<listitem>

					<para>Las reglas devueltas por esta función
					son añadidas a la cadena
					<literal>INPUT</literal> en la tabla
					<literal>filter</literal>. Puedes usarlas para
					filtrar paquetes dirigidos directamente al firewall.</para>

				</listitem>
			</varlistentry>

			<varlistentry>
				<term><methodname>output</methodname></term>
				<listitem>

					<para>Las reglas devueltas por este método son
					añadidas a la cadena <literal>OUTPUT</literal>
					en la tabla <literal>filter</literal>. Puedes
					usarlos para filtrar paquetes originados en el
					propio firewall.</para>

				</listitem>
			</varlistentry>

		</variablelist>

		<warning>
			<para>Debe ser cauteloso con las reglas del firewall que se
			escriban, ya que pueden abrir importantes agujeros de
			seguridad en eBox.</para>
		</warning>

		<para>Si necesita más información sobre como
		<application>iptables</application> y
		<application>Netfilter</application> trabajan, consulte el <ulink
		url='http://netfilter.org/documentation/HOWTO/NAT-HOWTO.html'>Howto de
		NAT</ulink> y el <ulink
		url='http://netfilter.org/documentation/HOWTO/packet-filtering-HOWTO.html'>
		Howto de Packet filtering</ulink> en el sitio web de Netfilter.<xref
		linkend='ex-fw-helper'/> muestra la implementación de la función
		<methodname>output</methodname> en
		<classname>EBox::FirewallHelper</classname> definida en el módulo squid.</para>

		<example id='ex-fw-helper'>
			<title>Creando reglas de firewall a medida</title>

				<programlisting><![CDATA[sub output
{
        my $self = shift;
        my $sq = EBox::Global->modInstance('squid');
        my @rules = ();
        push(@rules, "-m state --state NEW -p tcp --dport 80 -j ACCEPT");
        push(@rules, "-m state --state NEW -p tcp --dport 443 -j ACCEPT");
        return \@rules;
}]]></programlisting>
			</example>

		<para><methodname>usesPort</methodname> acepta tres argumentos:
		<parameter>protocol</parameter>, <parameter>port</parameter> y
		<parameter>network interface</parameter>. Esta función se usa para
		preguntar a los módulos si utilizan un puerto tcp o udp concreto. Le
		permite al firewall conocer si es una buena idea permitir o no la
		creación de la redirección de un puerto. Devuelve
		<literal>true</literal> si el módulo utiliza el puerto dado y
		<literal>undef</literal> en otro caso.</para>

	</section>

	<section id="sect-observers">
		<title>Definiendo nuevos observers</title>

		<para>Supongamos que estamos implementando un módulo mail con soporte
		para dominios virtuales, y queremos permitir a otros módulos saber
		cuando se borra un dominio virtual. Podríamos definir una clase
		abstracta llamada <classname>EBox::MailObserver</classname>, como esta:</para>

		<example>
			<title>Definiendo un observer que pueda ser implementado por
			otros módulos</title>

			<programlisting><![CDATA[package EBox::MailObserver;

use strict;
use warnings;

sub new
{
	my $class = shift;
	my $self = {};
	bless($self, $class);
	return $self;
}

# Cuando un dominio virtual se borra, se llama a este método.
sub virtualDomainDeleted # (domainName)
{}]]></programlisting>
			</example>

		<para>Cuando ocurre un evento importante, el módulo mail llamaría a la
		función <methodname>virtualDomainDeleted</methodname> en todos los
		módulos que hubiesen extendido la clase
		<classname>EBox::MailObserver</classname>:</para>

		<example>
			<title>Llamando a los módulos con un observer</title>

				<programlisting><![CDATA[sub removeVirtualDomain # (domainName)
{
	my ($self, $domain) = @_;

	#
	# do stuff
	#

	my $global = EBox::Global->getInstance();
	my @modules = @{$global->modInstancesOfType('EBox::MailObserver')};
	foreach my $mod (@modules) {
		$mod->virtualDomainDeleted($domain);
	}
}]]></programlisting>
			</example>

		</section>
</chapter>
