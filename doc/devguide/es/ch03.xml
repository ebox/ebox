<!-- vim: ts=2 sw=2
-->
<chapter id="ch-backend">

	<title>Backend del módulo</title>

	<simplesect>

		<para>La plataforma eBox ofrece unos módulos con ciertas
		funcionalidades que están disponibles a través de una API orientada a
		objetos en su mayor parte. No todo está orientado a objetos,
		interfaces procedurales se han usado cuando tenía sentido hacerlo.</para> 

		<para>Algunas de las características de la API funcionan a través de
		herencia, éstas normalmente ofrecen un medio para que el módulo
		implemente las funcionalidades estándar como los menús, la página de
		estado, el guardado de la configuración o su revocación, etc. Algunas
		de estas características necesitan ser implementadas por el módulo
		mientras que otras son completas en la plataforma, y el módulo puede
		extenderlas o sobreescribirlas.</para>

	</simplesect>

	<section id="sect-basemod">
		<title>El módulo base</title>

		<para>Todos los módulos de eBox heredan de la clase
		<classname>EBox::Module</classname>. Esta clase define funciones
		abstractas que los módulos sobreescribirán para implementar una cierta
		funcionalidad. Estas funciones son llamados por la plataforma cuando son
		necesarios.</para>

		<para>Ademas de estas funciones abstractas, la clase implementa unos
		pocas funcionescon algunas funcionalidades básicas. Estas últimas,
		siguen normalmente el método que define una plantilla de un
		patrón de diseño, es decir, realizan algunas operaciones pero delegan
		parte de ellas en alguna función abstracta que deberá ser implementada
		por la clase hija.</para>

		<!-- FIXME - class diagram -->

		<para>Finalmente, hay unas pocas funciones que implementan algunas
		operaciones comunes que son utilizadas por la mayoría de los módulos,
		están escritas para que sean llamadas por las clases hijas cuando se
		les necesita. Están situadas en la clase
		<classname>EBox::Module</classname> únicamente por conveniencia.</para>

		<section id="sect-modconstructor">
			<title>Constructor del módulo</title>

			<para>Todas las instancias del módulo son creadas y cacheadas
			por la clase <classname>Ebox::Global</classname>. Los
			constructores de un módulo no deben ser llamados directamente
			excepto por la clase <classname>EBox::Global</classname>. Por
			esta razón, se llaman <methodname>_create</methodname> en vez
			de <methodname>new</methodname>.</para>

			<para>El primer guión bajo en el nombre de la función es una
			convención de nombres. Las funciones con un nombre así están
			pensadas para ser usados de forma privada por su propia clase
			y por sus clases ascendentes. No deberían ser llamadas
			directamente por cualquier otra clase que no tenga una
			relación de este tipo. En el caso del constructor del módulo,
			la única clase que debería llamarlo es
			<classname>Ebox::Global</classname>.</para>

			<para>La función <methodname>_create</methodname> en
			<classname>EBox::Module</classname> recibe dos argumentos
			desde sus clases hijas. <parameter>name</parameter> es el
			nombre del módulo y es obligatorio;
			<parameter>domain</parameter>es el dominio
			<application>gettext</application> para el módulo, es
			opcional, y <quote>ebox</quote> es su valor por defecto.</para>

			<example>
				<title>Sencillo constructor de un módulo</title>
				<programlisting><![CDATA[sub _create
{
	my $class = shift;
	my $self = $class->SUPER::_create(name => 'dhcp',
					domain => 'ebox-dhcp',
					@_);
	bless ($self, $class);
	return $self;
}]]></programlisting>
			</example>

		</section>

	</section>

	<section id="sect-rootcmds">
		<title>Comandos de root</title>

		<para>El servidor apache bajo el que funciona eBox y cualquier otro
		script de perl que utilice el API de eBox, utilizan un id de usuario
		dedicado. El usuario es normalmente llamado <quote>ebox</quote>. Los
		módulos de eBox necesitan ejecutar ciertos comandos y escribir ciertos
		ficheros con privilegios de root, esto se hace usando
		<application>sudo</application>. El fichero de configuración de
		<application>sudo</application>, <filename>/etc/sudoers</filename>
		contiene una lista de los comandos que <application>sudo</application>
		permitirá al usuario ejecutar como root.</para>

		<para>Cuando un módulo se instala, se borra o se actualiza, la lista
		de comandos se ha de poner al día. eBox tiene el comando
		<command>ebox-sudoers</command> para generar fácilmente el fichero. El
		comando existe para ser llamado por los mantenedores de los paquetes
		en los scripts de post instalación o de desinstalación.</para>

		<para>Para que <command>ebox-sudoers</command> funcione, eBox necesita
		saber que comandos necesita cada uno de sus módulos. Para esto, la
		clase <classname>Ebox::Module</classname> tiene una función abstracta
		llamada <methodname>rootCommands</methodname>. Los módulos implementan
		esta función si quieren añadir nuevos comandos al fichero
		<filename>/etc/sudoers</filename>. Devolverá un array cuyos elementos
		serán los comandos que se deseen ejecutar. La implementación de este
		método en el módulo del firewall es algo así:</para>

		<example>
			<title>Definiendo comandos para ser ejecutados como root</title>
			<programlisting><![CDATA[sub rootCommands
{
	my $self = shift;
	my @array = ();
	push(@array, '/sbin/iptables');
	push(@array, '/sbin/sysctl -q -w net.ipv4.ip_forward*');
	return @array;
}]]></programlisting>
		</example>

		<para>Una vez que tiene definidos todos los comandos que necesita
		ejecutar como root en la función
		<methodname>rootCommands</methodname>, puede llamar a esos comandos
		utilizando la función <methodname>root()</methodname> en el módulo
		perl <classname>EBox::Sudo</classname>. Si el comando falla,
		<methodname>root()</methodname> lanza una excepción interna, para
		asegurarse de que sea capturada si es correcto que el comando falle o
		si desea informar al usuario de una forma distinta. Consulte la sección
		<xref linkend='sect-exceptions'/> para más detalles.</para>

		<!-- FIXME - example -->

	</section>

	<section id="sect-gconf">
		<title><classname>EBox::GConfModule</classname></title>

		<para>eBox utiliza GConf para almacenar su configuración. La
		plataforma de desarrollo ofrece un recubrimiento sobre los <ulink
		url='http://gtk2-perl.sourceforge.net/doc/pod/Gnome2/GConf.html'>
		bindings originales de perl</ulink>. GConf ofrece una sencilla API
		para almacenar y consultar configuración con valores clasificados por
		tipos y organizada jerarquicamente. También nos permite definir
		esquemas limitados para algunas claves de configuración, configurando
		sus tipos y valores por defecto.</para>

		<!-- FIXME - example -->

		<para>La plataforma de desarrollo define un recubrimiento sobre el API
		de GConf más algunas funcionalidades añadidas. El recubrimiento es
		implementado como una clase hija de
		<classname>Ebox::Module</classname>, así que todos los módulos que
		quieren usar GConf heredan de
		<classname>EBox::GConfModule</classname>. Sus hijos automáticamente
		adquieren estas características:</para>

		<itemizedlist>

			<listitem>

				<para>Copias de seguridad automáticos: La primera vez
				que la clave de un valor es modificada, se hace una
				copia de seguridad del árbol completo de configuración
				para ese módulo. Cuando la configuración se guarda, la
				copia de seguridad es automáticamente
				eliminada. Cuando los cambios en la configuración son
				descartados, la copia de seguridad es automáticamente
				recuperada. <classname>EBox::GConfModule</classname>
				implementa las funciones
				<methodname>makeBackup</methodname>,
				<methodname>restoreBackup</methodname> y
				<methodname>revokeConfig</methodname> definidas en la
				clase <classname>EBox::Module</classname>, por lo que
				las clases hijas de
				<classname>EBox::GConfModule</classname> no necesitan
				implementar estas funciones a no ser que se necesite
				algún requisito en especial o almacenar parte de su
				configuración fuera de GConf.</para>


			</listitem>
			<listitem>

				<para>Manejo de errores: Los errores de GConf son
				manejados por la clase recubridora. Ella los traduce
				a excepciones internas.</para>

			</listitem>
			<listitem>

				<para>Instancias de sólo-lectura y sólo-escritura:
				Cuando el módulo es instanciado en modo sólo-lectura,
				la clase recubridora utiliza una copia de la
				configuración para evitar ver que hay cambios sin
				guardar. También previene de llamadas a métodos que
				escriban en GConf.</para>

			</listitem>
			<listitem>

				<para>Comprobación de los límites del espacio de
				nombre: El recubrimiento comprueba todas las claves de
				GConf utilizadas por el módulo, para ver si están en
				su espacio de nombres. Esto asegura que las claves
				para un módulo sólo son leídas o escritas directamente
				por el propio módulo (siempre que todos los módulos
				utilicen esta clase recubridora).</para>

			</listitem>
			<listitem>

				<para>Rutas relativas: las funciones en la clase
				recubridora pueden recibir para las claves de gconf
				tanto rutas absolutas como relativas. La raíz del
				espacio de nombres de un módulo cambia dependiendo del
				tipo de instancia (sólo-lectura o lectura-escritura) y
				el tipo de clave (normal o de estado) a la cual se
				acceda. Por esta razón lo mejor es utilizar rutas
				relativas cuando se llamen a las funciones de la clase
				recubridora, ya que ellas traducen la ruta relativa en
				una ruta absoluta automáticamente.</para>

			</listitem>
			<listitem>

				<para>Estado del espacio de nombres: hay cierta
				información que no es suministrada por el usuario y
				que necesita ser escrita en cualquier momento, incluso
				en las instancias de sólo-lectura. Este tipo de
				información no está sujeta a guardar o cancelar la
				configuración. Es la información de estado, como los
				nombres de los servidores o la dirección IP dada por
				el sistema por un servidor DHCP externo. Un espacio de
				nombres aparte está disponible para este tipo de
				información, y de nuevo es automáticamente apartado de
				las operaciones de copia de seguridad, guardado y
				cancelación mencionadas anteriormente. Las funciones
				que suelen acceder a este espacio de nombres son
				idénticas a las normales, sólo que tienen el prefijo
				<literal>st_</literal> en sus nombres.</para>

			</listitem>

			<listitem>

				<para>Recuperación recursiva de directorios: hay dos
				funciones en <classname>EBox::GConfModule</classname>
				que permiten facilmente recuperar la estructura
				completa de
				directorios. <methodname>hash_from_dir</methodname>
				toma un directorio como argumento y devuelve un hash
				con todas las claves que están por debajo
				suyo. <methodname>array_from_dir</methodname> toma un
				directorio como argumento y devuelve un array de
				hashes tal y como devuelve
				<methodname>hash_from_dir</methodname> para cada uno
				de sus subdirectorios.</para>

			</listitem>

		</itemizedlist>

		<para>Esta es la lista de las funciones más importantes en
		<classname>EBox::GConfModule</classname>:</para>

		<variablelist>
			<varlistentry>
				<term><methodname>all_dirs</methodname></term>
				<listitem>

					<para>Dada una clave, devuelve todos los
					directorios de su interior.</para>
				
				</listitem>
			</varlistentry>
			<varlistentry>
				<term><methodname>all_dirs_base</methodname></term>
				<listitem>

					<para>Dada una clave, devuelve todos los
					directorios de su interior, eliminando
					cualquier directorio que aparezca por delante.</para>
				
				</listitem>
			</varlistentry>
			<varlistentry>
				<term><methodname>all_entries</methodname></term>
				<listitem>

					<para>Dada una clave, devuelve todas las
					entradas de su interior. Estas entradas son
					todas aquellas claves que no son directorios,
					por lo que contendrán un valor.</para>
					
					</listitem>
				</varlistentry>
				<varlistentry>
					<term><methodname>all_entries_base</methodname></term>
					<listitem>

					<para>Dada una clave, devuelve todas las
					de su interior, eliminando cualquier
					directorio que aparezca por delante. Las
					entradas son todas aquellas claves que no son
					directorios, por lo que contendrán un valor.</para>

				</listitem>
			</varlistentry>
			<varlistentry>
				<term><methodname>array_from_dir</methodname></term>
				<listitem>

					<para>Dada una clave, devuelve un array
					utilizando una referencia a un hash para
					contener en cada elemento los directorios bajo
					su clave. También, el hash contiene la clave
					<structfield>_dir</structfield> que dice cual
					es el nombre del directorio.</para>

				</listitem>
			</varlistentry>
			<varlistentry>
				<term><methodname>dir_exists</methodname></term>
				<listitem>

					<para>Dada una clave que referencia un
					directorio, devuelve <literal>true</literal>
					si existe.</para>

				</listitem>
			</varlistentry>
			<varlistentry>
				<term><methodname>get_bool</methodname></term>
				<listitem>

					<para>Devuelve el valor de una clave de tipo booleano.</para>

				</listitem>
			</varlistentry>
			<varlistentry>
				<term><methodname>get_int</methodname></term>
				<listitem>

					<para>Devuelve el valor de una clave de tipo entero.</para>

				</listitem>
			</varlistentry>
			<varlistentry>
				<term><methodname>get_list</methodname></term>
				<listitem>

					<para>Devuelve un array conteniendo la lista
					referenciada por la clave.</para>

				</listitem>
			</varlistentry>
			<varlistentry>
				<term><methodname>get_string</methodname></term>
				<listitem>

					<para>Devuelve el valor de una clave de tipo cadena.</para>

				</listitem>
			</varlistentry>
			<varlistentry>
				<term><methodname>get_unique_id</methodname></term>
				<listitem>
					
					<para>General un identificado único aleatorio
					con un <parameter>prefix</parameter> delante
					en la raiz del nombre del espacio del
					módulo. Si <parameter>directory</parameter> es
					pasado, será añadido a la ruta. Notar que esto
					no crea la entrada, únicamente devuelve un
					identificador único, así que es tarea del
					programador crear la entrada correctamente.</para>

				</listitem>
			</varlistentry>
			<varlistentry>
				<term><methodname>hash_from_dir</methodname></term>
				<listitem>
					
					<para>Devuelve un hash conteniendo todas las
					entradas del directorio referenciado por la clave.</para>

				</listitem>
			</varlistentry>
			<varlistentry>
				<term><methodname>isReadOnly</methodname></term>
				<listitem>

					<para>Devuelve <literal>true</literal> si la
					instancia actual de
					<classname>EBox::GConfModule</classname> a la
					que se está accediendo es de sólo-lectura.</para>

				</listitem>
			</varlistentry>
			<varlistentry>
				<term><methodname>makeBackup</methodname></term>
				<listitem>

					<para>Vuelca el contenido actual de la
					configuración a un fichero.</para>

				</listitem>
			</varlistentry>
			<varlistentry>
				<term><methodname>restoreBackup</methodname></term>
				<listitem>

					<para>Recupera el último backup.</para>

				</listitem>
			</varlistentry>
			<varlistentry>
				<term><methodname>revokeConfig</methodname></term>
				<listitem>

					<para>Todos los cambios hechos desde que se
					escribió o eliminó algo serán descartados.</para>
					
				</listitem>
			</varlistentry>
			<varlistentry>
				<term><methodname>set_bool</methodname></term>
				<listitem>

					<para>Asigna un <parameter>valor</parameter>
					booleano a una <parameter>clave</parameter>.</para>

				</listitem>
			</varlistentry>
			<varlistentry>
				<term><methodname>set_int</methodname></term>
				<listitem>

					<para>Asigna un <paramenter>valor</paramenter>
					entero a una
					<parameter>clave</parameter>.</para> 

				</listitem>
			</varlistentry>
			<varlistentry>
				<term><methodname>set_list</methodname></term>
				<listitem>

					<para>Asigna una lista de
					<parameter>valores</parameter> de un
					<parameter>tipo</parameter> en un <parameter>valor</parameter>.</para>
				
				</listitem>
			</varlistentry>
			<varlistentry>
				<term><methodname>set_string</methodname></term>
				<listitem>

					<para>Asigna un <parameter>valor</parameter>
					de tipo cadena en la <parameter>clave</parameter>.</para>

				</listitem>
			</varlistentry>
		</variablelist>

		<para>Veamos algunos ejemplos de las funciones anteriormente descritas.</para>
		
		<example>
			<title>Asignando un valor de tipo cadena</title>
			<programlisting> <![CDATA[$self->set_string("printers/x4235/name", "fooprinter"); ]]></programlisting>
		</example>

		<example>
			<title>Asignando una lista de cadenas</title>
			<programlisting><![CDATA[$self->set_list('foo/foolist', 'string', ['foo', 'bar']);]]></programlisting>
		</example>

		<example>
			<title>Recogiendo y usando un identificador único</title>
			<programlisting><![CDATA[my $id = $self->get_unique_id('p', 'printers');
$self->set_string("printers/$id/name", $name);
$self->set_bool("printers/$id/configured", undef);
		]]></programlisting>
		</example>
	</section>

	<section id="sect-ordering">
		<title>Ordering stuff</title>

		<para>The need to keep certain information ordered is fairly common
		across eBox modules. It is also common to provide reordering functions.
		An example of this are firewall rules, which need to be applied in
		a given order, and the user has to be able to change their order.
		The <classname>EBox::Order</classname> class solves just this
		problem.</para>

		<para>The idea is to give a directory to each item you want to
		keep ordered. Following the firewall example, we could have a
		<filename>rules/</filename> directory and, below it, one directory
		per rule. Each rule would get a unique identifier, and that
		would be its directory name below <filename>rules/</filename>.
		A rule with id <literal>r3561</literal> would be stored in
		<filename>rules/r3561</filename>, and below that directory we would
		store keys with each one of the rule's parameters. This is the most
		natural way of organizing items such as firewall rules, and it is with
		this organization that <classname>EBox::Order</classname> is designed
		to work.</para>

		<!-- FIXME example -->

		<para>The ordering mechanism adds one field to the
		items being ordered. Not surprisingly it is called
		<structfield>order</structfield>. To use the ordering API you have
		to create an <classname>EBox::Order</classname> instance. Its
		constructor takes to arguments: the instance of the module that owns
		the items being ordered, and the base directory where the items are
		stored.</para>

		<para><classname>EBox::Order</classname> implements these
		operations:</para>

		<variablelist>

			<varlistentry>
				<term><methodname>highest</methodname></term>
				<listitem>

					<para>Returns the highest <structfield>order</structfield> key of
					all the items.</para>

				</listitem>
			</varlistentry>

			<varlistentry>
				<term><methodname>lowest</methodname></term>
				<listitem>

					<para>Returns the lowest <structfield>order</structfield> key of
					all the items.</para>

				</listitem>
			</varlistentry>

			<varlistentry>
				<term><methodname>nextn</methodname></term>
				<listitem>

					<para>Given a number, returns the
					<structfield>order</structfield> key for the next item.</para>

				</listitem>
			</varlistentry>

			<varlistentry>
				<term><methodname>prevn</methodname></term>
				<listitem>

					<para>Given a number, returns the
					<structfield>order</structfield> key for the previous
					item.</para>

				</listitem>
			</varlistentry>

			<varlistentry>
				<term><methodname>get</methodname></term>
				<listitem>

					<para>Returns the identifier for the item whose
					<structfield>order</structfield> key equals a given
					number.</para>

				</listitem>
			</varlistentry>

			<varlistentry>
				<term><methodname>swap</methodname></term>
				<listitem>

					<para>It finds the items whose <structfield>order</structfield>
					keys match two given numbers and swaps their values.</para>

				</listitem>
			</varlistentry>

			<varlistentry>
				<term><methodname>list</methodname></term>
				<listitem>

					<para>Returns a reference to an array that holds the identifiers
					of all items, ordered from lowest to highest order.</para>

				</listitem>
			</varlistentry>

		</variablelist>

		<example>
			<title>Ordering firewall rules</title>

			<para>Let's see how the firewall module uses
			<classname>EBox::Order</classname> to keep its forwarding rules
			ordered. The <methodname>_fwdRulesOrder</methodname> returns the
			<classname>EBox::Order</classname> instance for the firewall
			rules:</para>

			<programlisting><![CDATA[sub _fwdRulesOrder
{
	my $self = shift;
	return new EBox::Order($self, "fwdrules");
}]]></programlisting>

			<para><filename>fwdrules</filename> is the directory that
			holds all the rules. Another private helper function is
			<methodname>_fwdRuleNumer</methodname>, it returns the order number
			for a given rule identifier:</para>

			<programlisting><![CDATA[sub _fwdRuleNumber # (rule)
{
	my ($self, $rule) = @_;
	return $self->get_int("fwdrules/$rule/order");
}]]></programlisting>

			<para>New rules are appended at the end of the list, so we find the
			highest order number and add one to it, this code is part of the
			<methodname>addFwdRule</methodname> method:</para>

			<programlisting><![CDATA[my $order = $self->_lastFwdRule() + 1;

$self->set_string("fwdrules/$id/name", $id);
$self->set_string("fwdrules/$id/action", $action);
$self->set_bool("fwdrules/$id/active", 1);
$self->set_int("fwdrules/$id/order", $order);]]></programlisting>

			<para><methodname>_lastFwdRule</methodname> is a trivial wrapper that
			returns the highest ordered number:</para>

			<programlisting><![CDATA[sub _lastFwdRule
{
	my $self = shift;
	my $order = $self->_fwdRulesOrder();
	defined($order) or return 0;
	return $order->highest;
}]]></programlisting>

			<para>Finally there are two methods to allow rule
			reordering, they are <methodname>FwdRuleUp</methodname> and
			<methodname>FwdRuleDown</methodname> (only the first one is shown
			here since they are almost identical):</para>

			<programlisting><![CDATA[sub FwdRuleUp # (rule)
{
	my ($self, $rule) = @_;
	my $order = $self->_fwdRulesOrder();
	defined($order) or return;
	my $num = $self->_fwdRuleNumber($rule);
	if ($num == 0) {
		return;
	}
	my $prev = $order->prevn($num);
	$order->swap($num, $prev);
}]]></programlisting>
		</example>

	</section>

	<section id="sect-config-and-daemons">
		<title>Controlling a daemon</title>

		<para>Besides exposing an API that allows reading and changing the
		configuration of a given service, a module's backend is in charge of
		making that service work. Typically, the service will be some sort of
		daemon that offers some functionality across the network after reading
		a config file. So your module needs to generate the config file and
		start/stop/restart the daemon at the right times.</para>

		<section id='sect-configfiles'>
			<title>Config file generation</title>

			<para>The easiest way to generate config files is using the
			<application>mason</application> templating engine which is also used
			in the web front-end. Using mason templates is documented in <xref
			linkend='sect-mason'/> so we won't repeat it here.</para>

			<para>Mason templates for config files are installed in the
			<filename>stubs</filename> directory under the shared directory
			for eBox. In the module source tree they are usually placed in
			directory of their own called <filename>stubs</filename> too. The
			<filename>Makefile.am</filename> in the <filename>stubs</filename>
			directory for the dnscache module looks like this:</para>

			<programlisting><![CDATA[Stubdir = @STUBSPATH@/dns-cache

nobase_Stub_DATA = named.conf.mas named.conf.options.mas \
	named.conf.local.mas

EXTRA_DIST = $(nobase_Stub_DATA)

MAINTAINERCLEANFILES = Makefile.in]]></programlisting>

			<para>The <application>autoconf</application> macro included in
			<filename>ebox.m4</filename> automatically exports the stubs
			directory path as <varname>STUBSPATH</varname>, so you just need
			to put create a directory for your module in it and put your mason
			templates there.</para>

			<para>There is a method in <classname>EBox::Module</classname>
			that helps with file permissions and other details. It is called
			<methodname>writeConfFile</methodname> and it takes three
			arguments:</para>

			<itemizedlist>
				<listitem>
					<para>The path of the config file that's going to be generated.
					</para>
				</listitem>

				<listitem>
					<para>The path of the mason template relative to the stubs
					directory.</para>
				</listitem>

				<listitem>
					<para>A reference to the arguments that you want to pass to the
					mason template.</para>
				</listitem>
			</itemizedlist>

			<para><methodname>writeConfFile</methodname> will generate the config
			file in a temporary location and then copy it on top of the desired
			destination, keeping its original permissions and ownership.</para>

			<example>
				<title>Generating a configuration file</title>

				<para>This is the code that generates the configuration file in the
				ipsec module:</para>

				<programlisting><![CDATA[my $self = shift;
my $conns = $self->staticActiveConnsArray();
my $warriors = $self->warriorActiveConnsArray();
my @array = ();

push(@array, 'shared_secret_conns' => $conns);
push(@array, 'road_warrior_conns' => $warriors);
$self->writeConfFile(IPSECCONFFILE, "ipsec/ipsec.conf.mas", \@array);

push(@array, 'includedir' => EBox::Config::conf . "/ipsecrsa/*");
$self->writeConfFile(IPSECSECRETS, "ipsec/ipsec.secrets.mas", \@array);
]]></programlisting>

				<para>And this is the template the generates the
				<filename>ipsec.secrets</filename> file:</para>

				<programlisting><![CDATA[<%args>
	@shared_secret_conns => ()
 	$includedir
</%args>

% foreach my $conn (@shared_secret_conns) {
<%$conn->{'lIP'}%> <%$conn->{'rIP'}%> : PSK "<%$conn->{'authinfo'}%>"

% }

include <%$includedir%>]]></programlisting>
			</example>
	
		</section>

		<section>
			<title>Controlling execution</title>

			<para>The first thing you need to know is when to start and
			stop the daemon you are controlling. Services are started
			by calling the <methodname>restartService</methodname> or
			<methodname>save</methodname> methods on a module instance, however
			those methods are implemented by <classname>EBox::Module</classname>
			and should normally not be overriden, since they takes
			care of logging and/or saving the configuration changes.
			Both of these methods call an abstract method when they
			need to actually start/restart the service. This method is
			<methodname>_regenConfig</methodname>, and it's the one that you need
			to implement.</para>

			<para><methodname>_regenConfig</methodname> should generate
			the configuration files for the daemon and start or restart
			it. A sample implementation of this method can be found in
			<xref linkend='ex-regencfg'/>. If you need to know whether the
			call is caused by a service start/restart or by saving the
			configuration changes, you can check the parameters passed to
			<methodname>_regenConfig</methodname>. When it's called because
			the configuration was saved (<methodname>save()</methodname>)
			the named argument <parameter>save</parameter> will be set
			to <literal>1</literal>, if it is just a regular service
			restart (<methodname>restartService()</methodname>), the
			<parameter>restart</parameter> argument will be set to
			<literal>1</literal>. In most situations you won't need this, since
			you can easily know whether the daemon is running, this is only
			useful for special cases like the network module.</para>

			<para>When <methodname>_regenConfig</methodname> gets called,
			you'll probably need to know whether to start or restart the
			daemon, because choosing the wrong operation may produce an
			error. To make that decision you need to know if the daemon is
			currently running. <classname>EBox::Module</classname> has two
			methods to make this task easier. If you know the process ID of
			the process you can use <methodname>pidRunning</methodname>,
			it receives a process ID as an argument. If you just know the
			name of the file where the daemon stored its process ID, you'll
			want to call <methodname>pidFileRunning</methodname>, which
			takes a file name, checks for a process ID in it and calls
			<methodname>pidRunning</methodname>. Both methods return true if the
			process is running and false if it's not.</para>

			<example id='ex-regencfg'>

				<title>Sample <methodname>_regenConfig</methodname>
				implementation</title>

				<programlisting><![CDATA[sub _regenConfig
{
	my $self = shift;
	$self->_setBindConf;
	$self->_doDaemon();
}

sub _doDaemon
{
	my $self = shift;

	if ($self->service and $self->pidFileRunning(PIDFILE)) {
		$self->_daemon('reload');
	} elsif ($self->service) {
		$self->_daemon('start');
	} elsif ($self->pidFileRunning(PIDFILE)) {
		$self->_daemon('stop');
	}
}

sub _daemon # (action)
{
	my ($self, $action) = @_;
	my $command = BIND9INIT . " " . $action . " 2>&1";

	if ( $action eq 'start') {
		root($command);
	} elsif ( $action eq 'stop') {
		root($command);
	} elsif ( $action eq 'reload') {
		root($command);
	} else {
		throw EBox::Exceptions::Internal(
			"Bad argument: $action");
	}
}]]></programlisting>
				
			</example>

			<para>Stopping the service is similar, you just check if
			it is running and if it is, then run the command that
			stops it. As with <methodname>restartService</methodname>,
			<classname>EBox::Module</classname> has a template implementation
			of the <methodname>stopService</methodname> method, which calls an
			abstract method when it's time to actually stop the service. The
			abstract method, <methodname>_stopService</methodname> is the one you
			need to implement.</para>

			<example>

				<title>Sample <methodname>_stopService</methodname>
				implementation</title>

				<programlisting><![CDATA[sub _stopService
{
	my $self = shift;

	if ($self->pidFileRunning(PIDFILE)) {
		$self->_daemon('stop');
	}
}]]></programlisting>
			</example>

		</section>

	</section>

	<section id='sect-schemas'>
	
		<title>gconf schemas</title>

			<section id='sect-schemas-minimal'> 
			<title>Minimal gconf schema</title>

			<para>A gconf schema is a special gconf key that sets the type and
			default value for some other gconf key. They are stored in the gconf
			database under the <filename>/schemas</filename> directory.</para>

			<para>You will need to create a gconf schema for you module. This is
			needed at least to integrate your module within the framework. By
			means of this schema your module could be instanced. So the first
			thing you should do is to associate the given name for your module
			and its proper perl module. Let's look at an example to clarify this
			idea a little further.</para>

			<para>Say we have a module called <emphasis>foobar</emphasis>,
			and the implementation for this module lies in
			<classname>EBox::Foobar</classname>. Your gconf schema would look
			something like this:</para>

			<example>
			<title>Minimal gconf schema</title>
				<programlisting><![CDATA[<gconfschemafile>
<schemalist>
	<schema>
		<key>/schemas/ebox/modules/global/modules/foobar/class</key>
		<applyto>/ebox/modules/global/modules/foobar/class</applyto>
		<owner>ebox</owner>
		<type>string</type>
		<default>EBox::Foobar</default>
		<locale name="C"/>
	</schema>
</schemalist>
</gconfschemafile>]]></programlisting>
			</example>

			<para>Once you have done this, anytime you instance
			the module <emphasis>foobar</emphasis> using the
			method <methodname>modInstance</methodname> from
			<classname>EBox::Global</classname>, it will know that it has to load
			and instance the class <classname>EBox::Foobar</classname>.</para>
	
			<example>
			<title>Creating a module instance</title>
			<programlisting><![CDATA[my $foobar = EBox::Global->modInstance('foobar');
$foobar->some_method();]]></programlisting>
			</example>
			
		</section>

		<section id='sect-schemas-default'> 
			<title>Default values</title>

			<para>Gconf schemas become useful to establish default values. These
			values will be used by the system when the user has not set a value
			for the corresponding key.</para>

			<para>There is an obvious scenario in which you might be interested
			in using this feature. This is when your module is installed for the
			first time, it could come in handy to set default values for your
			initial configuration.</para>

			<para>Let's illustrate this with a simple example. Imagine you are
			providing a module to manage a HTTP proxy. One of the configurable
			parameters is the listening port. You want the user to have the
			capability to change it, but also you wish to provide 3128 as an
			initial value. Gconf schema is the right place to do it. For 
			this example we would use the key 
			<filename>/schemas/ebox/modules/proxy/port</filename>.</para>

			<example>
				<title>Setting a default value in gconf schemas</title>
				 <programlisting><![CDATA[<schema>
	<key>/schemas/ebox/modules/proxy/port</key>
	<applyto>/ebox/modules/proxy/port</applyto>
	<owner>ebox</owner>
	<type>int</type>
	<default>3128</default>
	<locale name="C"/>
</schema>]]></programlisting>
			</example>
		</section>
			
		<section id='sect-schemas-dependence'> 
		<title>Module dependencies</title>

			<para>It is likely your module configuration depends on some other
			modules. If this occurs to your module, you will be interested in
			being notified anytime that there is a change in any of the modules
			you depend on.</para>

			<para>Continuing with the example used earlier, consider you
			want to configure the proxy for listening solely on the internal
			interfaces. The network module is the one which deals with the
			network interfaces. So at the time of generating the configuration
			for the proxy we will ask the network module for the network
			interfaces configured as internal. This raises an obvious issue, your
			module should regenerate its configuration whenever the internal
			interfaces change, that is, when the network module's configuration
			is changed.</para>

			<para>In order to express this relationship of dependence we will
			use your module's gconf schema as follows:</para>

			<example>
				<title>Setting module dependencies</title>
				 <programlisting><![CDATA[<schema>
	<key>/schemas/ebox/modules/global/modules/proxy/depends</key>
	<applyto>/ebox/modules/global/modules/proxy/depends</applyto>
	<owner>ebox</owner>
	<type>list</type>
	<list_type>string</list_type>
	<default>[network]</default>
	<locale name="C"/>
</schema>]]></programlisting>
			</example>

			<para>The above snippet tells the module global that
			proxy depends on network. This way, global will run
			the method <methodname>_regenConfig</methodname> from
			<classname>EBox::Proxy</classname> when the network module's
			configuration changes.</para>

			<!-- FIXME - sintax for multiple dependencies-->

		</section>
	</section>

	<section id="sect-cfgback">
		<title>Configuration backups</title>

		<para>As we pointed out earlier, all changes made on the keys stored
		in gconf are automatically backed up the first time a write or delete
		operation is carried on. In consequence, all theses changes could be
		restored automatically if the user wishes to dismiss or restore them
		from a file. Of course, this is true as long as you use the methods
		provided by <classname>EBox::GConfModule</classname>.</para>

		<para>If your module has some other stuff which is not stored in
		gconf and needs some special treatment to be backed up you will have
		to override the methods <methodname>_dump_to_file</methodname> and
		<methodname>_load_from_file</methodname>.</para>

		<para>The <emphasis>ipsec</emphasis> module keeps RSA keys outside
		of gconf, so when it is time to do a backup it needs to take care of
		them:</para>
		
		<example>
			<title>Overriding backup methods</title>
				<programlisting><![CDATA[sub _dump_to_file # (dir?)
{
	my ($self, $dir) = @_;
	$self->SUPER::_dump_to_file($dir);
	($dir) or $dir = EBox::Config::conf;
	my $origdir = EBox::Config::conf . "/ipsecrsa";
	if ( -e "$dir/ipsecrsa.bak") {
		rmtree("$dir/ipsecrsa.bak") or 
			throw EBox::Exceptions::Internal(__(
			  'Error while removing old rsa keys backup'));
	}
	mkdir("$dir/ipsecrsa.bak", 0700) or 
		throw EBox::Exceptions::Internal(__(
		  'Error while making backup dir for rsa keys'));
	my @keys = @{$self->listRSAKeys()};
	foreach my $key (@keys) {
		next unless (-f "$origdir/$key");
		copy("$origdir/$key", "$dir/ipsecrsa.bak") or
			throw EBox::Exceptions::Internal(
				__('Error while backing up rsa keys'));
	}
}

sub _load_from_file # (dir?)
{
	my ($self, $dir) = @_;
	$self->SUPER::_load_from_file($dir);
	($dir) or $dir = EBox::Config::conf;
	my $destdir = EBox::Config::conf . "/ipsecrsa";
	( -d "$dir/ipsecrsa.bak") or
		throw EBox::Exceptions::Internal(
			__('rsa keys backup not found'));
	if ( -e "$destdir") {
		rmtree($destdir) or throw EBox::Exceptions::Internal(
			__('Error while removing rsa keys'));
	}
	mkdir("$destdir", 0700) or 
		throw EBox::Exceptions::Internal(__(
		  'Error while making dir for rsa keys'));

	my @keys = @{$self->listRSAKeys()};
	foreach my $key (@keys) {
		next unless (-f "$dir/ipsecrsa.bak/$key");
		copy("$dir/ipsecrsa.bak/$key", "$destdir") or
			throw EBox::Exceptions::Internal(
				__('Error while restoring rsa keys'));
	}
}]]></programlisting>
		</example>
		
	</section>		

</chapter>
