<!-- vim: ts=2 sw=2
-->
<chapter id="ch-examplemod">

	<title>Creating a small module</title>

	<simplesect>

		<para>Once you've seen the eBox internals, we are going to apply all
		the knowledge explained in the previous chapters creating a module
		from scratch. The first thing to do is choose a network service that
		you want to integrate into eBox. In our case we've chosen the Network
		Time Protocol server because it is one of the most simple that exist in
		eBox. Our module will provide eBox these features:</para>

		<itemizedlist>
			<listitem>
				<para>Date and time synchronization with an external server.</para>
			</listitem>

			<listitem>
				<para>Let clients synchronize their time and date with
				eBox.</para>
			</listitem>
		</itemizedlist>

		<para>And these are the steps we are going to follow in the development fo
		the module:</para>

		<itemizedlist>
			<listitem>
				<para>Study the NTP server and its features.</para>
			</listitem>

			<listitem>
				<para>Create a new module from the module template.</para>
			</listitem>

			<listitem>
				<para>Define and implement an API to manage its configuration.</para>
			</listitem>

			<listitem>
				<para>Develop CGIs and mason templates.</para>
			</listitem>

			<listitem>
				<para>Make our module show up in the eBox menu and in the summary
				page.</para>
			</listitem>

			<listitem>
				<para>Generate the configuration files and control the execution of the
				daemon.</para>
			</listitem>

			<listitem>
				<para>Establish custom rules in the firewall that let our module
				work.</para>
			</listitem>
		</itemizedlist>

	</simplesect>
	
	<section id='sect-example-define'>
		<title>Studying the NTP service and its features</title>

		<para>We've decided to develop this module using the ntp server from <ulink
		url='http://www.ntp.org'>www.ntp.org</ulink>. Debian includes packages for
		the server so we are going to use two of them:
		<emphasis>ntp-server</emphasis> to provide the time synchronization service
		to clients and <emphasis>ntpdate</emphasis> to make synchronization queries
		to external servers.</para>

		<para>After choosing the software we have to study how it works, its
		configuration files and the configurable parameters within them. With all
		this information we will be able to choose what degree of control the user
		of our module will have. We'll try to strike a balance between flexibility
		in the configuration and ease of use.</para>

		<para>For the module we are developing we only need to tune some of the
		parameters contained in the <filename>/etc/ntp.conf</filename> file,
		which holds the configuration for the ntp daemon. Of all the possible
		configuration options contained in that file, we are only interested in
		two:</para>

		<itemizedlist>
			<listitem>
				<para>The list of ntp servers we are going to use to synchronize our
				date and time. This can be achieved by adding lines like the following
				as many times as necessary to the configuration file:</para>

				<programlisting> <![CDATA[ server ntp_server_ip ]]>
				</programlisting>
			</listitem>

			<listitem>
				<para>The ability to act as an NTP server for clients in our network.
				This is done using the <varname>server</varname> attribute, as seen
				above, with an special IP address:</para>

				<programlisting> <![CDATA[ server 127.127.1.0 ]]> </programlisting>
			</listitem>
		</itemizedlist>

		<para>The NTP server has more configuration options, but we have
		decided to leave them with sane default values that are transparent to
		the user. We will concentrate on those features that will be generally
		most interesting to our users.</para>

		<para>We will also add the possibility for the user to manually change
		the system time and date and the time zone, in case there is no
		possibility to synchronize the time with external NTP servers.</para>

		<para>Time and date modification is easily done using the
		<command>/bin/date</command> command.</para>

		<para>Time zone configuration is easy too.
		<filename>/etc/localtime</filename> is a symbolic link that points
		to a file named after the location we are in. All possible timezones
		are stored under the <filename>/usr/share/zoneinfo/</filename>
		directory. Each location is stored inside its continent,
		so if our time zone is <emphasis>Madrid/Europe</emphasis>,
		then <filename>/etc/localtime</filename>must point to
		<filename>/usr/share/zoneinfo/Europe/Madrid</filename>. The
		operation of modifying the time zone is as simple as changing the
		<filename>/etc/localtime</filename> symlink.</para>

  </section>

	<section id='sect-example-module-bootstrap'>
		<title>Create a new module from the module template.</title>

		<para>As we have seen above, eBox modules have a complex directory
		structure that can be tedious to set up. Because of that, a module
		template is provided inside the tools directory in the base ebox
		module. This template provides a basic skeleton for an eBox module and
		can be cloned to create a new one. Note that you should replace the
		string modulename with your module name. </para>

		<para>eBox uses <command>autoconf</command> and
		<command>automake</command> for module configuration and
		installation. The files <filename>autogen.sh</filename>,
		<filename>configure.ac</filename> and <filename>Makefile.am</filename>
		contain the basic autotools configuration for a standard module and are
		also included in the template. The template also provides a
		<filename>m4/ebox.m4</filename> file, used by modules to detect the
		current eBox installation paths. </para>

		<para>The <ulink
		url="http://www.gnu.org/software/autoconf/manual/">Autoconf</ulink>
		and <ulink
		url="http://www.gnu.org/software/automake/manual/">Automake</ulink>
		manuals are the best autotools reference.</para>

  </section>

	<section id='sect-example-api'>
		<title>Defining and implementing the API</title>

		<para>At this point we should have gained a good degree of familiarity
		with the network service we are going to work with. We should also
		know what features will be exposed to our future users. In addition
		we have a template to use as a base for our module. The next step
		is to define the API for our module's backend. We must define which
		methods will be needed to let the rest of the modules read and write
		all the configuration options and to manage the daemon: start, stop,
		etc...</para>

		<para>The backend of our module is going to be in the
		<classname>EBox::NTP</classname> class. It will inherit from
		<classname>EBox::GConfModule</classname> and it will contain all the
		methods that conform the NTP API. This is its constructor:</para>

		<example>
			<title><classname>EBox::NTP</classname> constructor</title>
			<programlisting><![CDATA[sub _create 
{
	my $class = shift;
	my $self = $class->SUPER::_create(name => 'ntp', 
						domain => 'ebox-ntp',
						@_);
	bless($self, $class);
	return $self;
}]]></programlisting>
		</example>

		<para>After the analysis performed in the previous
		section we can define the following methods in
		<classname>EBox::NTP</classname>(remember that we use a leading
		underscore for private method names):</para>

		<itemizedlist>
			<listitem>
				<para>setService</para>
			</listitem>
			<listitem>
				<para>service</para>
			</listitem>
			<listitem>
				<para>setSynchronized</para>
			</listitem>
			<listitem>
				<para>synchronized</para>
			</listitem>
			<listitem>
				<para>setServers</para>
			</listitem>
			<listitem>
				<para>servers</para>
			</listitem>
			<listitem>
				<para>setNewData</para>
			</listitem>
			<listitem>
				<para>setNewTimeZone</para>
			</listitem>
			<listitem>
				<para>_restartAllServices</para>
			</listitem>
		</itemizedlist>

		<variablelist>
			
			<varlistentry>
				<term><methodname>setService</methodname></term>
				<listitem>

					<para>This method gets a boolean argument that enables or disables the
					NTP service, which will allows clients in the local network
					synchronize their time and date with eBox.</para>

					<para>Here is its implementation:</para>
					
					<example>
						<title>Enabling the NTP server</title>
						<programlisting><![CDATA[sub setService 
{
	my ($self, $active) = @_;
	if ($active xor $self->service) {
		$self->set_bool('active', $active);
	}
} ]]> </programlisting>
					</example>

					<para>First we read the <parameter>active</parameter> argument
					and then we use the <methodname>service</methodname> method
					to find out if the server is currently enabled. Only if the
					new value is different than the old one we go on to set
					the <parameter>active</parameter> gconf key, by calling
					<methodname>set_bool</methodname>.</para>

				</listitem>
			</varlistentry>

			<varlistentry>
				<term><methodname>service</methodname></term>
				<listitem>

					<para>This method returns whether the NTP server is currently
					enabled or not. Its implementation is trivial, all we need is
					to fetch the <parameter>active</parameter> gconf key and return
					it:</para>

					<example>
						<title>Reading the state of the NTP server</title>
						<programlisting><![CDATA[sub service 
{
	my $self = shift;
	return $self->getbool('active');
} ]]> </programlisting>
					</example>

				</listitem>
			</varlistentry>

			<varlistentry>
				<term><methodname>setSynchronized</methodname></term>
				<listitem>

					<para>This method receives a boolean parameter that decides
					whether eBox will synchronize its date and time with external
					NTP servers. As you can see, its implementation is similar
					to <methodname>setService</methodname>, we just use the
					<parameter>synchronized</parameter> gconf key instead:</para>

					<example>
						<title>Enabling the external NTP synchronization</title>
						<programlisting><![CDATA[sub setSynchronized # (synchronized)
{
	my ($self, $synchronized) = @_;

	if ($synchronized xor $self->synchronized) {
		$self->set_bool('synchronized', $synchronized);
	}
} ]]> </programlisting>
					</example>

				</listitem>
			</varlistentry>

			<varlistentry>
				<term><methodname>synchronized</methodname></term>
				<listitem>

					<para>This method returns the value of the
					<parameter>synchronized</parameter> gconf key.
					Its implementation is quite simple and similar to
					<methodname>service</methodname>.</para>

					<example>
						<title>Fetching the configuration for external
						synchronization</title>

						<programlisting><![CDATA[sub synchronized 
{ 
	my $self = shift;
	return $self->getbool('synchronized');
} ]]> </programlisting>
					</example>

				</listitem>
			</varlistentry>

			<varlistentry>
				<term><methodname>setServers</methodname></term>
				<listitem>

					<para>This allows us to store the names of the ntp servers we
					will use to synchronize our time and date in the gconf database.
					Its implementation checks whether an IP address or a domain name
					were introduced and checks the syntax of the value accordingly.
					If the syntax is correct the servers will be stored in the
					gconf database calling the <methodname>set_string</methodname>
					method. In addition to that, we won't let the user set a
					secondary server if no primary server has been set, and the
					same for the third server. Let's see part <footnote><para>The
					complete implementation can be found in the subversion
					repository</para></footnote>of its implementation:</para>

					<example>
						<title>Setting the external NTP servers</title>
						<programlisting><![CDATA[sub setServers # (server1, server2, server3) 
{
	my ($self, $s1, $s2, $s3) = @_;

	if ($s1 =~ /^(\d{1,3}\.){3}\d{1,3}$/) {
		checkIP($s1, __("primary server IP address"));
		$self->set_string('server1', $s1);
	} else {
		checkDomainName($s1, __("primary server name "));
		$self->set_string('server1', $s1);
	}

	if (defined($s2) and ($s2 ne "")) {
		if ($s2 =~ /^(\d{1,3}\.){3}\d{1,3}$/) {
			checkIP($s2, __("secondary server IP address"));
			$self->set_string('server2', $s2);
		} else {

			...
]]> </programlisting>
					</example>
				</listitem>
			</varlistentry>

			<varlistentry>
				<term><methodname>servers</methodname></term>
				<listitem>

					<para>It returns an array that contains the NTP external
					servers stored in gconf:</para>

					<example>
						<title>Getting the list of external NTP servers</title>
						<programlisting><![CDATA[sub servers 
{
	my $self = shift;
	my @servers;
	@servers = ($self->get_string('server1'),
		$self->get_string('server2'),
		$self->get_string('server3'));

	return @servers;
} ]]> </programlisting>
					</example>
				</listitem>
			</varlistentry>
		
			<varlistentry>
				<term><methodname>setNewDate</methodname></term>
				<listitem>

					<para>This method changes the system's date and time. This is its
					implementation:</para>
					
					<example>
						<title>Setting a new system time and date</title>
						<programlisting><![CDATA[sub setNewDate # (day, month, year, hour, minute, second)
{
	my ($self, $day, $month, $year, $hour, $min, $sec) = @_;

	my $newdate = "$year-$month-$day $hour:$min:$sec";
	my $command = "/bin/date --set \"$newdate\"";
	root($command);

	$self->_restartAllServices;
} ]]> </programlisting>
					</example>

					<para>We receive as arguments every piece of data necessary to set the
					time and date in the system: day, month, year, hour, minutes and
					seconds.</para>

					<para>We build the complete command in the
					<varname>command</varname> variable and a call is made to the
					<function>root</function> function that executes it. This
					command must be run as root using <command>sudo</command>, that's
					why we don't run it directly.</para>

					<para>When the system time changes, some system services and eBox
					modules need to be restarted. This is implemented in the
					<methodname>_restartAllServices</methodname> method seen in <xref
					linkend='ex-ntp-restart-all'/>.</para>
				</listitem> 
			</varlistentry>

			<varlistentry>
				<term><methodname>setNewTimeZone</methodname></term>
				<listitem>
					
					<para>Along with the time and date, the time zone may be changed too.
					For this purpose we implemented this method:</para>

					<example>
						<title>Setting a new time zone</title>
						<programlisting><![CDATA[sub setNewTimeZone # (continent, country)
{
	my ($self, $continent, $country) = @_;

	my $command = "ln -s /usr/share/zoneinfo/$continent/$country" .
			" /etc/localtime";
	$self->set_string('continent', $continent);
	$self->set_string('country', $country);
	root("rm /etc/localtime");
	root($command);
	$self->_restartAllServices;
} ]]></programlisting>
					</example>

					<para>It gets two arguments: <parameter>continent</parameter>
					and <parameter>country</parameter>. We use them to redo
					the symbolic link in <filename>/etc/localtime</filename>
					so that it points to the new time zone. For example,
					if the two arguments are <literal>Africa</literal> and
					<literal>Africa</literal>, <filename>/etc/localtime</filename>
					will be changed so that it points to
					<filename>/usr/share/zoneinfo/Africa/Dakar</filename>.</para>

					<para>We store both arguments in gconf too, making to calls to
					<methodname>set_string</methodname>. When the time zone has
					been changed some eBox modules and the system log services are
					restarted so that they don't run with the wrong time.</para>

				</listitem>
			</varlistentry>

			<varlistentry>
				<term><methodname>_restartAllServices</methodname></term>
				<listitem>

					<para>Operations that change the system's time and date may leave some
					parts of the system in an inconsistent state. To avoid having eBox
					modules and system log services with a time shift we'll write a
					method that will restart all those services so that they get the new
					time and date. Here it goes:</para>

					<example id='ex-ntp-restart-all'>
						<title>Restarting eBox modules and system services</title>
						<programlisting> <![CDATA[sub _restartAllServices
{
	my $self = shift;
	my $global = EBox::Global->getInstance();
	my @names = grep(!/^network$/, @{$global->modNames});
	@names = grep(!/^firewall$/, @names);
	my $log = $global->logger;
	my $failed = "";
 	$log->info("Restarting all modules");
	
	foreach my $name (@names) {
		my $mod = $global->modInstance($name);
		try {
			$mod->restartService();
		} catch EBox::Exceptions::Internal with {
			$failed .= "$name ";
		};
	}
	
	if ($failed ne "") {
		throw EBox::Exceptions::Internal("The following modules ".
			"failed while being restarted, their state is ".
			"unknown: $failed");
	}

	$log->info("Restarting system logs");
	try {
		root("/etc/init.d/sysklogd restart");
		root("/etc/init.d/klogd restart");
		root("/etc/init.d/cron restart");
	} catch EBox::Exceptions::Internal with {
	};
} ]]> </programlisting>
					</example>

					<para>First we get an <classname>EBox::Global</classname>
					instance that will build instances of every eBox module.
					We restart all modules except <emphasis>network</emphasis>
					and <emphasis>firewall</emphasis>, catching any exception
					that may be thrown while restarting them. Then we manually
					restart the system daemons: <emphasis>sysklogd</emphasis>,
					<emphasis>klogd</emphasis> and <emphasis>crond</emphasis>.
					Doing this requires root privileges so we invoke the
					<function>root</function> function.</para>

				</listitem>
			</varlistentry>
    </variablelist>

	</section>

	<section id='sect-example-cgis'>
		<title>Creating CGIs and templates</title>

		<para>After designing and implementing the API, it is time to create
		the layer that will interact with it: CGIs and mason templates. As
		you saw in <xref linkend='sect-example-define'/>, this module is
		going to answer NTP queries for clients in the local network. The
		API that enables and disables this service was implemented in <xref
		linkend='sect-example-api'/>. We will now create two CGIs and a mason
		template that will use these methods to give the user an interface for
		this feature:</para>

		<para>The two CGIs are <classname>EBox::CGI::NTP::Index</classname> and
		<classname>EBox::CGI::NTP::Enable</classname>, the template is called
		<filename>ntp/index.mas</filename>.</para>

		<para>Our first CGI is <classname>EBox::CGI::NTP::Index</classname>.
		It inherits from <classname>EBox::CGI::ClientBase</classname> and
		implements a constructor that sets the title for our page and the name
		of the template associated to this CGI. This is the constructor:</para>

		<example> 
			<title>Constructor for <classname>EBox::CGI::NTP::Index</classname>
			</title>
      <programlisting><![CDATA[package EBox::CGI::NTP::Index;

use strict;
use warnings;

use base 'EBox::CGI::ClientBase';

use EBox::Global;
use EBox::Gettext;

sub new {
	my $class = shift;
	my $self = $class->SUPER::new('title'    => NTP,
			'template' => 'ntp/index.mas', @_);

	$self->{domain} = "ebox-ntp";
	bless($self, $class);
	return $self;
} ]]> </programlisting>
		</example>

		<para>A noteworthy detail is the fact that the title string in this
		CGI is not translatable, and thus we haven't followed the instructions
		in <xref linkend='sect-i18n-developers'/> for i18n. If the title was
		translatable we would have followed those instructions.</para>

		<para>We are now ready to implement the
		<methodname>_process</methodname> method, which reads the current
		configuration for the NTP server and feeds it to the mason
		template.</para>

		<example>
			<title>Feeding the configuration of the NTP server to the mason
			template</title>

			<programlisting><![CDATA[sub _process
{
   my $self = shift;
   my $ntp = EBox::Global->modInstance('ntp');

   my @array = ();
   my $active = 'no';

   if ($ntp->service()) {
      $active = 'yes';
   }

   push (@array, 'active'     => $active);
   $self->{params} = \@array;
}]]></programlisting>
		</example>

		<para>You can see that the first thing we do is create an instance of
		our module (ntp) using <classname>EBox::Global</classname>. We use this
		instance to invoke the <methodname>service</methodname> method, which
		returns the configuration of the server and we pass it to the mason
		template placing it in the <structfield>param</structfield> attribute
		of the CGI. If the mason template needed more arguments we would just add
		them to the <varname>array</varname> variable.</para>

		<para>This CGI we just implemented, along with its mason template,
		shows the current configuration for the NTP server. We will now
		implement the CGI that will receive a new configuration from the user
		and will tell the backend to change it.</para>

		<example>
			<title>CGI to enable and disable the NTP server</title>
			<programlisting><![CDATA[package EBox::CGI::NTP::Enable;

use strict;
use warnings;

use base 'EBox::CGI::ClientBase';

use EBox::Global;
use EBox::Gettext;

sub new 
{
	my $class = shift;
	my $self = $class->SUPER::new('title' => 'NTP', @_);
	$self->{redirect} = "NTP/Index";
	$self->{domain} = "ebox-ntp";
	bless($self, $class);

	return $self;
}

sub _process
{
	my $self = shift;
	my $ntp= EBox::Global->modInstance('ntp');

	$self->_requireParam('active', __('module status'));
	$ntp->setService(($self->param('active') eq 'yes'));
}

1; ]]> </programlisting>
		</example>

		<para>Its implementation is quite simple, only a couple of details are
		noteworthy.</para>

		<para>First, the constructor sets the
		<structfield>redirect</structfield> attribute to
		<literal>NTP/Index</literal>. This will make the browser invoke that
		CGI after setting the configuration so that the value shown to the user
		is refreshed.</para>

		<para>Finally, we use the <methodname>setService</methodname> method,
		and we pass it a boolean argument that results from the reading of the
		<parameter>active</parameter> parameter from the HTTP request. HTTP
		parameters are fetched by invoking the <methodname>param</methodname>
		method from the parent class.</para>

		<para>Next we are going to create the mason template that will
		display the configuration and the form to change it. This is an
		special case, since most eBox modules will need to enable/disable
		network services. A common way of doing this is provided by the
		<filename>enable.mas</filename> mason template, which is part of the
		basic framework.</para>

		<para>It is very easy to use it. We create a template that receives an
		argument with the current configuration of the server. As explained
		in <xref linkend='sect-mason'/> we can include an external template
		by writing: 
		<programlisting><![CDATA[<& template.mas, @arguments &>]]></programlisting>.
		We are going to include <filename>enable.mas</filename> and we give it two
		arguments, the title and the current configuration of the NTP server. It
		looks like this:</para>

    <example> 
			<title>Mason template for enabling the NTP server</title> 
			<programlisting><![CDATA[<%args> $active </%args>
<%init> use EBox::Gettext; </%init>

<div class='ntpnew'>
<br />
<& enable.mas, title => __('Enable the local NTP server'),
		active => $active &>
</div>
]]></programlisting>
		</example>

		<para>Using <filename>enable.mas</filename> requires that
		the CGI that enables or disables the service be called
		<classname>Enable</classname>, since that is hard-coded into
		<filename>enable.mas</filename>. If you take another look at the CGI
		we implemented for this purpose, you'll see that its classname is
		<classname>EBox::CGI::NTP::Enable</classname>, just as required.</para>

		<para>We are now missing the CGIs that change the time zone, the time
		and date, and set the external NTP servers. These CGIs and templates
		are quite simple, it you want to see their source code you can check
		the subversion repository, their code will not be shown here, we'll
		limit ourselves to a quick overview of the files involved and their
		relationships.</para>

		<para>Two CGIs handle the time zone changing feature:</para>

		<itemizedlist>
			<listitem>
				<para><classname>Timezone</classname> uses a mason template
				(<filename>timezone.mas</filename>) to display the current timezone
				configuration.</para>
			</listitem>
			<listitem>

				<para><classname>ChangeTimeZone</classname> receives
				the new timezone from the web browser and invokes the
				<methodname>SetNewTimeZone</methodname>.</para>
			</listitem>
		</itemizedlist>

		<para>There is one more detail about the
		<classname>TimeZone</classname> CGI. It sends the current country and
		continent to the mason template, but it also sends a list with all
		possible continents and a hash that links each continents with the
		list of countries it contains. All this information is read from the
		<filename>/usr/share/zoneinfo/zone.tab</filename> file.</para>

		<para>Finally, our module provides two ways to establish the system's
		time and date: manually and synchronizing with external NTP servers.
		Each of these two methods excludes the other one (the user can only
		use one of the two methods). The <classname>Datetime</classname> CGI
		displays the information about the current time and date and the
		configuration of the external NTP servers stored in gconf. Two CGIs let
		the user change the settings shown in <classname>Datetime</classname>:
		<classname>Synch</classname> enables the synchronization against
		external NTP servers and <classname>ChangeDate</classname> changes the
		time and date manually.</para>

		<para>We just said that only one of the two methods may be used at
		the same time. This is enforced by the mason templates, and we are
		going to see how it's done. The <filename>datetime.mas</filename>
		template gets its arguments from the <classname>Datetime</classname>
		CGI, it includes the template <filename>synch.mas</filename>
		which lets the user choose whether he wants to set the time
		manually or use external NTP servers. Then, depending on the
		current configuration it loads the NTP server selection template
		(<filename>servers.mas</filename>) or the manual time and date
		configuration template (<filename>date.mas</filename>).</para>

		<example>
			<title><filename>datetime.mas</filename> template</title>
			<programlisting><![CDATA[<& /ntp/synch.mas, title => __('Synchronize with external NTP servers'),
synchronized => $synchronized &>

% if ($synchronized eq 'yes') {
<& /ntp/servers.mas, title => __('External NTP servers'), servers => \@servers
&>
% }

% if ($synchronized eq 'no') {
<& /ntp/date.mas, title => __('Change Date and Time'), date => \@date &>
% }]]></programlisting>
		</example>

		<para><filename>synch.mas</filename>, <filename>server.mas</filename>
		and <filename>date.mas</filename> just display the information that
		<filename>datetime.mas</filename> sends them as arguments.</para>
  </section>

	<section id='sect-example-menu'>
		<title>Showing the menu and the Summary page</title>

		<para>We are already in the final steps in the development of our
		module. Now we are going to add a new section to the eBox menu that
		will let the user access the user interface of our module and a section
		to the summary page with information about the ntp module.</para>

		<para>Adding a new section to the menu is as simple as
		implementing the <methodname>menu</methodname> method in our
		<classname>EBox::NTP</classname> class. This method gets an instance
		of <classname>EBox::Menu::Root</classname> to which we will add
		a new NTP section with several items: <quote>NTP Server</quote>,
		<quote>Date/Time</quote> and <quote>Time zone</quote>. Here is the
		<methodname>menu</methodname> method:</para>

		<example>
			<title>Adding entries to the eBox menu</title>
			<programlisting><![CDATA[sub menu
{
	my ($self, $root) = @_;
	my $folder = new EBox::Menu::Folder('name' => 'NTP',
			'text' => __('NTP'));

	$folder->add(new EBox::Menu::Item('url' => 'NTP/Index',
			'text' => __('NTP server')));
	$folder->add(new EBox::Menu::Item('url' => 'NTP/Datetime',
			'text' => __('Date/time')));
	$folder->add(new EBox::Menu::Item('url' => 'NTP/Timezone',
			'text' => __('Time zone')));
	$root->add($folder);
}]]></programlisting>
		</example>

		<para>As you saw in <xref linkend='sect-menu'/>, a new section is
		created with an instance of <classname>EBox::Menu::Folder</classname>,
		which needs to be given a name.</para>

		<para>The we add to it instances of
		<classname>EBox::Menu::Item</classname> which needs a name and a URL
		(as we explained in <xref linkend='sect-cgi'/>, we only need to specify
		<quote>NTP/Index</quote>, not the whole path).</para>

		<para>The NTP module is not going to have its own section in the
		summary page as there is not much information to display. We'll just
		add an entry in the status table at top of that page. For that we are going
		to implement the <methodname>statusSummary</methodname> method in
		<classname>EBox::NTP</classname>:</para>

		<example>
			<title><methodname>statusSummary</methodname> in 
			<classname>EBox::NTP</classname></title>

			<programlisting><![CDATA[sub statusSummary
{
	my $self = shift;
	return new EBox::Summary::Status('ntp', __('NTP local server'),
					$self->isRunning, $self->service);
}]]></programlisting>
		</example>

  </section>

	<section id='sect-example-daemon'>
		<title>Generating config files and managing the NTP server</title>

		<para>Let's see how you can use mason templates to generate the config
		file for the NTP server. In <xref linkend='sect-example-define'/>
		we saw that the NTP server reads all its configuration from the
		<filename>/etc/ntp.conf</filename> file. We'll use the same system we
		use to generate HTML for this file.</para>

		<para>This part of the module belongs in the backend, so
		all the methods needed to implemented will be placed in
		<classname>EBox::NTP</classname>.</para>

		<para>We have created a private method called
		<methodname>_setNTPConf</methodname> which will be invoked every time
		we need to generate the config file. Here it is:</para>

		<example>
			<title> Generating the <filename>/etc/ntp.conf</filename> config
			file</title>

			<programlisting><![CDATA[sub _setNTPConf
{
	my $self = shift;
	my @array = ();
	my @servers = $self->servers;
	my $synch = 'no';
	my $active = 'no';

	($self->synchronized) and $synch = 'yes';
	($self->service) and $active = 'yes';

	push(@array, 'active'   => $active);
	push(@array, 'synchronized'  => $synch);
	push(@array, 'servers'  => \@servers);

	$self->writeConfFile(NTPCONFFILE, "ntp/ntp.conf.mas", \@array);
}]]></programlisting>
		</example>

		<para>It is very simple, we just add all the arguments for the mason
		template to the <varname>array</varname> variable. Our arguments
		are:</para>

		<variablelist>
			<varlistentry>
				<term><parameter>active</parameter></term>
				<listitem>
					<para>It tells the template whether we are going to offer the NTP
					service for clients in our network or not.</para>
				</listitem>
			</varlistentry>

			<varlistentry>
				<term><parameter>synchronized</parameter></term>
				<listitem>
					<para>It tells the template whether we are going to synchronize our
					system's time with external NTP servers.</para>
				</listitem>
			</varlistentry>

			<varlistentry>
				<term><parameter>servers</parameter></term>
				<listitem>
					<para>It's an array with the list of external NTP servers.</para>
				</listitem>
			</varlistentry>
		</variablelist>

		<para>After building the array with the arguments we call
		<methodname>writeConfFile</methodname>, which generates the configuration
		file with proper permissions and needs these arguments:</para>
		
		<itemizedlist>
			<listitem>
				<para>The absolute path to the configuration file. In our case it is the
				<constant>NTPCONFFILE</constant> constant, which is defined in the
				beginning of our module: </para>
<programlisting><![CDATA[use constant NTPCONFFILE => "/etc/ntp.conf";]]></programlisting>
			</listitem>

			<listitem>
				<para>The path to the mason template that generates the file.</para>
			</listitem>

			<listitem>
				<para>An array with the arguments for the template.</para>
			</listitem>
		</itemizedlist>

		<para>And now let's see the template. We decided to leave some of the
		values in the config file with fixed values, other values are dynamic and
		are generated based on the arguments received:</para>

		<example>
			<title>Template to generate
			<filename>/etc/ntp.conf</filename></title>
			<programlisting><![CDATA[<%args>
	$active
	$synchronized
	@servers
</%args>
# /etc/ntp.conf, configuration for ntpd
# Generated by EBox

driftfile /var/lib/ntp/ntp.drift
statsdir /var/log/ntpstats/

% if ($synchronized eq 'yes') {
%       if ($servers[0]) {
server <% $servers[0] %>
%       }
%       if ($servers[1]) {
server <% $servers[1] %>
%       }
%       if ($servers[2]) {
server <% $servers[2] %>
%       }
% }
% if ($active eq 'yes') {
server 127.127.1.0
% }
fudge 127.127.1.0 stratum 13

restrict default kod notrap nomodify nopeer noquery

restrict 127.0.0.1 nomodify]]></programlisting>
		</example>

		<para>The only thing left is the code to manage the ntp
		daemon. We have to implement several methods, the first is an
		abstract method defined in <classname>EBox::Module</classname>:
		<methodname>_regenConfig</methodname>. It is invoked when services
		are restarted or when a new configuration for a module is saved.
		It has to generate the config file, using the already seen
		<methodname>_setNTPConf</methodname> method. Let's see it:</para>

		<example>
			<title><methodname>_regenConfig</methodname> method</title>
			<programlisting><![CDATA[sub _regenConfig
{
	my $self = shift;

	$self->_setNTPConf;
	$self->_doDaemon();
}]]></programlisting>
		</example>

		<para>Besides invoking <methodname>_setNTPConf</methodname>,
		it needs to restart the daemon, it does so by calling
		a private method: <methodname>_doDaemon</methodname>.
		Together with methods <methodname>_daemon</methodname>,
		<methodname>_stopService</methodname>, and
		<methodname>isRunning</methodname>, <methodname>_doDaemon</methodname>
		performs the management of the daemon. Let's see them one by
		one:</para>

		<example>
			<title>NTP daemon management method</title>
			<programlisting><![CDATA[sub _doDaemon
{
	my $self = shift;
	my $logger = EBox::Global->logger;

	if (($self->service or $self->synchronized) and $self->isRunning) {
		$self->_daemon('stop');
		sleep 2;
		if ($self->synchronized) {
			my $exserver = $self->get_string('server1');
			try {
				root("/usr/sbin/ntpdate $exserver");
			} catch EBox::Exceptions::Internal with {
				$logger->info("Error, ntpdate could" .
						" not be started.");
			};
		}
		$self->_daemon('start');
	} elsif ($self->service or $self->synchronized) {
		if ($self->synchronized) {
			my $exserver = $self->get_string('server1');
			try {
				root("/usr/sbin/ntpdate $exserver");
			} catch EBox::Exceptions::Internal with {
				$logger->info("Error ntpdate could" .
						" not be started.");
			};
		}
		$self->_daemon('start');
	} elsif ($self->isRunning) {
		$self->_daemon('stop');
		if ($self->synchronized) {
			$self->_daemon('start');
		}
	}
}]]></programlisting>
		</example>

		<para>This method is invoked:</para>
		
		<itemizedlist>
			<listitem>
				<para>To launch the server if it was stopped.</para>
			</listitem>
			<listitem>
				<para>To restart the server when it is running.</para>
			</listitem>
			<listitem>
				<para>To stop the server.</para>
			</listitem>
		</itemizedlist>

		<para>Depending on which case we are in it calls
		<methodname>_daemon</methodname> telling it which action we want to
		perform: start or stop. If the system date is to be synchronized
		with external servers we should try to make a manual query with the
		<command>/usr/sbin/ntpdate</command> before starting the daemon. This
		is a recommended practice before launching the ntp daemon.</para>

		<para>Let's see the <methodname>_daemon</methodname> code, which
		starts, stops or restarts the daemon directly depending on its
		argument:</para>

		<example>
			<title>Commands for starting and stopping the ntp daemon.</title>
			<programlisting><![CDATA[sub _daemon # (action)
{
	my ($self, $action) = @_;

	if ( $action eq 'start') {
		root("start-stop-daemon --start --quiet --pidfile" .
			" /var/run/ntpd.pid --exec /usr/sbin/ntpd " .
			" -- -g -p /var/run/ntpd.pid");
	} elsif ( $action eq 'stop') {
		root("start-stop-daemon --stop --quiet --pidfile" .
			" /var/run/ntpd.pid");
	} elsif ( $action eq 'force-reload') {
		root("start-stop-daemon --stop --quiet --pidfile"
			" /var/run/ntpd.pid");
		sleep 2;
		root("start-stop-daemon --start --quiet --exec /usr/sbin/ntpd -- -g -p /var/run/ntpd.pid");
	} else {
		throw EBox::Exceptions::Internal("Bad argument: $action");
	}
}]]></programlisting>
		</example>

		<para>There only two methods left for you to see.
		<methodname>_stopService</methodname> is defined as an abstract method by
		<classname>EBox::Module</classname>, it just stops the service.
		<methodname>isRunning</methodname> tells us whether the ntp daemon is
		currently running, it does so by checking its process id (PID).</para>

		<example>
			<title><methodname>_stopService</methodname> method.</title>
			<programlisting><![CDATA[sub _stopService
{
	my $self = shift;

	if ($self->isRunning) {
		$self->_daemon('stop');
	}
}
]]> </programlisting>
		</example>

		<example>
			<title>Telling wheter the ntp daemon is running or not.</title>
			<programlisting><![CDATA[sub isRunning
{
	my $self = shift;
	return $self->pidFileRunning(PIDFILE);
}
]]> </programlisting>
		</example>
  </section>

	<section id='sect-example-firewall'>
		<title>Setting up proper firewall rules</title>

		<para>The last step in creating this module is to let the firewall know
		about our needs, so that the ntp service works fine. If our date is set
		by querying external servers we will need to make UDP connections on
		port 123 to them. We also need to let clients connect to our 123 UDP
		port if we are going to be an NTP server. We created a private method
		called <methodname>_configureFirewall</methodname> that takes care of
		all this stuff. Here it is:</para>

		<example>
			<title>Firewall configuration</title>
			<programlisting><![CDATA[sub _configureFirewall
{
	my $self = shift;
	my $fw = EBox::Global->modInstance('firewall');

	if ($self->synchronized) {
		$fw->addOutputRule('udp', 123);
	} else {
		$fw->removeOutputRule('udp', 123);
	}

	if ($self->service and (!defined($fw->service('ntp')))) {
		$fw->addService('ntp', 'udp', 123, 0);
		$fw->setObjectService('_global', 'ntp', 'allow');
	} elsif ( !($self->service) and defined($fw->service('ntp')) ) {
		$fw->removeService('ntp');
	}
}]]></programlisting>
		</example>

		<para>The eBox firewall module simplifies this job providing
		methods that let us add new rules to the firewall. First of all
		we need an instance of the firewall module, as usual we use
		<classname>EBox::Global</classname> to get it. Then we add the
		output rule if we need to connect to external servers or remove
		it if we do not need to and it had been previously added. The
		methods for this are <methodname>addOutputRule</methodname> and
		<methodname>removeOutputRule</methodname>.</para>

		<para>For our NTP server, we need to register our service with
		the firewall by calling <methodname>addService</methodname>
		and then we'll allow it by default by calling
		<methodname>setObjectService</methodname>. If the NTP server feature is
		disabled we remove the ntp service from the firewall by calling
		<methodname>removeService</methodname>.</para>

  </section>
	
	<section id='sect-example-conclusion'>
		<title>Conclusion</title>

		<para>We are done, we just created an eBox module form scratch. We've
		gone through every step needed and seen what issues to watch out for.
		Now it is time to try it out and do some tests to check that it works
		as we expect. We hope this guide has been helpful and encourages you
		to contribute to making it a better platform with new modules and
		features.</para>
	</section>

</chapter>
