<!-- vim: ts=2 sw=2
-->
<chapter id="ch-backend">

	<title>Backend del módulo</title>

	<simplesect>

		<para>La plataforma eBox ofrece unos módulos con ciertas
		funcionalidades que están disponibles a través de una API orientada a
		objetos en su mayor parte. No todo está orientado a objetos,
		interfaces procedurales se han usado cuando tenía sentido hacerlo.</para> 

		<para>Algunas de las características de la API funcionan a través de
		herencia, éstas normalmente ofrecen un medio para que el módulo
		implemente las funcionalidades estándar como los menús, la página de
		estado, el guardado de la configuración o su revocación, etc. Algunas
		de estas características necesitan ser implementadas por el módulo
		mientras que otras son completas en la plataforma, y el módulo puede
		extenderlas o sobreescribirlas.</para>

	</simplesect>

	<section id="sect-basemod">
		<title>El módulo base</title>

		<para>Todos los módulos de eBox heredan de la clase
		<classname>EBox::Module</classname>. Esta clase define funciones
		abstractas que los módulos sobreescribirán para implementar una cierta
		funcionalidad. Estas funciones son llamados por la plataforma cuando son
		necesarios.</para>

		<para>Además de estas funciones abstractas, la clase implementa unos
		pocas funciones con algunas funcionalidades básicas. Estas últimas,
		siguen normalmente el método que define una plantilla de un
		patrón de diseño, es decir, realizan algunas operaciones pero delegan
		parte de ellas en alguna función abstracta que deberá ser implementada
		por la clase hija.</para>

		<!-- FIXME - class diagram -->

		<para>Finalmente, hay unas pocas funciones que implementan algunas
		operaciones comunes que son utilizadas por la mayoría de los módulos,
		están escritas para que sean llamadas por las clases hijas cuando se
		les necesita. Están situadas en la clase
		<classname>EBox::Module</classname> únicamente por conveniencia.</para>

		<section id="sect-modconstructor">
			<title>Constructor del módulo</title>

			<para>Todas las instancias del módulo son creadas y cacheadas
			por la clase <classname>Ebox::Global</classname>. Los
			constructores de un módulo no deben ser llamados directamente
			excepto por la clase <classname>EBox::Global</classname>. Por
			esta razón, se llaman <methodname>_create</methodname> en vez
			de <methodname>new</methodname>.</para>

			<para>El primer guión bajo en el nombre de la función es una
			convención de nombres. Las funciones con un nombre así están
			pensadas para ser usados de forma privada por su propia clase
			y por sus clases ascendentes. No deberían ser llamadas
			directamente por cualquier otra clase que no tenga una
			relación de este tipo. En el caso del constructor del módulo,
			la única clase que debería llamarlo es
			<classname>Ebox::Global</classname>.</para>

			<para>La función <methodname>_create</methodname> en
			<classname>EBox::Module</classname> recibe dos argumentos
			desde sus clases hijas. <parameter>name</parameter> es el
			nombre del módulo y es obligatorio;
			<parameter>domain</parameter>es el dominio
			<application>gettext</application> para el módulo, es
			opcional, y <quote>ebox</quote> es su valor por defecto.</para>

			<example>
				<title>Sencillo constructor de un módulo</title>
				<programlisting><![CDATA[sub _create
{
	my $class = shift;
	my $self = $class->SUPER::_create(name => 'dhcp',
					domain => 'ebox-dhcp',
					@_);
	bless ($self, $class);
	return $self;
}]]></programlisting>
			</example>

		</section>

	</section>

	<section id="sect-rootcmds">
		<title>Comandos de root</title>

		<para>El servidor apache bajo el que funciona eBox y cualquier otro
		script de perl que utilice el API de eBox, utilizan un id de usuario
		dedicado. El usuario es normalmente llamado <quote>ebox</quote>. Los
		módulos de eBox necesitan ejecutar ciertos comandos y escribir ciertos
		ficheros con privilegios de root, esto se hace usando
		<application>sudo</application>. El fichero de configuración de
		<application>sudo</application>, <filename>/etc/sudoers</filename>
		contiene una lista de los comandos que <application>sudo</application>
		permitirá al usuario ejecutar como root.</para>

		<para>Cuando un módulo se instala, se borra o se actualiza, la lista
		de comandos se ha de poner al día. eBox tiene el comando
		<command>ebox-sudoers</command> para generar fácilmente el fichero. El
		comando existe para ser llamado por los mantenedores de los paquetes
		en los scripts de post instalación o de desinstalación.</para>

		<para>Para que <command>ebox-sudoers</command> funcione, eBox necesita
		saber que comandos necesita cada uno de sus módulos. Para esto, la
		clase <classname>Ebox::Module</classname> tiene una función abstracta
		llamada <methodname>rootCommands</methodname>. Los módulos implementan
		esta función si quieren añadir nuevos comandos al fichero
		<filename>/etc/sudoers</filename>. Devolverá un array cuyos elementos
		serán los comandos que se deseen ejecutar. La implementación de este
		método en el módulo del firewall es algo así:</para>

		<example>
			<title>Definiendo comandos para ser ejecutados como root</title>
			<programlisting><![CDATA[sub rootCommands
{
	my $self = shift;
	my @array = ();
	push(@array, '/sbin/iptables');
	push(@array, '/sbin/sysctl -q -w net.ipv4.ip_forward*');
	return @array;
}]]></programlisting>
		</example>

		<para>Una vez que tiene definidos todos los comandos que necesita
		ejecutar como root en la función
		<methodname>rootCommands</methodname>, puede llamar a esos comandos
		utilizando la función <methodname>root()</methodname> en el módulo
		perl <classname>EBox::Sudo</classname>. Si el comando falla,
		<methodname>root()</methodname> lanza una excepción interna, para
		asegurarse de que sea capturada si es correcto que el comando falle o
		si desea informar al usuario de una forma distinta. Consulte la sección
		<xref linkend='sect-exceptions'/> para más detalles.</para>

		<!-- FIXME - example -->

	</section>

	<section id="sect-gconf">
		<title><classname>EBox::GConfModule</classname></title>

		<para>eBox utiliza GConf para almacenar su configuración. La
		plataforma de desarrollo ofrece un recubrimiento sobre los <ulink
		url='http://gtk2-perl.sourceforge.net/doc/pod/Gnome2/GConf.html'>
		bindings originales de perl</ulink>. GConf ofrece una sencilla API
		para almacenar y consultar configuración con valores clasificados por
		tipos y organizada jerárquicamente. También nos permite definir
		esquemas limitados para algunas claves de configuración, configurando
		sus tipos y valores por defecto.</para>

		<!-- FIXME - example -->

		<para>La plataforma de desarrollo define un recubrimiento sobre el API
		de GConf más algunas funcionalidades añadidas. El recubrimiento es
		implementado como una clase hija de
		<classname>Ebox::Module</classname>, así que todos los módulos que
		quieren usar GConf heredan de
		<classname>EBox::GConfModule</classname>. Sus hijos automáticamente
		adquieren estas características:</para>

		<itemizedlist>

			<listitem>

				<para>Copias de seguridad automáticos: La primera vez
				que la clave de un valor es modificada, se hace una
				copia de seguridad del árbol completo de configuración
				para ese módulo. Cuando la configuración se guarda, la
				copia de seguridad es automáticamente
				eliminada. Cuando los cambios en la configuración son
				descartados, la copia de seguridad es automáticamente
				recuperada. <classname>EBox::GConfModule</classname>
				implementa las funciones
				<methodname>makeBackup</methodname>,
				<methodname>restoreBackup</methodname> y
				<methodname>revokeConfig</methodname> definidas en la
				clase <classname>EBox::Module</classname>, por lo que
				las clases hijas de
				<classname>EBox::GConfModule</classname> no necesitan
				implementar estas funciones a no ser que se necesite
				algún requisito en especial o almacenar parte de su
				configuración fuera de GConf.</para>


			</listitem>
			<listitem>

				<para>Manejo de errores: Los errores de GConf son
				manejados por la clase recubridora. Ella los traduce
				a excepciones internas.</para>

			</listitem>
			<listitem>

				<para>Instancias de sólo-lectura y sólo-escritura:
				Cuando el módulo es instanciado en modo sólo-lectura,
				la clase recubridora utiliza una copia de la
				configuración para evitar ver que hay cambios sin
				guardar. También previene de llamadas a métodos que
				escriban en GConf.</para>

			</listitem>
			<listitem>

				<para>Comprobación de los límites del espacio de
				nombre: El recubrimiento comprueba todas las claves de
				GConf utilizadas por el módulo, para ver si están en
				su espacio de nombres. Esto asegura que las claves
				para un módulo sólo son leídas o escritas directamente
				por el propio módulo (siempre que todos los módulos
				utilicen esta clase recubridora).</para>

			</listitem>
			<listitem>

				<para>Rutas relativas: las funciones en la clase
				recubridora pueden recibir para las claves de gconf
				tanto rutas absolutas como relativas. La raíz del
				espacio de nombres de un módulo cambia dependiendo del
				tipo de instancia (sólo-lectura o lectura-escritura) y
				el tipo de clave (normal o de estado) a la cual se
				acceda. Por esta razón lo mejor es utilizar rutas
				relativas cuando se llamen a las funciones de la clase
				recubridora, ya que ellas traducen la ruta relativa en
				una ruta absoluta automáticamente.</para>

			</listitem>
			<listitem>

				<para>Estado del espacio de nombres: hay cierta
				información que no es suministrada por el usuario y
				que necesita ser escrita en cualquier momento, incluso
				en las instancias de sólo-lectura. Este tipo de
				información no está sujeta a guardar o cancelar la
				configuración. Es la información de estado, como los
				nombres de los servidores o la dirección IP dada por
				el sistema por un servidor DHCP externo. Un espacio de
				nombres aparte está disponible para este tipo de
				información, y de nuevo es automáticamente apartado de
				las operaciones de copia de seguridad, guardado y
				cancelación mencionadas anteriormente. Las funciones
				que suelen acceder a este espacio de nombres son
				idénticas a las normales, sólo que tienen el prefijo
				<literal>st_</literal> en sus nombres.</para>

			</listitem>

			<listitem>

				<para>Recuperación recursiva de directorios: hay dos
				funciones en <classname>EBox::GConfModule</classname>
				que permiten fácilmente recuperar la estructura
				completa de
				directorios. <methodname>hash_from_dir</methodname>
				toma un directorio como argumento y devuelve un hash
				con todas las claves que están por debajo
				suyo. <methodname>array_from_dir</methodname> toma un
				directorio como argumento y devuelve un array de
				hashes tal y como devuelve
				<methodname>hash_from_dir</methodname> para cada uno
				de sus subdirectorios.</para>

			</listitem>

		</itemizedlist>

		<para>Esta es la lista de las funciones más importantes en
		<classname>EBox::GConfModule</classname>:</para>

		<variablelist>
			<varlistentry>
				<term><methodname>all_dirs</methodname></term>
				<listitem>

					<para>Dada una clave, devuelve todos los
					directorios de su interior.</para>
				
				</listitem>
			</varlistentry>
			<varlistentry>
				<term><methodname>all_dirs_base</methodname></term>
				<listitem>

					<para>Dada una clave, devuelve todos los
					directorios de su interior, eliminando
					cualquier directorio que aparezca por delante.</para>
				
				</listitem>
			</varlistentry>
			<varlistentry>
				<term><methodname>all_entries</methodname></term>
				<listitem>

					<para>Dada una clave, devuelve todas las
					entradas de su interior. Estas entradas son
					todas aquellas claves que no son directorios,
					por lo que contendrán un valor.</para>
					
					</listitem>
				</varlistentry>
				<varlistentry>
					<term><methodname>all_entries_base</methodname></term>
					<listitem>

					<para>Dada una clave, devuelve todas las
					de su interior, eliminando cualquier
					directorio que aparezca por delante. Las
					entradas son todas aquellas claves que no son
					directorios, por lo que contendrán un valor.</para>

				</listitem>
			</varlistentry>
			<varlistentry>
				<term><methodname>array_from_dir</methodname></term>
				<listitem>

					<para>Dada una clave, devuelve un array
					utilizando una referencia a un hash para
					contener en cada elemento los directorios bajo
					su clave. También, el hash contiene la clave
					<structfield>_dir</structfield> que dice cual
					es el nombre del directorio.</para>

				</listitem>
			</varlistentry>
			<varlistentry>
				<term><methodname>dir_exists</methodname></term>
				<listitem>

					<para>Dada una clave que referencia un
					directorio, devuelve <literal>true</literal>
					si existe.</para>

				</listitem>
			</varlistentry>
			<varlistentry>
				<term><methodname>get_bool</methodname></term>
				<listitem>

					<para>Devuelve el valor de una clave de tipo booleano.</para>

				</listitem>
			</varlistentry>
			<varlistentry>
				<term><methodname>get_int</methodname></term>
				<listitem>

					<para>Devuelve el valor de una clave de tipo entero.</para>

				</listitem>
			</varlistentry>
			<varlistentry>
				<term><methodname>get_list</methodname></term>
				<listitem>

					<para>Devuelve un array conteniendo la lista
					referenciada por la clave.</para>

				</listitem>
			</varlistentry>
			<varlistentry>
				<term><methodname>get_string</methodname></term>
				<listitem>

					<para>Devuelve el valor de una clave de tipo cadena.</para>

				</listitem>
			</varlistentry>
			<varlistentry>
				<term><methodname>get_unique_id</methodname></term>
				<listitem>
					
					<para>General un identificado único aleatorio
					con un <parameter>prefix</parameter> delante
					en la raíz del nombre del espacio del
					módulo. Si <parameter>directory</parameter> es
					pasado, será añadido a la ruta. Notar que esto
					no crea la entrada, únicamente devuelve un
					identificador único, así que es tarea del
					programador crear la entrada correctamente.</para>

				</listitem>
			</varlistentry>
			<varlistentry>
				<term><methodname>hash_from_dir</methodname></term>
				<listitem>
					
					<para>Devuelve un hash conteniendo todas las
					entradas del directorio referenciado por la clave.</para>

				</listitem>
			</varlistentry>
			<varlistentry>
				<term><methodname>isReadOnly</methodname></term>
				<listitem>

					<para>Devuelve <literal>true</literal> si la
					instancia actual de
					<classname>EBox::GConfModule</classname> a la
					que se está accediendo es de sólo-lectura.</para>

				</listitem>
			</varlistentry>
			<varlistentry>
				<term><methodname>makeBackup</methodname></term>
				<listitem>

					<para>Vuelca el contenido actual de la
					configuración a un fichero.</para>

				</listitem>
			</varlistentry>
			<varlistentry>
				<term><methodname>restoreBackup</methodname></term>
				<listitem>

					<para>Recupera el último backup.</para>

				</listitem>
			</varlistentry>
			<varlistentry>
				<term><methodname>revokeConfig</methodname></term>
				<listitem>

					<para>Todos los cambios hechos desde que se
					escribió o eliminó algo serán descartados.</para>
					
				</listitem>
			</varlistentry>
			<varlistentry>
				<term><methodname>set_bool</methodname></term>
				<listitem>

					<para>Asigna un <parameter>valor</parameter>
					booleano a una <parameter>clave</parameter>.</para>

				</listitem>
			</varlistentry>
			<varlistentry>
				<term><methodname>set_int</methodname></term>
				<listitem>

					<para>Asigna un <parameter>valor</parameter>
					entero a una
					<parameter>clave</parameter>.</para>

				</listitem>
			</varlistentry>
			<varlistentry>
				<term><methodname>set_list</methodname></term>
				<listitem>

					<para>Asigna una lista de
					<parameter>valores</parameter> de un
					<parameter>tipo</parameter> en un
					<parameter>valor</parameter>.</para>
				
				</listitem>
			</varlistentry>
			<varlistentry>
				<term><methodname>set_string</methodname></term>
				<listitem>

					<para>Asigna un <parameter>valor</parameter>
					de tipo cadena en la <parameter>clave</parameter>.</para>

				</listitem>
			</varlistentry>
		</variablelist>

		<para>Veamos algunos ejemplos de las funciones anteriormente descritas.</para>
		
		<example>
			<title>Asignando un valor de tipo cadena</title>
			<programlisting> <![CDATA[$self->set_string("printers/x4235/name", "fooprinter"); ]]></programlisting>
		</example>

		<example>
			<title>Asignando una lista de cadenas</title>
			<programlisting><![CDATA[$self->set_list('foo/foolist', 'string', ['foo', 'bar']);]]></programlisting>
		</example>

		<example>
			<title>Recogiendo y usando un identificador único</title>
			<programlisting><![CDATA[my $id = $self->get_unique_id('p', 'printers');
$self->set_string("printers/$id/name", $name);
$self->set_bool("printers/$id/configured", undef);
		]]></programlisting>
		</example>
	</section>

	<section id="sect-ordering">
		<title>Ordenando cosas</title>

		<para>La necesidad de mantener cierta información ordenada es muy
		normal en los módulos eBox. También es común ofrecer funciones de
		reordenación. Un ejemplo claro son las reglas del firewall, las cuales
		necesitan ser aplicadas en un cierto orden, y el usuario ha de
		poderles cambiar su orden. La clase <classname>EBox::Order</classname>
		resuelve justamente este problema.</para>
		
		<para>La idea es dar un directorio a cada objeto que se quiere
		mantener ordenado. Siguiendo con el ejemplo del firewall, podríamos
		tener el directorio <filename>rules/</filename> y, por debajo, un
		directorio por regla. Cada regla tendría un identificador único, y eso
		sería el nombre de su directorio bajo <filename>rules/</filename>. Una
		regla con el id <literal>r3561</literal> se almacenaría en
		<filename>rules/r3561</filename>, y debajo de ese directorio se
		almacenarían las claves con cada uno de los parámetros de la
		regla. Ésta es la forma más natural de organizar elementos como reglas
		de firewall, y es con una organización de este tipo para lo que está
		diseñado <classname>EBox::Order</classname> para trabajar.</para>

		<!-- FIXME example -->

		<para>El mecanismo de ordenación añade un campo a los objetos para ser
		ordenados. Lógicamente, se le ha denominado
		<structfield>order</structfield>. Para usar el API de ordenación ha de
		crear una instancia de <classname>EBox::Order</classname>. Su
		constructor toma como argumentos: la instancia del módulo al que
		pertenecen los objetos que van a ser ordenados y el directorio base
		donde los objetos serán almacenados.</para>

		<para><classname>EBox::Order</classname> implementa estas
		operaciones:</para>

		<variablelist>

			<varlistentry>
				<term><methodname>highest</methodname></term>
				<listitem>

					<para>Devuelve la clave
					<structfield>order</structfield> más alta de
					todos los objetos.</para>

				</listitem>
			</varlistentry>

			<varlistentry>
				<term><methodname>lowest</methodname></term>
				<listitem>

					<para>Devuelve la clave
					<structfield>order</structfield> más baja de
					todos los elementos.</para>

				</listitem>
			</varlistentry>

			<varlistentry>
				<term><methodname>nextn</methodname></term>
				<listitem>

					<para>Dado un número, devuelve la clave
					<structfield>order</structfield> del siguiente
					objeto.</para>

				</listitem>
			</varlistentry>

			<varlistentry>
				<term><methodname>prevn</methodname></term>
				<listitem>

					<para>Dado un número, devuelve la clave 
					<structfield>order</structfield> del objeto
					anterior.</para> 

				</listitem>
			</varlistentry>

			<varlistentry>
				<term><methodname>get</methodname></term>
				<listitem>

					<para>Devuelve el identificador del objeto
					cuya clave <structfield>order</structfield> es
					igual a un número dado.</para>

				</listitem>
			</varlistentry>

			<varlistentry>
				<term><methodname>swap</methodname></term>
				<listitem>

					<para>Encuentra los objetos cuyas claves
					<structfield>order</structfield> coinciden con
					los dos números dados e intercambia sus valores.</para>

				</listitem>
			</varlistentry>

			<varlistentry>
				<term><methodname>list</methodname></term>
				<listitem>

					<para>Devuelve una referencia a un array que
					contenga los identificadores de todos los
					objetos, ordenados del más bajo al más alto.</para>

				</listitem>
			</varlistentry>

		</variablelist>

		<example>
			<title>Ordenando las reglas del firewall</title>

			<para>Vamos a ver como utiliza
			<classname>EBox::Order</classname> el módulo firewall para
			mantener sus reglas de forwarding ordenadas. La función
			<methodname>_fwdRulesOrder</methodname> devuelve la instancia
			de <classname>EBox::Order</classname> de las reglas del firewall:</para>
			
			<programlisting><![CDATA[sub _fwdRulesOrder
{
	my $self = shift;
	return new EBox::Order($self, "fwdrules");
}]]></programlisting>

			<para><filename>fwdrules</filename> es el directorio que
			contiene todas las reglas. Otra función auxiliar privada es
			<methodname>_fwdRuleNumber</methodname>, la cual devuelve el
			número de orden para el identificador de una regla dada:</para>

			<programlisting><![CDATA[sub _fwdRuleNumber # (rule)
{
	my ($self, $rule) = @_;
	return $self->get_int("fwdrules/$rule/order");
}]]></programlisting>

			<para>Las nuevas reglas son añadidas al final de la lista, por
			lo que vamos a buscar el número de orden más alto y le
			añadiremos una nueva. Este código es parte de la función
			<methodname>addFwdRule</methodname>:</para>

			<programlisting><![CDATA[my $order = $self->_lastFwdRule() + 1;

$self->set_string("fwdrules/$id/name", $id);
$self->set_string("fwdrules/$id/action", $action);
$self->set_bool("fwdrules/$id/active", 1);
$self->set_int("fwdrules/$id/order", $order);]]></programlisting>

			<para><methodname>_lastFwdRule</methodname> es una función
			recubridora trivial que devuelve el número de orden más alto:</para>

			<programlisting><![CDATA[sub _lastFwdRule
{
	my $self = shift;
	my $order = $self->_fwdRulesOrder();
	defined($order) or return 0;
	return $order->highest;
}]]></programlisting>

			<para>Finalmente hay dos funciones que admiten la reordenación
			de las reglas, éstas son <methodname>FwdRuleUp</methodname> y
			<methodname>FwdRuleDown</methodname> (mostramos sólo la
			primera dado que son prácticamente idénticas):</para>

			<programlisting><![CDATA[sub FwdRuleUp # (rule)
{
	my ($self, $rule) = @_;
	my $order = $self->_fwdRulesOrder();
	defined($order) or return;
	my $num = $self->_fwdRuleNumber($rule);
	if ($num == 0) {
		return;
	}
	my $prev = $order->prevn($num);
	$order->swap($num, $prev);
}]]></programlisting>
		</example>

	</section>

	<section id="sect-config-and-daemons">
		<title>Controlando un demonio</title>

		<para>Además de tener un API que permite leer y cambiar la
		configuración de un servicio dado, el backend de un módulo está a
		cargo de hacer que el servicio funcione. Típicamente, el servicio será
		algún tipo de demonio que ofrezca algunas funcionalidades a través de
		la red después de leer su fichero de configuración. Por tanto, el
		módulo creado necesitará generar el fichero de configuración y
		parar/arrancar/reiniciar el demonio las veces que sea necesario.</para>

		<section id='sect-configfiles'>
			<title>Generación del fichero de configuración</title>

			<para>La forma más sencilla de generar el fichero de
			configuración es usar el sistema de plantillas
			<application>mason</application> el cual es usado también en
			el front-end web. El uso de las plantillas de mason está
			documentado en <xref linkend='sect-mason'/> así que no lo
			repetiremos aquí.</para>

			<para>Las plantillas de mason para los ficheros de
			configuración son instaladas en el directorio
			<filename>stubs</filename> baje el directorio compartido para
			eBox. En el árbol de directorios del código fuente, cada
			módulo también tiene normalmente un directorio llamado
			<filename>stubs</filename>. El fichero
			<filename>Makefile.am</filename> del directorio
			<filename>stubs</filename> para el módulo dnscache tiene esta
			forma:</para>
			
			<programlisting><![CDATA[Stubdir = @STUBSPATH@/dns-cache

nobase_Stub_DATA = named.conf.mas named.conf.options.mas \
	named.conf.local.mas

EXTRA_DIST = $(nobase_Stub_DATA)

MAINTAINERCLEANFILES = Makefile.in]]></programlisting>

			<para>La macro de <application>autoconf</application>, llamada
			<filename>ebox.m4</filename>, incluida automáticamente exporta
			la ruta del directorio stubs como <varname>STUBPATH</varname>,
			por lo que sólo se necesita crear un directorio para el módulo
			en dicha ruta y colocar las plantilla de mason en su
			interior.</para>
			
			<para>Hay un método en <classname>EBox::Module</classname> que
			ofrece ayuda con los permisos de los ficheros y otros
			detalles. Se llama <methodname>writeConfFile</methodname> y
			necesita tres argumentos:</para>
			
			<itemizedlist>
				<listitem>
					<para>La ruta del fichero de configuración que
						va a ser generado.</para>
				</listitem>

				<listitem>
					<para>La ruta de la plantilla de mason
					relativa al directorio stubs.</para>
				</listitem>

				<listitem>
					<para>Una referencia a los argumentos que se
					le quieren pasar a la plantilla de
					mason.</para>
				</listitem>
			</itemizedlist>

			<para><methodname>writeConfFile</methodname>generará el
			fichero de configuración en un directorio temporal y después
			lo copiará encima del fichero que exista en el directorio
			deseado, manteniendo sus propietarios y permisos originales.</para>

			<example>
				<title>Generando un fichero de configuración</title>

				<para>Este es el código que genera el fichero de
				configuración en el módulo ipsec:</para>

				<programlisting><![CDATA[my $self = shift;
my $conns = $self->staticActiveConnsArray();
my $warriors = $self->warriorActiveConnsArray();
my @array = ();

push(@array, 'shared_secret_conns' => $conns);
push(@array, 'road_warrior_conns' => $warriors);
$self->writeConfFile(IPSECCONFFILE, "ipsec/ipsec.conf.mas", \@array);

push(@array, 'includedir' => EBox::Config::conf . "/ipsecrsa/*");
$self->writeConfFile(IPSECSECRETS, "ipsec/ipsec.secrets.mas", \@array);
]]></programlisting>

				<para>Y esta es la plantilla que genera el fichero <filename>ipsec.secrets</filename>:</para>


				<programlisting><![CDATA[<%args>
	@shared_secret_conns => ()
 	$includedir
</%args>

% foreach my $conn (@shared_secret_conns) {
<%$conn->{'lIP'}%> <%$conn->{'rIP'}%> : PSK "<%$conn->{'authinfo'}%>"

% }

include <%$includedir%>]]></programlisting>
			</example>
	
		</section>

		<section>
			<title>Controlando la ejecución</title>

			<para>La primera cosa que necesita saber es cuando iniciar y
			para el demonio que se está controlando. Los servicios son
			arrancados llamando a las funciones
			<methodname>restartService</methodname> o
			<methodname>save</methodname> en la instancia de un módulo,
			sin embargo estos métodos son implementados por
			<classname>EBox::Module</classname> y no deberían ser
			reimplementados normalmente, siendo que controlan los
			registros del sistema y/o guardan los cambios de
			configuración. Ambas funciones llaman a una función abstracta
			cuando necesitan iniciar/reiniciar el servicio. Este método es
			<methodname>_regenConfig</methodname>, y es el que necesita implementar.</para>

			<para><methodname>_regenConfig</methodname> debería generar
			los ficheros de configuración para el demonio e iniciarlo o
			reiniciarlo. Un ejemplo de implementación de este módulo se
			encuentra en <xref linkend='ex-regencfg'/>. Si necesita saber
			cuando la llamada es realizada por el inicio/reinicio del
			servicio o por la petición de guardar los cambios en la
			configuración, puede comprobar los parámetros pasados a
			<methodname>_regenConfig</methodname>. Cuando se llama porque
			la configuración fue guardada
			(<methodname>save()</methodname>) el argumento llamado
			<parameter>save</parameter> será puesto a
			<literal>1</literal>. En la mayoría de situaciones no será
			esto necesario, ya que se puede saber fácilmente si el demonio
			está ejecutándose, y sólo es útil para casos especiales como
			el módulo network.</para>

			<para>Cuando se llama a <methodname>_regenConfig</methodname>,
			probablemente necesite saber cuando iniciar o reiniciar el
			demonio, porque elegir la operación incorrecta podría producir
			un error. Para realizar tal decisión necesita saber si el
			demonio se encuentra funcionando en ese
			momento. <classname>EBox::Module</classname> tiene dos
			funciones para hacer esta tarea más sencilla. Si sabe cual es
			el ID del proceso, puede usar
			<methodname>pidRunning</methodname>. Recibe el ID de un
			proceso como argumento. Si sólo sabe el nombre del fichero
			donde el demonio almacenó su ID de proceso, querrá llamar a la
			función <methodname>pidFileRunning</methodname>, el cual toma
			el nombre de un fichero, comprueba el ID del proceso y llama a
			<methodname>pidRunning</methodname>. Ambas funciones devuelven
			true si el proceso está funcionando y false si no lo está.</para>

			<example id='ex-regencfg'>
			        <title>Ejemplo de implementación de <methodname>_regenConfig</methodname></title>

				<programlisting><![CDATA[sub _regenConfig
{
	my $self = shift;
	$self->_setBindConf;
	$self->_doDaemon();
}

sub _doDaemon
{
	my $self = shift;

	if ($self->service and $self->pidFileRunning(PIDFILE)) {
		$self->_daemon('reload');
	} elsif ($self->service) {
		$self->_daemon('start');
	} elsif ($self->pidFileRunning(PIDFILE)) {
		$self->_daemon('stop');
	}
}

sub _daemon # (action)
{
	my ($self, $action) = @_;
	my $command = BIND9INIT . " " . $action . " 2>&1";

	if ( $action eq 'start') {
		root($command);
	} elsif ( $action eq 'stop') {
		root($command);
	} elsif ( $action eq 'reload') {
		root($command);
	} else {
		throw EBox::Exceptions::Internal(
			"Bad argument: $action");
	}
}]]></programlisting>
				
			</example>

			<para>Parar el servicio es similar. Se puede comprobar si está
			ejecutándose, y si es así, entonces lanzar el comando que lo
			pare. Como con <methodname>restartService</methodname>,
			<classname>EBox::Module</classname> tiene una implementación
			básica de la función <methodname>stopService</methodname>, la
			cual llama a una función abstracta cuando es momento de parar
			el servicio. La función abstracta,
			<methodname>_stopService</methodname> es la que se necesita
			implementar.</para>

			<example>

				<title>Implementación de
				<methodname>_stopService</methodname> de ejemplo</title>

				<programlisting><![CDATA[sub _stopService
{
	my $self = shift;

	if ($self->pidFileRunning(PIDFILE)) {
		$self->_daemon('stop');
	}
}]]></programlisting>
			</example>

		</section>

	</section>

	<section id='sect-schemas'>
		<title>Esquemas de GConf</title>

			<section id='sect-schemas-minimal'> 
			<title>Esquema de GConf mínimo</title>

			<para>Un esquema de GConf es una clave especial de GConf que
			configura el tipo y el valor por defecto de alguna clave de
			GConf. Son almacenados en la base de datos de GConf bajo el
			directorio <filename>/schemas</filename>.</para>

			<para>Necesitará crear un esquema de GConf para el
			módulo. Esto es necesario, al menos para integrar el módulo con
			la plataforma. Por medio de este esquema, el módulo podrá ser
			instanciado. Por tanto, la primera cosas que se deberá hacer
			es asociar el nombre dado para el módulo y su módulo de
			perl. Veamos el ejemplo para clarificar un poco más esta idea:</para>
			
			<para>Digamos que tenemos un módulo llamado
			<emphasis>foobar</emphasis> y la implementación para este
			módulo recae en <classname>EBox::Foobar</classname>. El
			esquema de GConf sería algo así:</para>

			<example>
			<title>Esquema de GConf mínimo</title>
				<programlisting><![CDATA[<gconfschemafile>
<schemalist>
	<schema>
		<key>/schemas/ebox/modules/global/modules/foobar/class</key>
		<applyto>/ebox/modules/global/modules/foobar/class</applyto>
		<owner>ebox</owner>
		<type>string</type>
		<default>EBox::Foobar</default>
		<locale name="C"/>
	</schema>
</schemalist>
</gconfschemafile>]]></programlisting>
			</example>

			<para>Una vez que ha hecho esto, cada vez que se instancie el
			módulo <emphasis>foobar</emphasis> utilizando el método
			<methodname>modInstance</methodname> de
			<classname>EBox::Global</classname>, sabrá que tiene que
			cargar e instanciar la clase
			<classname>EBox::Foobar</classname>.</para>

			<example>
			<title>Creando la instancia de un módulo</title>
			<programlisting><![CDATA[my $foobar = EBox::Global->modInstance('foobar');
$foobar->some_method();]]></programlisting>
			</example>
			
		</section>

		<section id='sect-schemas-default'>
			<title>Valores por defecto</title>

			<para>Los esquemas de GConf son útiles para estableces valores
			por defecto. Estos valores se usarán por el sistema cuando el
			usuario no ha dado un valor a la clave correspondiente.</para>

			<para>Hay un escenario obvio en el cual puede estar interesado
			en utilizar estas características. Este es cuando su módulo es
			instalado por primera vez. Podría ser útil configurar unos
			valores por defecto en la configuración inicial.</para>

			<para>Vamos a ilustrar esto con un pequeño ejemplo. Imagine
			que está desarrollando un módulo para manejar un proxy
			HTTP. Uno de los parámetros configurables es el puerto por
			donde escucha. Desea que el usuario tenga la capacidad de
			cambiarlo, pero también desea que tenga como valor inicial
			configurado, el puerto 3128. El esquema de GConf es el sitio
			ideal para hacerlo. Para este ejemplo, usaremos la clave
			<filename>/schemas/ebox/modules/proxy/port</filename>.</para>

			<example>
				<title>Configurando un valor por defecto en los
				esquemas de GConf</title>
				 <programlisting><![CDATA[<schema>
	<key>/schemas/ebox/modules/proxy/port</key>
	<applyto>/ebox/modules/proxy/port</applyto>
	<owner>ebox</owner>
	<type>int</type>
	<default>3128</default>
	<locale name="C"/>
</schema>]]></programlisting>
			</example>
		</section>
			
		<section id='sect-schemas-dependence'> 
		<title>Dependencias de módulos</title>

			<para>Es cuestión de la configuración de su módulo que pueda
			depender de otros. Si esto ocurre, estará interesado en que le
			sea notificado cada vez que hay un cambio en cualquiera de los
			módulos de los que depende.</para>

			<para>Continuando con el ejemplo utilizado anteriormente,
			considere que desea configurar el proxy para que escuche
			únicamente en los interfaces internos. El módulo
			<emphasis>network</emphasis> se el único que maneja los
			interfaces de red. Así que en el momento de generar la
			configuración del proxy, se le pedirá al módulo
			<emphasis>network</emphasis> los interfaces de red
			configurados como internos. Esto levanta una duda obvia, el
			módulo debería regenerar su configuración cuando el interfaz
			interno cambia, esto es, cuando la configuración del módulo
			<emphasis>network</emphasis> cambie.</para>

			<para>Para expresar esta relación de dependencia haremos uso
			del esquema de gconf del módulo de esta forma:</para>

			<example>
				<title>Configurando dependencias entre módulos</title>
				 <programlisting><![CDATA[<schema>
	<key>/schemas/ebox/modules/global/modules/proxy/depends</key>
	<applyto>/ebox/modules/global/modules/proxy/depends</applyto>
	<owner>ebox</owner>
	<type>list</type>
	<list_type>string</list_type>
	<default>[network]</default>
	<locale name="C"/>
</schema>]]></programlisting>
			</example>

			<para>El trozo de código le dice al módulo global que proxy
			depende de network. De esta forma, el módulo global lanzará la
			función <methodname>_regenConfig</methodname> de
			<classname>EBox::Proxy</classname> cuando la configuración del
			módulo de red cambie.</para>

			<!-- FIXME - sintax for multiple dependencies-->

		</section>
	</section>

	<section id="sect-cfgback">
		<title>Copia de seguridad de las configuraciones</title>

		<para>Como señalábamos con anterioridad, todos los cambios hechos en
		las claves almacenadas en gconf son automáticamente guardados la
		primera vez que se efectúa una operación de escritura o borrado. En
		consecuencia, todos esos cambios pueden ser recuperados
		automáticamente si el usuario desea descartar o recuperarlos de un
		fichero. Por supuesto esto ocurre siempre que se usen las funciones
		provistas a tal efecto por <classname>EBox::GConfModule</classname>.</para>

		<para>Si su módulo tiene alguna otra cosa que no es almacenada en
		gconf y necesita un tratamiento especial para realizar su copia de
		seguridad, deberá reimplementar los métodos
		<methodname>_dump_to_file</methodname> y
		<methodname>_load_from_file</methodname>.</para> 

		<para>El módulo <emphasis>ipsec</emphasis> tiene sus claves RSA fuera
		de GConf, por lo que cuando llega el momento de realizar una copia de
		seguridad de éstas, necesita controlarlas de la siguiente manera:</para>
		
		<example>
			<title>Sobreescribiendo funciones para las copias de seguridad</title>
				<programlisting><![CDATA[sub _dump_to_file # (dir?)
{
	my ($self, $dir) = @_;
	$self->SUPER::_dump_to_file($dir);
	($dir) or $dir = EBox::Config::conf;
	my $origdir = EBox::Config::conf . "/ipsecrsa";
	if ( -e "$dir/ipsecrsa.bak") {
		rmtree("$dir/ipsecrsa.bak") or 
			throw EBox::Exceptions::Internal(__(
			  'Error mientras se eliminaba la copia de seguridad de las
				antiguas claves rsa'));
	}
	mkdir("$dir/ipsecrsa.bak", 0700) or 
		throw EBox::Exceptions::Internal(__(
		  'Error while making backup dir for rsa keys'));
	my @keys = @{$self->listRSAKeys()};
	foreach my $key (@keys) {
		next unless (-f "$origdir/$key");
		copy("$origdir/$key", "$dir/ipsecrsa.bak") or
			throw EBox::Exceptions::Internal(
				__('Error durante la copia de seguridad de las claves rsa'));
	}
}

sub _load_from_file # (dir?)
{
	my ($self, $dir) = @_;
	$self->SUPER::_load_from_file($dir);
	($dir) or $dir = EBox::Config::conf;
	my $destdir = EBox::Config::conf . "/ipsecrsa";
	( -d "$dir/ipsecrsa.bak") or
		throw EBox::Exceptions::Internal(
			__('copia de seguridad de las claves rsa no encontrado'));
	if ( -e "$destdir") {
		rmtree($destdir) or throw EBox::Exceptions::Internal(
			__('Error durante la eliminación de las claves rsa'));
	}
	mkdir("$destdir", 0700) or 
		throw EBox::Exceptions::Internal(__(
		  'Error durante la creación del directorio para las claves rsa'));

	my @keys = @{$self->listRSAKeys()};
	foreach my $key (@keys) {
		next unless (-f "$dir/ipsecrsa.bak/$key");
		copy("$dir/ipsecrsa.bak/$key", "$destdir") or
			throw EBox::Exceptions::Internal(
				__('Error durante la recuperación de las claves rsa'));
	}
}]]></programlisting>
		</example>
		
	</section>		

</chapter>

 