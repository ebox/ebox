# Copyright (C) 2005  Warp Networks S.L., DBS Servicios Informaticos S.L.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License, version 2, as
# published by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

package EBox::DNS;

use strict;
use warnings;

use base qw(EBox::GConfModule 
			EBox::Model::ModelProvider 
			EBox::Model::CompositeProvider
			EBox::ServiceModule::ServiceInterface);

use EBox::Objects;
use EBox::Gettext;
use EBox::Service;
use EBox::Summary::Module;
use EBox::Summary::Status;
use EBox::Menu::Item;
use EBox::Sudo qw( :all );
use EBox::Validate qw( :all );
use EBox::DNS::Model::DomainTable;
use EBox::DNS::Model::HostnameTable;
use EBox::DNS::Model::AliasTable;
use EBox::DNS::Model::DNSComposite;
use EBox::Model::ModelManager;

use constant BIND9CONFDIR => "@BIND9CONFDIR@";
use constant BIND9CONFFILE => "@BIND9CONF@";
use constant BIND9CONFOPTIONSFILE => "@BIND9CONFOPTIONS@";
use constant BIND9CONFLOCALFILE => "@BIND9CONFLOCAL@";
use constant BIND9INIT     => "@BIND9_INIT@";
use constant PIDFILE       => "/var/run/bind/run/named.pid";

sub _create 
{
	my $class = shift;
	my $self = $class->SUPER::_create(name => 'dns', 
                                          domain => 'ebox-dns',
                                          printableName => __('dns'),
                                          @_);

	bless($self, $class);
	return $self;
}

# Method: modelClasses
#
# Overrides:
#
#       <EBox::ModelProvider::modelClasses>
#
sub modelClasses
{
    return [
            {
             class      => 'EBox::DNS::Model::DomainTable',
             parameters => [
                            directory => 'domainTable',
                           ],
            },
            {
             class      => 'EBox::DNS::Model::HostnameTable',
             parameters => [
                            directory => 'hostnameTable',
                           ],
            },
            {
             class      => 'EBox::DNS::Model::AliasTable',
             parameters => [
                            directory => 'aliasTable',
                           ],
            },
            {
             class => 'EBox::DNS::Model::EnableFormDNS',
             parameters => [
                            enableTitle => __('DNS Server'),
                            modelDomain => 'DNS',
                            domain      => 'ebox-dns',
                            directory   => 'enableForm',
                           ],
            }
           ];
}

# Method: _exposedMethods
#
#
# Overrides:
#
#      <EBox::Model::ModelProvider::_exposedMethods>
#
# Returns:
#
#      hash ref - the list of the exposes method in a hash ref every
#      component
#
sub _exposedMethods
  {

      my %exposedMethods =
        (
         'addDomain1' => { action   => 'add',
                          path     => [ 'DomainTable' ],
                        },
         'removeDomain' => { action  => 'del',
                             path    => [ 'DomainTable' ],
                             indexes => [ 'domain' ],
                           },
         'addHostName' => { action  => 'add',
                            path    => [ 'DomainTable', 'hostnames' ],
                            indexes => [ 'domain' ],
                          },
         'setIP'       => { action   => 'set',
                            path     => [ 'DomainTable', 'hostnames' ],
                            indexes  => [ 'domain', 'hostname' ],
                            selector => [ 'ipaddr' ]
                          },
         'getHostName' => { action   => 'get',
                            path     => [ 'DomainTable', 'hostnames' ],
                            indexes  => [ 'domain', 'hostname' ],
                          },
         'removeHostName' => { action => 'del',
                               path   => [ 'DomainTable', 'hostnames' ],
                               indexes => [ 'domain', 'hostname' ],
                             },
         'addAlias'    => { action  => 'add',
                            path    => [ 'DomainTable', 'hostnames', 'alias' ],
                            indexes => [ 'domain', 'hostname' ],
                          },
         'removeAlias' => { action  => 'del',
                            path    => [ 'DomainTable', 'hostnames', 'alias' ],
                            indexes => [ 'domain', 'hostname', 'alias' ],
                          },
         'changeAlias' => { action   => 'set',
                            path     => [ 'DomainTable', 'hostnames', 'alias' ],
                            indexes  => [ 'domain', 'hostname', 'alias' ],
                            selector => [ 'alias' ],
                          },
         );

      return \%exposedMethods;

  }

# Method: compositeClasses
#
# Overrides:
#
#    <EBox::Model::CompositeProvider::compositeClasses>
#
sub compositeClasses
{
 return [
         'EBox::DNS::Model::DNSComposite',
        ];
}

# Method: addDomain
#
# 	Add new domain to table model
#
# Parameters:
#
#       Check <EBox::DNS::Model::DomainTable> for details
#
sub addDomain
{
	my ($self, $domainData) = @_;

	my $domainModel = EBox::Model::ModelManager->instance()->model('DomainTable');

	$domainModel->addDomain($domainData);
}

# Method: domains
# 	returns an array with all domain names
#
# Returns:
# 	an array ref
# 	
sub domains
{
	my $self = shift;
	my @array;

	my $model = EBox::Model::ModelManager->instance()->model('DomainTable');

	foreach my $row(@{$model->printableValueRows()})
	{
		my $domaindata;

		$domaindata->{'name'} = $row->{'domain'};

		push(@array, $domaindata);
	}

	return \@array;
}

# Method: hostnames
# 	returns an array with all hostname structure
#
# Parameters:
# 	array with all printable values of a domain
#
# Returns:
#		array ref with this structure data:
#		
#		'name': hostname
#		'ip': ip address of hostname
#		'aliases': an array ref returned by <EBox::DNS::aliases> method.
# 	
sub hostnames
{
	my ($self, $data) = @_;
	my @array;

	foreach my $hostname(@{$data})
	{
		my $hostdata;

		$hostdata->{'name'} = $hostname->{'hostname'};
		$hostdata->{'ip'} = $hostname->{'ipaddr'};
		$hostdata->{'aliases'} = $self->aliases($hostname->{'alias'}->{'values'});

		push(@array, $hostdata);
	}

	return \@array;
}

# Method: getHostnames
#
#       Given a domain name, it returns an array ref of hostnames that
#       it contains.
#
# Parameters:
#
#       domain - String the domain's name
#
# Returns:
#
#       array ref - containing the same structure as
#       <EBox::DNS::hostnames> returns
#
sub getHostnames
{

    my ($self, $domain) = @_;

    my $domainModel = $self->model('DomainTable');
    my $domainRowId = $domainModel->findId(domain => $domain);

    unless ( defined($domainRowId) ) {
        throw EBox::Exceptions::DataNotFound(data  => __('domain'),
                                             value => $domain);
    }
    my $hostnameModel = $self->model('HostnameTable');
    $hostnameModel->setDirectory($domainModel->directory()
                                 . "/keys/$domainRowId/hostnames");

    return $self->hostnames($hostnameModel->printableValueRows());

}

# Method: aliases
# 	returns an array with all alias structure of a hostname
#
# Parameters:
# 	array with all printable values of a hostname
#
# Returns:
#		array ref with this structure data:
#		
#		'name': alias name
# 	
sub aliases
{
	my ($self, $data) = @_;
	my @array;

	foreach my $alias(@{$data})
	{
		my $aliasdata;

		$aliasdata->{'name'} = $alias->{'alias'};

		push(@array, $aliasdata);
	}

	return \@array;
}

# Method: completeDomain
# 	returns a structure with all necesary data to build bind db config files
#
# Parameters:
# 	domain name
#
# Returns:
#		structure data with:
#		
#		'name': domain name
#		'hosts': an array ref returned by <EBox::DNS::hostnames> method.
# 	
sub completeDomain # (domain)
{
	my ($self, $domain) = @_;
	my $model = EBox::Model::ModelManager->instance()->model('DomainTable');
	my $domdata;

	my $row = $model->find(domain => $domain->{'name'});
	$domdata->{'name'} = $domain->{'name'};
	$domdata->{'hosts'} = $self->hostnames($row->{'hostnames'}->{'values'});
	
	return $domdata;
}

# Method: createHostDataArray
# 	returns host and their alias info in a single hosts array ref.
#
# Parameters:
# 	hostip: less significant ip address block of a host.
# 	hostData: host and alias info
#
# Returns:
# 	array ref
sub createHostDataArray
{
	my ($self, $hostip, $hostData) = @_;
	my @newHostsDataArray;
	
	# Add host info
	my $newHostData;
	$newHostData->{'name'} = $hostData->{'name'};
	$newHostData->{'ip'} = $hostip;
	push(@newHostsDataArray, $newHostData);
	
	# Add all alias info
	foreach my $aliasData (@{$hostData->{'aliases'}})
	{
		my $newHostDataFromAlias;
		$newHostDataFromAlias->{'name'} = $aliasData->{'name'};
		$newHostDataFromAlias->{'ip'} = $hostip;
		push(@newHostsDataArray, $newHostDataFromAlias);
	}

	return \@newHostsDataArray;
}

# Method: updateReversedData
# 	updates or adds new item to the array data passed as parameters
#
# Parameters:
# 	array ref that holds reversed info data
# 	groupIDData structure to update or add
#
sub updateReversedData
{
	my ($self, $reversedData, $groupIPData) = @_;
	# Try to find an previously added groupip item (from other domain)
	my $pos = -1;
	for(my $i = 0; $i < @{$reversedData}; $i++)
	{
		if($reversedData->[$i]->{'groupip'} eq $groupIPData->{'groupip'})
		{
			my $jpos = -1;
			for(my $j = 0; $j < @{$reversedData->[$i]->{'domain'}}; $j++)
			{
				if($reversedData->[$i]->{'domain'}->[$j]->{'name'}
						eq $groupIPData->{'domain'}->{'name'})
				{
					push(@{$reversedData->[$i]->{'domain'}->[$j]->{'hosts'}},
							@{$groupIPData->{'domain'}->{'hosts'}});
					$jpos = $j;
					last;
				}
			}

			if($jpos < 0)
			{
				push(@{$reversedData->[$i]->{'domain'}}, $groupIPData->{'domain'});
			}
			$pos = $i;
			last;
		}
	}
	
	if($pos < 0)
	{
		my $item;
		$item->{'groupip'} = $groupIPData->{'groupip'};
		push(@{$item->{'domain'}}, $groupIPData->{'domain'});
		push(@{$reversedData}, $item);
	}
}

# Method: switchToReverseInfoData
# 	returns a structure with all necesary data to build reverse db config
# 	files.
#
# Parameters:
# 	array ref structure returned by <EBox::DNS::completeDomain>
#
# Returns:
# 	array ref structure data with:
#
#		'groupip': ip range to define a zone file info
#		'domain': an array of hosts and domain data:
#				'name': domain name
#				'hosts': an array of hostnames and hostip:
#						'ip': less significant block of an ip address
#						'name': name of the host in the domain
#
sub switchToReverseInfoData
{
	my ($self, $info) = @_;
	my @reversedData;

	foreach my $domainData (@{$info})
	{
		my $domain = $domainData->{'name'};

		foreach my $hostData (@{$domainData->{'hosts'}})
		{
			my @ipblocks = split(/\./, $hostData->{'ip'});

			#Set group ip bind format (reverse order)
			my $groupip = join(".", $ipblocks[2], $ipblocks[1], $ipblocks[0]);
			my $hostip = $ipblocks[3];
			
			my $newDomainData;
			$newDomainData->{'name'} = $domain;
			$newDomainData->{'hosts'} = $self->createHostDataArray($hostip, $hostData);

			my $groupIPData;
			$groupIPData->{'groupip'} = $groupip;
			$groupIPData->{'domain'} = $newDomainData;

			$self->updateReversedData(\@reversedData, $groupIPData);
		}
	}

	return \@reversedData;
}

# Method: actions
#
# 	Override EBox::ServiceModule::ServiceInterface::actions
#
sub actions
{
	return [ 
	{
		'action' => __('Remove bind9 init script link'),
		'reason' => __('eBox will take care of starting and stopping ' .
						'the services.'),
		'module' => 'dns'
	}
    ];
}


# Method: usedFiles
#
#	Override EBox::ServiceModule::ServiceInterface::usedFiles
#
sub usedFiles
{
	my ($self) = @_;
	my $files = 	[{
		 'file' => BIND9CONFFILE,
		 'module' => 'dns',
 	 	 'reason' => 'main bind9 configuration file'
		},
		{
		 'file' => BIND9CONFOPTIONSFILE,
		 'module' => 'dns',
 	 	 'reason' => 'main bind9 options configuration file'
		},
		{
		 'file' => BIND9CONFLOCALFILE ,
		 'module' => 'dns',
 	 	 'reason' => 'local bind9 options configuration file'
		}
	       ];


	my @domains = @{$self->domains()};

	my @domainData;
	foreach my $domain (@domains)
	{
		my $domdata = $self->completeDomain($domain);
		push(@domainData, $domdata);
		my $file = BIND9CONFDIR . "/db." . $domdata->{'name'};
		push (@{$files}, 
						{
							 'file' => $file,
							 'module' => 'dns',
							 'reason' => __x('configuration file for zone {zone}', zone => $file )
						});

	}

	my $reversedData = $self->switchToReverseInfoData(\@domainData);
	my @inaddrs;
	foreach my $reversedDataItem(@{$reversedData})
	{
		my $file = BIND9CONFDIR . "/db." . $reversedDataItem->{'groupip'};
		push (@{$files}, 
						{
							 'file' => $file,
							 'module' => 'dns',
							 'reason' => __x('configuration file for reverse resolution zone {zone}', zone => $file )
						});


	}

	return $files;
}

# Method: enableActions 
#
# 	Override EBox::ServiceModule::ServiceInterface::enableActions
#
sub enableActions
{
    root(EBox::Config::share() . '/ebox-dns/ebox-dns-enable');
}


# Method: serviceModuleName 
#
#	Override EBox::ServiceModule::ServiceInterface::serviceModuleName
#
sub serviceModuleName
{
	return 'dns';
}

sub _doDaemon
{
	my $self = shift;

	if ($self->service and EBox::Service::running('ebox.bind9')) {
		EBox::Service::manage('ebox.bind9','restart');
	} elsif ($self->service) {
		EBox::Service::manage('ebox.bind9','start');
	} elsif (EBox::Service::running('ebox.bind9')) {
		EBox::Service::manage('ebox.bind9','stop');
	}
}

sub _stopService
{
	EBox::Service::manage('ebox.bind9','stop');
}
# Method: service
#
#      Check whether the Events service is enabled or not
#
# Returns:
#
#      boolean - the service is enabled or not
#
sub service
{

	my ($self) = @_;
	
	return $self->isEnabled();
}

# Method: setService
#
#      Set if the events service is enabled or not
#
# Parameters:
#
#      enabled - boolean service to be enabled or not
#
sub setService
{

	my ($self, $enabled) = @_;

	$self->enableService($enabled)
}

# Method: _regenConfig
#
#       Overrides base method. It regenertates the dhcp service configuration
#
sub _regenConfig
{
	my $self = shift;

	$self->_setBindConf;
	$self->_doDaemon();
}

sub _setBindConf
{
	my $self = shift;
	my @array = ();

	$self->writeConfFile(BIND9CONFFILE, 
				"dns/named.conf.mas", 
				\@array);
	$self->writeConfFile(BIND9CONFOPTIONSFILE, 
				"dns/named.conf.options.mas", 
				\@array);

	my @domains = @{$self->domains()};

#	push(@array, 'domains' => \@domains);
#	$self->writeConfFile(BIND9CONFLOCALFILE, 
#				"dns/named.conf.local.mas", 
#				\@array);

#	root("/bin/rm -rf " . BIND9CONFDIR . "/zones/");
#	root("/bin/mkdir " . BIND9CONFDIR . "/zones/");

	my @domainData;
	foreach my $domain (@domains)
	{
		my $domdata = $self->completeDomain($domain);
		push(@domainData, $domdata);

		my $file = BIND9CONFDIR . "/db." . $domdata->{'name'};
		@array = ();
		push(@array, 'domain' => $domdata);
		$self->writeConfFile($file,"dns/db.mas",\@array);
	}

	my $reversedData = $self->switchToReverseInfoData(\@domainData);

	my @inaddrs;
	foreach my $reversedDataItem(@{$reversedData})
	{
		my $file = BIND9CONFDIR . "/db." . $reversedDataItem->{'groupip'};
		push(@inaddrs, $reversedDataItem->{'groupip'});
		@array = ();
		push(@array, 'rdata' => $reversedDataItem);
		$self->writeConfFile($file, "dns/dbrev.mas", \@array);
	}

	push(@array, 'domains' => \@domains);
	push(@array, 'inaddrs' => \@inaddrs);
	$self->writeConfFile(BIND9CONFLOCALFILE, 
				"dns/named.conf.local.mas", 
				\@array);
}

sub statusSummary
{
	my $self = shift;
	return new EBox::Summary::Status('dns', __('DNS'),
		EBox::Service::running('ebox.bind9'), $self->service);
}

sub configureFirewall
{
	my ($self) = @_;

	my $fw = EBox::Global->modInstance('firewall');	

	if ($self->service()) {
		$fw->addOutputRule('udp', 53);
		$fw->addOutputRule('tcp', 53);
	} else {
		$fw->removeOutputRule('udp', 53);
		$fw->removeOutputRule('tcp', 53);
	}
}

sub onInstall
{
	EBox::init();
	_addDNSService();
	my $fw = EBox::Global->modInstance('firewall');
	$fw->setInternalService('dns', 'accept');
	$fw->saveConfigRecursive();
}

# Method: menu 
#
#       Overrides EBox::Module method.
#
sub menu
{
        my ($self, $root) = @_;
        $root->add(new EBox::Menu::Item('url' => 'DNS/Composite/DNSComposite',
                                        'text' => __('DNS')));
}

sub _addDNSService
{
   my $serviceMod = EBox::Global->modInstance('services');

   if (not $serviceMod->serviceExists('name' => 'dns')) {
       $serviceMod->addService('name' => 'dns',
           'protocol' => 'udp',
           'sourcePort' => 'any',
           'destinationPort' => 53,
           'internal' => 1,
	   'readOnly' => 1);

   } else {
       $serviceMod->setService('name' => 'dns',
           'protocol' => 'udp',
           'sourcePort' => 'any',
           'destinationPort' => 53,
           'internal' => 1,
	   'readOnly' => 1);
       EBox::info("Not adding dns service as it already exists");
   }

   $serviceMod->save();

}

1;
