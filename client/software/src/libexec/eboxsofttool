#!/usr/bin/perl

# Copyright (C) 2005 Warp Netwoks S.L., DBS Servicios Informaticos S.L.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License, version 2, as
# published by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

use AptPkg::Config;
use Digest::MD5;
use AptPkg::Cache;
use AptPkg::System qw($_system);
use AptPkg::Version;
use Storable qw(store_fd);

my $fetched = [];
my $nonfetched = [];
my $visited;

# Method: listEBoxPkgs
# 	
# 	Returns an array of hashes with the following fields:
#	name - name of the package
#	description - short description of the package
#	version - version installed (if any)
#	avail - latest version available
#	removable - true if the package can be removed
#
# Returns:
#
# 	array ref of hashes holding the above keys
sub listEBoxPkgs
{
	my $cache = AptPkg::Cache->new;
	my $versioning = $AptPkg::System::_system->versioning();
	my @pkgs = grep(/^ebox/, $cache->keys());
	my @array = ();

	# WARNING - do not move this line before the $cache->keys() call
	my $records = $cache->packages();

        foreach my $p (@pkgs) {
                my $pkg = $cache->{$p};
                my $h;
                $h->{name} = $pkg->{Name};
		if(($h->{name} eq 'ebox') or ($h->{name} eq 'ebox-software')){
			$h->{removable} = 0;
		}else{
			$h->{removable} = 1;
		}
                my $available = $pkg->{VersionList} or next;
                my $curver = undef;
                if ($pkg->{CurrentVer}) {
                        $curver = $pkg->{CurrentVer}{VerStr};
                        $h->{version} = $pkg->{CurrentVer}{VerStr};
                }
		my $curverobject;
                foreach my $v (@{$available}) {
                        if (!$curver) {
                                $curver = $v->{VerStr};
				$curverobject = $v;
                        } elsif ($versioning->compare
                                        ($curver, $v->{VerStr}) < 0) {
                                $curver = $v->{VerStr};
				$curverobject = $v;
                        }
                }
		my @depends = ();
		if($curverobject->{DependsList}) {
			@depends = @{$curverobject->{DependsList}};
		}
		$h->{depends} = [];
		foreach my $dep (@depends) {
			push(@{$h->{depends}}, $dep->{TargetPkg}{Name});
		}
		if (pkgIsFetched($p)) {
			$h->{avail} = $curver;
		} else {
			unless (defined($h->{version})) {
				next;
			}
			$h->{avail} = $h->{version};
		}
		my $info = $records->lookup($pkg->{Name});
                $h->{avail} = $curver;
                $h->{description} = $info->{ShortDesc};
		push(@array, $h);
        }

	return \@array;
}

sub _pkgIsFetched # (pkg, cache, versioning, records)
{
	my ($p, $cache, $versioning, $records) = @_;

	my $pquoted = quotemeta($p);

	if (grep(/^$pquoted$/, @{$fetched})) {
		return 1;
	}
	if (grep(/^$pquoted$/, @{$notfetched})) {
		return undef;
	}

	if (grep(/^$pquoted$/, @{$visited})) {
		return 1;
	} else {
		push(@{$visited}, $p);
	}

	my $pkg = $cache->{$p};

	my $provides = $pkg->{ProvidesList};
	if (defined($provides) and (scalar(@{$provides}) > 0)) {
		foreach my $provide (@{$provides}) {
			my $depFetched = _pkgIsFetched(
					$provide->{OwnerPkg}->{Name}, 
					$cache, 
					$versioning, 
					$records);
			if ($depFetched) {
				push(@{$fetched}, $p);
				return 1;
			}
		}
	}

	my $available = $pkg->{VersionList};
	unless (defined($available)) {
		push(@{$notfetched}, $p);
		return undef;
	}

	my $curver = undef;
	my $arch = undef;
	my $curverobject = undef;
	if ($pkg->{CurrentVer}) {
		$curver = $pkg->{CurrentVer}{VerStr};
		$curverobject = $pkg->{CurrentVer};
	}
	foreach my $v (@{$available}) {
		if (!$curver) {
			$curver = $v->{VerStr};
			$arch = $v->{Arch};
			$curverobject = $v;
		} elsif ($versioning->compare
				($curver, $v->{VerStr}) < 0) {
			$curver = $v->{VerStr};
			$arch = $v->{Arch};
			$curverobject = $v;
		}
	}
	if ($pkg->{CurrentVer}) {
		if ($curver eq $pkg->{CurrentVer}{VerStr}) {
			push(@{$fetched}, $p);
			return 1;
		}
	}
	# package not installed or upgrade available
	my $info = $records->lookup($pkg->{Name});

	#my $file = $info->{FileName};
	#$file =~ s/^.*\///;
	my $file = "$p" . "_$curver"."_$arch.deb";
	$file =~ s/:/%3a/g;


	unless ( -f "/var/cache/apt/archives/$file" ) {
		push(@{$notfetched}, $p);
		return undef;
	}
	unless (open(MD5, "/var/cache/apt/archives/$file")) {
		push(@{$notfetched}, $p);
		return undef;
	}
	my $md5 = Digest::MD5->new;
	$md5->addfile(*MD5);
	my $digest = $md5->hexdigest;
	close(MD5);

	my $expected = $info->{MD5Hash};
	unless ($expected eq $digest) {
		push(@{$notfetched}, $p);
		return undef;
	}

	# package is fetched, check dependencies
	my @depends = ();
	if($curverobject->{DependsList}) {
		@depends = @{$curverobject->{DependsList}};
	}
	my $skip = 0;
	foreach my $dep (@depends) {
		my $or = $dep->{CompType} & AptPkg::Dep::Or;
		if ($skip) {
			$skip = $or;
			next;
		}
		$skip = 0;

		if (($dep->{DepType} ne "Depends") and 
			($dep->{DepType} ne "PreDepends")) {
			next;
		}

		my $pkgFetched = _pkgIsFetched($dep->{TargetPkg}{Name}, 
							$cache, 
							$versioning, 
							$records);
		if ($pkgFetched) {
			if ($or) {
				$skip = 1;
			}
			next;
		} else {
			if ($or) {
				next;
			} else {
				push(@{$notfetched}, $p);
				return undef;
			}
		}
	}
	push(@{$fetched}, $p);
	return 1;
}

# Method: pkgIsFetched
#	
#	Checks if a package has been already fetched.
#
# Parameters:
#
# 	pkgname - package name
#
sub pkgIsFetched # (pkgname)
{
	my ($pkg) = @_;

	my $cache = AptPkg::Cache->new;
	my $versioning = $AptPkg::System::_system->versioning();
	my $records = $cache->packages();
	$visited = [];
	return _pkgIsFetched($pkg, $cache, $versioning, $records);
}

# Method: listUpgradablePkgs
#	
#	Returns a list of those packages which are ready to be upgraded
#
# Parameters:
#
# 	clear - if set to 1, forces the cache to be cleared
#
# Returns:
#
#	array ref - holding hashes ref containing keys: 'name' and 
#	'description' for each package
sub listUpgradablePkgs 
{
	my $upgrade = [];

	my $file = EBox::Config::tmp . "packagelist";

	my $cache = AptPkg::Cache->new;
	my $versioning = $AptPkg::System::_system->versioning();

	# ebox packages are handled separately
	# kernel-images are not upgraded
	my @packages = grep(!/^(kernel-image)|(ebox)/, $cache->keys());

	# WARNING - do not move this line before the $cache->keys() call
	my $records = $cache->packages();

	foreach my $p (@packages) {
                my $pkg = $cache->{$p};
                ($pkg->{CurrentState} == AptPkg::State::Installed) or next;
                my $available = $pkg->{VersionList} or next;
                my $curver = $pkg->{CurrentVer}{VerStr};
		my $arch;
                foreach my $v (@{$available}) {
                        if ($versioning->compare($curver, $v->{VerStr}) < 0) {
                                $curver = $v->{VerStr};
                                $arch = $v->{Arch};
                        }
                }
                if ($curver eq $pkg->{CurrentVer}{VerStr}) {
                        next;
                }

                my $info = $records->lookup($pkg->{Name});

		#my $file = $info->{FileName};
		#$file =~ s/^.*\///;
		my $pkgfile = "$p" . "_$curver"."_$arch.deb";
		$pkgfile =~ s/:/%3a/g;

		( -f "/var/cache/apt/archives/$pkgfile" ) or next;
		open(MD5, "/var/cache/apt/archives/$pkgfile") or next;
		my $md5 = Digest::MD5->new;
		$md5->addfile(*MD5);
		my $digest = $md5->hexdigest;
		close(MD5);

		my $expected = $info->{MD5Hash};
		($expected eq $digest) or next;

                my $h;
                $h->{name} = $pkg->{Name};
                $h->{description} = $info->{ShortDesc};

                push(@{$upgrade}, $h);
	}
	return $upgrade;
}

if(not defined($ARGV[0])) {
	print "Usage: eboxsofttool [ --ebox | --ebox-info | --upgradable ]\n";
	exit 1;
}

my $return;

if ($ARGV[0] eq "--ebox-info") {
	$return = listEBoxPkgs();
} elsif ($ARGV[0] eq "--upgradable") {
	$return = listUpgradablePkgs();
} else {
	print "Usage: eboxsofttool [ --ebox | --ebox-info | --upgradable ]\n";
	exit 1;
}

store_fd($return,\*STDOUT);
