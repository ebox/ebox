# Copyright (C) 2004  Warp Netwoks S.L.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License, version 2, as
# published by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

package EBox::Squid;
# Simple API to manage squid.conf
# Author: Javier Uruen Val
# Version: 0.21
# Last Modification: 07-01-2004
use strict;
use warnings;

use base 'EBox::GConfModule';

use EBox::Objects;
use EBox::Global;
use EBox::Config;
use EBox::Firewall;
use EBox::Validate qw( :all );
use EBox::Exceptions::InvalidData;
use EBox::Exceptions::Internal;
use EBox::Exceptions::DataNotFound;
use EBox::Sudo qw( :all );
use Data::Dumper;
use Error qw(:try);

#Module local conf stuff
use constant SQUIDCONFILE => "@SQUIDCONF@";
use constant SQUIDINIT    => "/etc/init.d/squid";
use constant PIDFILE      => "/var/run/squid.pid";
#Strings to find tags in our base configuration file
use  constant TAG_ACL   		=> "# <EBOX> TAG_ACL #";
use  constant TAG_HTTP_ACCESS           => "# <EBOX> TAG_HTTP_ACCESS #";
use  constant TAG_HTTP_PORT             => "# <EBOX> TAG_HTTP_PORT #";
use  constant TAG_TRANSPARENT           => "# <EBOX> TAG_TRANSPARENT #";

use  constant TRANSPARENT_CONF          => "httpd_accel_host virtual\n".
		      			   "httpd_accel_port 80\n".
		      			   "httpd_accel_with_proxy on\n".
	      				   "httpd_accel_uses_host_header on\n";

# FIXME use of InvalidData exceptions is wrong all over this file

sub _create {
	my $class = shift;
	my $self  = $class->SUPER::_create(name => 'squid');
	$self->{logger} = EBox::Global->logger();
	bless ($self, $class);
	return $self;
}



sub _doDaemon {
	my $self = shift;
	my $isRunning;
	$isRunning = 1 if ( -f PIDFILE );
	if ( $self->getService eq 'yes'  and $isRunning  ){
		$self->daemon('reload');
	}elsif ( $self->getService eq 'yes' ){
		$self->daemon('start');
	}elsif ( $self->getService eq 'no' and $isRunning){
		$self->daemon('stop');
	}
}

sub stopService($) {
	my $self = shift;
	if ( -f PIDFILE ){
		$self->daemon('stop');
	}
	
}
#Override virtual method in base class
#This method should be called anytime  object's conf changes
#Restart service if module active
sub _regenConfig {
	my $self = shift;
	$self->setSquidConf;
	$self->_doDaemon();
}

#Override virtual method in base class
#Arguments:
#	- Object name
#Returns:
#	- True if  used by this module
#	- False if not used by this module
sub usesObject($$){
	my $self = shift;
	my $object  = shift;
	my $exceps = $self->getExceptions;
	foreach (@{$exceps}) {
		return 1 if ($_ eq $object);
	}
	return undef;
}

#Override virtual method in base class
#Arguments:
#	- Object name
sub freeObject($$){
	my $self = shift;
	my $object  = shift;
	(defined($object) && $object ne "") or return;
	my $exceps = $self->getExceptions;
	my @array = ();
	foreach (@{$exceps}) {
		($_ ne $object) or next;
		push(@array, $_)
	}
	$self->setExceptions(\@array);

}

#changes the global policy
#Pars: 0 -> 'allow'|'deny'
sub setGlobalPolicy {
	my ($self, $policy) = @_;
	if ( $policy ne 'allow' && $policy ne 'deny'){
		throw EBox::Exceptions::Internal(
                        __x("Policy '{polict}' is invalid", policy => $policy));
	}
	$self->{logger}->debug("Setting global policy to $policy");
	$self->set_string("policy", $policy);
}

#returns  the global policy
#'allow'|'deny'
sub getGlobalPolicy {
	my $self = shift;
	return $self->get_string("policy");
}

#creates exceptions for the global policy
#Par: 0- Array with object names
sub setExceptions {
	my ($self, $args) = (@_);
	my $objects = EBox::Global->modInstance('objects');
	$self->unset("exceptions");
	($args) or return;
	foreach (@{$args}){	
	      $objects->objectExists($_) or
		      throw EBox::Exceptions::DataNotFound(
		             'data' => __("object"), 'value' => $_);
        }
	$self->set_list("exceptions", "string", $args);
}

#returns:
#	- array reference with object's overriding global policy
sub getExceptions {
	my $self = shift;
	return $self->get_list("exceptions");
}


#returns true if an Object is an exception to global policy
sub isExcep($$) {
	my ($self, $object) = @_;
	my $exceptions = $self->getExceptions();
	foreach (@{$exceptions}) {
		return 1 if ($_ eq $object);
	}
	return undef;
}
#sets authentication 
#Par: 0 -> 'yes'|'no'  Weird, isn't it?
sub setAuth {
	my ($self, $auth) = @_;
	if ($auth ne 'yes' && $auth ne 'no') {
		throw EBox::Exceptions::InvalidData("Bad argument: $auth");
	}
	$self->set_string("auth", $auth);
}

#returns authentication 
#ret: yes|no
sub getAuth {
	my $self = pop;
	return $self->get_string("auth");
}



sub _confFW {
	my $self = shift;
	my $fw = EBox::Global->modInstance('firewall');
	#FIXME
	try {
		$fw->removeService('squid');
		$fw->removeOutputRule('tcp', 80);
	} catch EBox::Exceptions::Internal with { };

	if ($self->getService eq 'yes') {
		$fw->addService('squid', 'tcp' , $self->getPort);
		$fw->addOutputRule('tcp', 80);
		$fw->setObjectService('_global', 'squid', 'allow');
		if ($self->getTransproxy eq 'yes') {
			$fw->setServiceDNat('squid', 80);
		} else {
			try {
				$fw->unsetServiceDNat('squid');
			} catch EBox::Exceptions::DataNotFound with { };
		}
	} 
}

#sets activation service
#Par: 0-> 'yes'|'no
sub setService {
	my ($self, $active) = @_;
	if ($active ne 'yes' && $active ne 'no') {
		throw EBox::Exceptions::InvalidData("Bad argument: $active");
	}
	$self->set_string("active", $active);
	$self->_confFW;
}

#returns if service is active or not
#ret: yes|no
sub getService {
	my $self = shift;    	
	return $self->get_string("active");
}

#sets transparent proxy service
#Par: 0-> 'yes'|'no
sub setTransproxy {
	my ($self, $trans) = @_;
	if ($trans ne 'yes' && $trans ne 'no') {
		throw EBox::Exceptions::InvalidData("Bad argument: $trans");
	}
	$self->set_string("transproxy", $trans);
	$self->_confFW;
}

#returns if service is active or not
#ret: yes|no
sub getTransproxy {
	my $self = shift;    	
	return $self->get_string("transproxy");
}

#sets port service
#Par: 0-> port_number
sub setPort {
	my ($self, $port) = @_;
	checkPort($port, "listening port");
	# FIXME - check firewall for availability of port (function not
	# implemented yet in firewall)
	$self->set_int("port", $port);
	$self->_confFW;
}

#returns port_number
#ret: port_number
sub getPort {
	my $self = shift;    	
	return $self->get_int("port");
}

#Updates the squid.conf file with xml user conf
sub setSquidConf {
	my $self = shift;
	my ($objects, $httport);
	
	my $auth = $self->getAuth();	
	my $policy = $self->getGlobalPolicy();
	my $objectobj = EBox::Global->modInstance('objects');
	my $exceptions = $self->getExceptions();
	my $httpaccess = "http_access $policy all\n";
	my $except_acl = "listAllow";
	my $ex_statemnt = "http_access allow listAllow\n";
	
	if ($policy eq "allow") {
		$ex_statemnt = "http_access deny listDeny\n";
		$except_acl = "listDeny";
	}
	if (@{$exceptions}) {
		$httpaccess =  $ex_statemnt . $httpaccess;
	}

	foreach (@{$exceptions}) {
		foreach (@{$objectobj->getObjectAddresses($_)}){
			$objects .= "acl $except_acl src  $_\n";
		  }
	}

	$httport = "http_port " . $self->getPort . "\n";
	unless (open (SQUIDCONF, "> " . SQUIDCONFILE)) {
		 throw EBox::Exceptions::Internal(
		 	"Could not open to write ". SQUIDCONFILE . 
			" Check permissions");
	}
	unless  (open (SQUIDBASE, EBox::Config->stubs . "/squid/squid.conf")) {
		throw EBox::Exceptions::Internal(
                	        "Could not open  ". EBox::Config->stubs .
	                	"/squid/squid.conf" );
	}

	my @squidbase = <SQUIDBASE>;
        foreach (@squidbase){
		print SQUIDCONF ;
		print SQUIDCONF "$objects"    if ( /TAG_ACL/);
		print SQUIDCONF "$httpaccess" if ( /TAG_HTTP_ACCESS/);
		print SQUIDCONF "$httport"    if ( /TAG_HTTP_PORT/);
		if ( /TAG_TRANSPARENT/ and $self->getTransproxy eq 'yes'){
			print SQUIDCONF TRANSPARENT_CONF;
		}
	}
       close(SQUIDCONF);
       close(SQUIDBASE);
}


#manage squid via init.d/squid script
#Pars 0: start|stop|restart
sub daemon(){
	my ($self, $action) = @_;
	#FIXME Check return values to see if everything was ok
	my $command =  SQUIDINIT . " " . $action . " 2>&1";
	if ( $action eq 'start') {
		root($command);
		$self->{logger}->info("starting squid");
	}
	elsif ( $action eq 'stop'){
		root($command);
		$self->{logger}->info("stoping squid");
	}
	elsif ( $action eq 'reload'){
		root($command);
		$self->{logger}->info("reloading squid");
	}
	else {
		throw EBox::Exceptions::InvalidData("Bad argument: $action");
	}
	
}

1;
